###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 28/Apr/2019  15:09:20
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  E:\PETPOSITION\KN2000(01)\KAC(3A)_MainDir\bma2x2.c
#    Command line =  
#        "E:\PETPOSITION\KN2000(01)\KAC(3A)_MainDir\bma2x2.c" -e
#        --char_is_signed -On --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_cross_call --debug --code_model medium --data_model
#        medium -o
#        "E:\PETPOSITION\KN2000(01)\KAC(3A)_MainDir\Project\Debug\Obj\"
#        --dlib_config "C:\Program Files\IAR Systems\Embedded Workbench
#        7.0\stm8\LIB\dlstm8mmf.h" -lcN
#        "E:\PETPOSITION\KN2000(01)\KAC(3A)_MainDir\Project\Debug\List\" -lb
#        "E:\PETPOSITION\KN2000(01)\KAC(3A)_MainDir\Project\Debug\List\" -I
#        "E:\PETPOSITION\KN2000(01)\KAC(3A)_MainDir\" -I
#        "E:\PETPOSITION\KN2000(01)\KAC(3A)_libSystem\Libraries\STM8L15x_StdPeriph_Driver\inc\"
#        --vregs 16
#    List file    =  
#        E:\PETPOSITION\KN2000(01)\KAC(3A)_MainDir\Project\Debug\List\bma2x2.lst
#    Object file  =  
#        E:\PETPOSITION\KN2000(01)\KAC(3A)_MainDir\Project\Debug\Obj\bma2x2.o
#
###############################################################################

E:\PETPOSITION\KN2000(01)\KAC(3A)_MainDir\bma2x2.c
      1          /*
      2          ****************************************************************************
      3          * Copyright (C) 2015 - 2016 Bosch Sensortec GmbH
      4          *
      5          * bma2x2.c
      6          * Date: 2016/11/14
      7          * Revision: 2.0.7 $
      8          *
      9          * Usage: Sensor Driver for BMA2x2 sensor
     10          *
     11          ****************************************************************************
     12          * Disclaimer
     13          *
     14          * Common:
     15          * Bosch Sensortec products are developed for the consumer goods industry.
     16          * They may only be used within the parameters of the respective valid
     17          * product data sheet.  Bosch Sensortec products are provided with the
     18          * express understanding that there is no warranty of fitness for a
     19          * particular purpose.They are not fit for use in life-sustaining,
     20          * safety or security sensitive systems or any system or device
     21          * that may lead to bodily harm or property damage if the system
     22          * or device malfunctions. In addition,Bosch Sensortec products are
     23          * not fit for use in products which interact with motor vehicle systems.
     24          * The resale and or use of products are at the purchasers own risk and
     25          * his own responsibility. The examination of fitness for the intended use
     26          * is the sole responsibility of the Purchaser.
     27          *
     28          * The purchaser shall indemnify Bosch Sensortec from all third party
     29          * claims, including any claims for incidental, or consequential damages,
     30          * arising from any product use not covered by the parameters of
     31          * the respective valid product data sheet or not approved by
     32          * Bosch Sensortec and reimburse Bosch Sensortec for all costs in
     33          * connection with such claims.
     34          *
     35          * The purchaser must monitor the market for the purchased products,
     36          * particularly with regard to product safety and inform Bosch Sensortec
     37          * without delay of all security relevant incidents.
     38          *
     39          * Engineering Samples are marked with an asterisk (*) or (e).
     40          * Samples may vary from the valid technical specifications of the product
     41          * series. They are therefore not intended or fit for resale to third
     42          * parties or for use in end products. Their sole purpose is internal
     43          * client testing. The testing of an engineering sample may in no way
     44          * replace the testing of a product series. Bosch Sensortec assumes
     45          * no liability for the use of engineering samples.
     46          * By accepting the engineering samples, the Purchaser agrees to indemnify
     47          * Bosch Sensortec from all claims arising from the use of engineering
     48          * samples.
     49          *
     50          * Special:
     51          * This software module (hereinafter called "Software") and any information
     52          * on application-sheets (hereinafter called "Information") is provided
     53          * free of charge for the sole purpose to support your application work.
     54          * The Software and Information is subject to the following
     55          * terms and conditions:
     56          *
     57          * The Software is specifically designed for the exclusive use for
     58          * Bosch Sensortec products by personnel who have special experience
     59          * and training. Do not use this Software if you do not have the
     60          * proper experience or training.
     61          *
     62          * This Software package is provided `` as is `` and without any expressed
     63          * or implied warranties,including without limitation, the implied warranties
     64          * of merchantability and fitness for a particular purpose.
     65          *
     66          * Bosch Sensortec and their representatives and agents deny any liability
     67          * for the functional impairment
     68          * of this Software in terms of fitness, performance and safety.
     69          * Bosch Sensortec and their representatives and agents shall not be liable
     70          * for any direct or indirect damages or injury, except as
     71          * otherwise stipulated in mandatory applicable law.
     72          *
     73          * The Information provided is believed to be accurate and reliable.
     74          * Bosch Sensortec assumes no responsibility for the consequences of use
     75          * of such Information nor for any infringement of patents or
     76          * other rights of third parties which may result from its use.
     77          * No license is granted by implication or otherwise under any patent or
     78          * patent rights of Bosch. Specifications mentioned in the Information are
     79          * subject to change without notice.
     80          **************************************************************************/
     81          /*! file <BMA2x2 >
     82              brief <Sensor driver for BMA2x2> */
     83          #include "bma2x2.h"
     84          /*! user defined code to be added here ... */
     85          static struct bma2x2_t *p_bma2x2;
     86          /*! Based on Bit resolution value_u8 should be modified */
     87          u8 V_BMA2x2RESOLUTION_U8 = BMA2x2_12_RESOLUTION;//BMA2x2_14_RESOLUTION;
     88          
     89          /****************************************************************************/
     90          /*!	Static Function Declarations
     91          *****************************************************************************/
     92          /*!
     93           *  @brief This API computes the number of bytes of accel FIFO data
     94           *  which is to be parsed.
     95           *
     96           *  @param[out] data_index       : The start index for parsing data
     97           *  @param[out] data_read_length : No of bytes to be parsed from FIFO buffer
     98           *  @param[in] accel_frame_count : Number of accelerometer frames to be read
     99           *  @param[in] fifo_data_select  : Denoting enabled axes data stored in FIFO
    100           *  @param[in] fifo_conf         : FIFO configuration structure
    101           *
    102           */
    103          static void get_accel_len_to_parse(u8 *data_index, u8 *data_read_length,
    104          		u8 accel_frame_count, u8 fifo_data_select,
    105          		struct fifo_configuration *fifo_conf);
    106          
    107          /*!
    108           *  @brief This API is used to parse the accelerometer frame from the
    109           *  user defined FIFO data buffer mapped to the structure fifo_conf and store
    110           *  it in the union fifo_frame
    111           *
    112           *  @note It update the data_index value which is used to store the index of
    113           *  the current data byte which is parsed.
    114           *
    115           *  @note The parsed accel frames stored in the union fifo_conf contains data
    116           *  in accordance with the enabled data axes to be stored in FIFO
    117           *  (XYZ axes or individual axis)
    118           *
    119           *  @param[in,out] accel_frame  : Instance of union fifo_frame
    120           *  @param[in,out] data_index   : Index value of noumber of bytes parsed
    121           *  @param[in,out] accel_index  : Index value of accelerometer frame parsed
    122           *  @param[in] fifo_data_select : Denoting enabled axes data stored in FIFO
    123           *  @param[in] fifo_conf        : FIFO configuration structure
    124           *
    125           */
    126          static void unpack_accel_frame(union fifo_frame *accel_frame, u8 *data_index,
    127          		u8 *accel_index, u8 fifo_data_select,
    128          		struct fifo_configuration *fifo_conf);
    129          
    130          /*!
    131           *  @brief This API is used to parse the accelerometer data and
    132           *  store it in the union fifo_frame
    133           *  It also updates the data_index value which stores the index of
    134           *  the current data byte which is parsed
    135           *
    136           *  @param[in,out] accel_frame  : Instance of union fifo_frame
    137           *  @param[in,out] data_index   : Index value of noumber of bytes parsed
    138           *  @param[in] fifo_conf        : FIFO configuration structure
    139           *
    140           */
    141          static void unpack_accel_xyz(union fifo_frame *accel_frame, u8 *data_index,
    142          		struct fifo_configuration *fifo_conf);
    143          /*!
    144           * @brief
    145           *	This API reads the data from
    146           *	the given register continuously
    147           *
    148           *
    149           *	@param addr_u8 -> Address of the register
    150           *	@param data_u8 -> The data from the register
    151           *	@param len_u32 -> no of bytes to read
    152           *
    153           *
    154           *	@return results of bus communication function
    155           *	@retval 0 -> Success
    156           *	@retval -1 -> Error
    157           *
    158           *
    159           */
    160          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_burst_read(u8 addr_u8,
    161          u8 *data_u8, u32 len_u32)
    162          {
    163          	/* Variable used to return value of
    164          	communication routine*/
    165          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    166          
    167          	if (p_bma2x2 == BMA2x2_NULL) {
    168          		/* Check the struct p_bma2x2 is empty */
    169          		return E_BMA2x2_NULL_PTR;
    170          		} else {
    171          			/* Read the data from the register*/
    172          			com_rslt = p_bma2x2->BMA2x2_BURST_READ_FUNC
    173          			(p_bma2x2->dev_addr, addr_u8, data_u8, len_u32);
    174          		}
    175          	return com_rslt;
    176          }
    177          /*!
    178           *	@brief
    179           *	This function is used for initialize
    180           *	bus read and bus write functions
    181           *	assign the chip id and device address
    182           *	chip id is read in the register 0x00 bit from 0 to 7
    183           *
    184           *	@param bma2x2 : structure pointer
    185           *
    186           *	@return results of bus communication function
    187           *	@retval 0 -> Success
    188           *	@retval -1 -> Error
    189           *
    190           *	@note
    191           *	While changing the parameter of the bma2x2_t
    192           *	consider the following point:
    193           *	Changing the reference value of the parameter
    194           *	will changes the local copy or local reference
    195           *	make sure your changes will not
    196           *	affect the reference value of the parameter
    197           *	(Better case don't change the reference value of the parameter)
    198           *
    199          */
    200          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_init(struct bma2x2_t *bma2x2)
    201          {
    202          	/*  Variable used to return value of
    203          	communication routine*/
    204          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    205          	u8 data_u8 = BMA2x2_INIT_VALUE;
    206          	u8 config_data_u8 = BMA2x2_INIT_VALUE;
    207          	/* assign bma2x2 ptr */
    208          	p_bma2x2 = bma2x2;
    209          	if (p_bma2x2 == BMA2x2_NULL) {
    210          		/* Check the struct p_bma2x2 is empty */
    211          		com_rslt = E_BMA2x2_NULL_PTR;
    212          	} else {
    213          		/* read Chip Id */
    214          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    215          		(p_bma2x2->dev_addr,
    216          		BMA2x2_CHIP_ID_REG, &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
    217          		p_bma2x2->chip_id = data_u8;    /* get bit slice */
    218          		/* read the fifo config register and update
    219          		the value to the fifo_config*/
    220          		com_rslt += bma2x2_read_reg(BMA2x2_FIFO_MODE_REG,
    221          		&config_data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
    222          		p_bma2x2->fifo_config = config_data_u8;
    223          	}
    224          	return com_rslt;
    225          }
    226          /*!
    227           * @brief
    228           *	This API gives data to the given register and
    229           *	the data is written in the corresponding register address
    230           *
    231           *
    232           *	@param adr_u8  -> Address of the register
    233           *	@param data_u8 -> The data to the register
    234           *	@param len_u8 -> no of bytes to read
    235           *
    236           *
    237           *
    238           *	@return results of bus communication function
    239           *	@retval 0 -> Success
    240           *	@retval -1 -> Error
    241           *
    242           *
    243          */
    244          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_write_reg(u8 adr_u8,
    245          u8 *data_u8, u8 len_u8)
    246          {
    247          	/*  Variable used to return value of
    248          	communication routine*/
    249          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    250          
    251          	if (p_bma2x2 == BMA2x2_NULL) {
    252          		/* Check the struct p_bma2x2 is empty */
    253          		return E_BMA2x2_NULL_PTR;
    254          		} else {
    255          		/* Write the data to the register*/
    256          		com_rslt = p_bma2x2->BMA2x2_BUS_WRITE_FUNC
    257          		(p_bma2x2->dev_addr, adr_u8, data_u8, len_u8);
    258          
    259          		if (p_bma2x2->power_mode_u8 != BMA2x2_MODE_NORMAL) {
    260          			/*A minimum interface idle time delay
    261          			of atleast 450us is required as per the data sheet.*/
    262          			p_bma2x2->delay_msec(BMA2x2_INTERFACE_IDLE_TIME_DELAY);
    263          		}
    264          	}
    265          	return com_rslt;
    266          }
    267          /*!
    268           * @brief This API reads the data from
    269           *           the given register address
    270           *
    271           *
    272           *	@param adr_u8 -> Address of the register
    273           *	@param data_u8 -> The data from the register
    274           *	@param len_u8 -> no of bytes to read
    275           *
    276           *
    277           *
    278           *	@return results of bus communication function
    279           *	@retval 0 -> Success
    280           *	@retval -1 -> Error
    281           *
    282           *
    283          */
    284          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_reg(u8 adr_u8,
    285          u8 *data_u8, u8 len_u8)
    286          {
    287          	/*  Variable used to return value of
    288          	communication routine*/
    289          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    290          
    291          	if (p_bma2x2 == BMA2x2_NULL) {
    292          		/* Check the struct p_bma2x2 is empty */
    293          		return E_BMA2x2_NULL_PTR;
    294          		} else {
    295          			/*Read the data from the register*/
    296          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    297          			(p_bma2x2->dev_addr, adr_u8, data_u8, len_u8);
    298          		}
    299          	return com_rslt;
    300          }
    301          /*!
    302           * @brief
    303           *	This API reads acceleration data X values
    304           *	from location 02h and 03h
    305           *
    306           *
    307           *  @param   accel_x_s16 : pointer holding the data of accel X
    308           *		       value       |   resolution
    309           *       ----------------- | --------------
    310           *              0          | BMA2x2_12_RESOLUTION
    311           *              1          | BMA2x2_10_RESOLUTION
    312           *              2          | BMA2x2_14_RESOLUTION
    313           *
    314           *
    315           *	@return results of bus communication function
    316           *	@retval 0 -> Success
    317           *	@retval -1 -> Error
    318           *
    319           *
    320           */
    321          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_x(s16 *accel_x_s16)
    322          {
    323          	/*  Variable used to return value of
    324          	communication routine*/
    325          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    326          	/* Array holding the accel x value
    327          	data_u8[0] - x->LSB
    328          	data_u8[1] - x->MSB
    329          	*/
    330          	u8	data_u8[BMA2x2_ACCEL_DATA_SIZE] = {
    331          	BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE};
    332          	if (p_bma2x2 == BMA2x2_NULL) {
    333          		/* Check the struct p_bma2x2 is empty */
    334          		return E_BMA2x2_NULL_PTR;
    335          		} else {
    336          		switch (V_BMA2x2RESOLUTION_U8) {
    337          		/* This case used for the resolution bit 12*/
    338          		case BMA2x2_12_RESOLUTION:
    339          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    340          			(p_bma2x2->dev_addr,
    341          			BMA2x2_ACCEL_X12_LSB_REG, data_u8,
    342          			BMA2x2_LSB_MSB_READ_LENGTH);
    343          			*accel_x_s16 = (s16)((((s32)((s8)
    344          			data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    345          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    346          			(data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB] &
    347          			BMA2x2_RESOLUTION_12_MASK));
    348          			*accel_x_s16 = *accel_x_s16 >>
    349          			BMA2x2_SHIFT_FOUR_BITS;
    350          		break;
    351          		/* This case used for the resolution bit 10*/
    352          		case BMA2x2_10_RESOLUTION:
    353          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    354          			(p_bma2x2->dev_addr,
    355          			BMA2x2_ACCEL_X10_LSB_REG, data_u8,
    356          			BMA2x2_LSB_MSB_READ_LENGTH);
    357          			*accel_x_s16 = (s16)((((s32)((s8)
    358          			data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    359          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    360          			(data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB] &
    361          			BMA2x2_RESOLUTION_10_MASK));
    362          			*accel_x_s16 = *accel_x_s16 >>
    363          			BMA2x2_SHIFT_SIX_BITS;
    364          		break;
    365          		/* This case used for the resolution bit 14*/
    366          		case BMA2x2_14_RESOLUTION:
    367          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    368          			(p_bma2x2->dev_addr,
    369          			BMA2x2_ACCEL_X14_LSB_REG, data_u8,
    370          			BMA2x2_LSB_MSB_READ_LENGTH);
    371          			*accel_x_s16 = (s16)((((s32)((s8)
    372          			data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    373          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    374          			(data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB] &
    375          			BMA2x2_RESOLUTION_14_MASK));
    376          			*accel_x_s16 = *accel_x_s16 >>
    377          			BMA2x2_SHIFT_TWO_BITS;
    378          		break;
    379          		default:
    380          		break;
    381          		}
    382          	}
    383          	return com_rslt;
    384          }
    385          /*!
    386           * @brief
    387           *	This API reads acceleration data X values
    388           *	from location 02h and 03h bit resolution support 8bit
    389           *
    390           *
    391           *  @param   accel_x_s8 : pointer holding the data of accel X
    392           *
    393           *
    394           *
    395           *	@return results of bus communication function
    396           *	@retval 0 -> Success
    397           *	@retval -1 -> Error
    398           *
    399           *
    400           */
    401          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_eight_resolution_x(
    402          s8 *accel_x_s8)
    403          {
    404          	/*  Variable used to return value of
    405          	communication routine*/
    406          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    407          	u8	data = BMA2x2_INIT_VALUE;
    408          
    409          	if (p_bma2x2 == BMA2x2_NULL) {
    410          		/* Check the struct p_bma2x2 is empty */
    411          		return E_BMA2x2_NULL_PTR;
    412          		} else {
    413          			/* Read the sensor X data*/
    414          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    415          			(p_bma2x2->dev_addr,
    416          			BMA2x2_X_AXIS_MSB_ADDR, &data,
    417          			BMA2x2_GEN_READ_WRITE_LENGTH);
    418          			*accel_x_s8 = BMA2x2_GET_BITSLICE(data,
    419          			BMA2x2_ACCEL_X_MSB);
    420          		}
    421          	return com_rslt;
    422          }
    423          /*!
    424           * @brief
    425           *	This API reads acceleration data Y values
    426           *	from location 04h and 05h
    427           *
    428           *  @param   accel_y_s16 : pointer holding the data of accel Y
    429           *		       value       |   resolution
    430           *       ----------------- | --------------
    431           *              0          | BMA2x2_12_RESOLUTION
    432           *              1          | BMA2x2_10_RESOLUTION
    433           *              2          | BMA2x2_14_RESOLUTION
    434           *
    435           *
    436           *	@return results of bus communication function
    437           *	@retval 0 -> Success
    438           *	@retval -1 -> Error
    439           *
    440           *
    441          */
    442          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_y(s16 *accel_y_s16)
    443          {
    444          	/*  Variable used to return value of
    445          	communication routine*/
    446          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    447          	/* Array holding the accel y value
    448          	data_u8[0] - y->LSB
    449          	data_u8[1] - y->MSB
    450          	*/
    451          	u8 data_u8[BMA2x2_ACCEL_DATA_SIZE] = {BMA2x2_INIT_VALUE,
    452          	BMA2x2_INIT_VALUE};
    453          
    454          	if (p_bma2x2 == BMA2x2_NULL) {
    455          		/* Check the struct p_bma2x2 is empty */
    456          		return E_BMA2x2_NULL_PTR;
    457          		} else {
    458          		switch (V_BMA2x2RESOLUTION_U8) {
    459          		/* This case used for the resolution bit 12*/
    460          		case BMA2x2_12_RESOLUTION:
    461          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    462          			(p_bma2x2->dev_addr,
    463          			BMA2x2_ACCEL_Y12_LSB_REG, data_u8,
    464          			BMA2x2_LSB_MSB_READ_LENGTH);
    465          			*accel_y_s16 = (s16)((((s32)((s8)
    466          			data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    467          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    468          			(data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB] &
    469          			BMA2x2_12_BIT_SHIFT));
    470          			*accel_y_s16 = *accel_y_s16 >>
    471          			BMA2x2_SHIFT_FOUR_BITS;
    472          		break;
    473          		/* This case used for the resolution bit 10*/
    474          		case BMA2x2_10_RESOLUTION:
    475          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    476          			(p_bma2x2->dev_addr,
    477          			BMA2x2_ACCEL_Y10_LSB_REG, data_u8,
    478          			BMA2x2_LSB_MSB_READ_LENGTH);
    479          			*accel_y_s16 = (s16)((((s32)((s8)
    480          			data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    481          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    482          			(data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB] &
    483          			BMA2x2_10_BIT_SHIFT));
    484          			*accel_y_s16 = *accel_y_s16 >>
    485          			BMA2x2_SHIFT_SIX_BITS;
    486          		break;
    487          		/* This case used for the resolution bit 14*/
    488          		case BMA2x2_14_RESOLUTION:
    489          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    490          			(p_bma2x2->dev_addr,
    491          			BMA2x2_ACCEL_Y14_LSB_REG, data_u8,
    492          			BMA2x2_LSB_MSB_READ_LENGTH);
    493          			*accel_y_s16 = (s16)((((s32)((s8)
    494          			data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    495          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    496          			(data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB] &
    497          			BMA2x2_14_BIT_SHIFT));
    498          			*accel_y_s16 = *accel_y_s16 >>
    499          			BMA2x2_SHIFT_TWO_BITS;
    500          		break;
    501          		default:
    502          		break;
    503          		}
    504          	}
    505          	return com_rslt;
    506          }
    507          /*!
    508           * @brief This API reads acceleration data Y values of
    509           * 8bit  resolution  from location 05h
    510           *
    511           *
    512           *
    513           *
    514           *  @param accel_y_s8   The data of y
    515           *
    516           *
    517           *
    518           *	@return results of bus communication function
    519           *	@retval 0 -> Success
    520           *	@retval -1 -> Error
    521           *
    522           *
    523          */
    524          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_eight_resolution_y(
    525          s8 *accel_y_s8)
    526          {
    527          		/*  Variable used to return value of
    528          	communication routine*/
    529          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    530          	u8	data = BMA2x2_INIT_VALUE;
    531          
    532          	if (p_bma2x2 == BMA2x2_NULL) {
    533          		/* Check the struct p_bma2x2 is empty */
    534          		return E_BMA2x2_NULL_PTR;
    535          		} else {
    536          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    537          			(p_bma2x2->dev_addr,
    538          			BMA2x2_Y_AXIS_MSB_ADDR, &data,
    539          			BMA2x2_GEN_READ_WRITE_LENGTH);
    540          			*accel_y_s8 = BMA2x2_GET_BITSLICE(data,
    541          			BMA2x2_ACCEL_Y_MSB);
    542          		}
    543          	return com_rslt;
    544          }
    545          /*!
    546           * @brief This API reads acceleration data Z values
    547           *                          from location 06h and 07h
    548           *
    549           *
    550           *  @param   accel_z_s16 : pointer holding the data of accel Z
    551           *		       value       |   resolution
    552           *       ----------------- | --------------
    553           *              0          | BMA2x2_12_RESOLUTION
    554           *              1          | BMA2x2_10_RESOLUTION
    555           *              2          | BMA2x2_14_RESOLUTION
    556           *
    557           *
    558           *	@return results of bus communication function
    559           *	@retval 0 -> Success
    560           *	@retval -1 -> Error
    561           *
    562           *
    563          */
    564          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_z(s16 *accel_z_s16)
    565          {
    566          	/*  Variable used to return value of
    567          	communication routine*/
    568          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    569          	/* Array holding the accel z value
    570          	data_u8[0] - z->LSB
    571          	data_u8[1] - z->MSB
    572          	*/
    573          	u8 data_u8[BMA2x2_ACCEL_DATA_SIZE] = {BMA2x2_INIT_VALUE,
    574          	BMA2x2_INIT_VALUE};
    575          
    576          	if (p_bma2x2 == BMA2x2_NULL) {
    577          		/* Check the struct p_bma2x2 is empty */
    578          		return E_BMA2x2_NULL_PTR;
    579          		} else {
    580          		switch (V_BMA2x2RESOLUTION_U8) {
    581          		case BMA2x2_12_RESOLUTION:
    582          			/* This case used for the resolution bit 12*/
    583          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    584          			(p_bma2x2->dev_addr,
    585          			BMA2x2_ACCEL_Z12_LSB_REG, data_u8,
    586          			BMA2x2_LSB_MSB_READ_LENGTH);
    587          			*accel_z_s16 = (s16)((((s32)((s8)
    588          			data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    589          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    590          			(data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB]
    591          			& BMA2x2_12_BIT_SHIFT));
    592          			*accel_z_s16 = *accel_z_s16 >>
    593          			BMA2x2_SHIFT_FOUR_BITS;
    594          		break;
    595          		/* This case used for the resolution bit 10*/
    596          		case BMA2x2_10_RESOLUTION:
    597          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    598          			(p_bma2x2->dev_addr,
    599          			BMA2x2_ACCEL_Z10_LSB_REG, data_u8,
    600          			BMA2x2_LSB_MSB_READ_LENGTH);
    601          			*accel_z_s16 = (s16)((((s32)((s8)
    602          			data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    603          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    604          			(data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB]
    605          			& BMA2x2_10_BIT_SHIFT));
    606          			*accel_z_s16 = *accel_z_s16 >>
    607          			BMA2x2_SHIFT_SIX_BITS;
    608          		break;
    609          		/* This case used for the resolution bit 14*/
    610          		case BMA2x2_14_RESOLUTION:
    611          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    612          			(p_bma2x2->dev_addr,
    613          			BMA2x2_ACCEL_Z14_LSB_REG, data_u8,
    614          			BMA2x2_LSB_MSB_READ_LENGTH);
    615          			*accel_z_s16 = (s16)((((s32)((s8)
    616          			data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    617          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    618          			(data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB]
    619          			& BMA2x2_14_BIT_SHIFT));
    620          			*accel_z_s16 = *accel_z_s16 >>
    621          			BMA2x2_SHIFT_TWO_BITS;
    622          		break;
    623          		default:
    624          		break;
    625          		}
    626          	}
    627          	return com_rslt;
    628          }
    629          /*!
    630           * @brief
    631           *	This API reads acceleration data Z values of
    632           *	8bit  resolution  from location 07h
    633           *
    634           *
    635           *
    636           *
    637           *  \@aram  accel_z_s8 : the data of z
    638           *
    639           *
    640           *	@return results of bus communication function
    641           *	@retval 0 -> Success
    642           *	@retval -1 -> Error
    643           *
    644           *
    645          */
    646          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_eight_resolution_z(
    647          s8 *accel_z_s8)
    648          {
    649          		/*  Variable used to return value of
    650          	communication routine*/
    651          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    652          	u8	data = BMA2x2_INIT_VALUE;
    653          
    654          	if (p_bma2x2 == BMA2x2_NULL) {
    655          		/* Check the struct p_bma2x2 is empty */
    656          		return E_BMA2x2_NULL_PTR;
    657          		} else {
    658          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    659          			(p_bma2x2->dev_addr,
    660          			BMA2x2_Z_AXIS_MSB_ADDR, &data,
    661          			BMA2x2_GEN_READ_WRITE_LENGTH);
    662          			*accel_z_s8 = BMA2x2_GET_BITSLICE(data,
    663          			BMA2x2_ACCEL_Z_MSB);
    664          		}
    665          	return com_rslt;
    666          }
    667          /*!
    668           *	@brief This API reads acceleration data X,Y,Z values
    669           *	from location 02h to 07h
    670           *
    671           *  @param accel : pointer holding the data of accel
    672           *		       value       |   resolution
    673           *       ----------------- | --------------
    674           *              0          | BMA2x2_12_RESOLUTION
    675           *              1          | BMA2x2_10_RESOLUTION
    676           *              2          | BMA2x2_14_RESOLUTION
    677           *
    678           *	@return results of bus communication function
    679           *	@retval 0 -> Success
    680           *	@retval -1 -> Error
    681           *
    682           *
    683          */
    684          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_xyz(
    685          struct bma2x2_accel_data *accel)
    686          {
    687          	/*  Variable used to return value of
    688          	communication routine*/
    689          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    690          	/* Array holding the accel xyz value
    691          	data_u8[0] - x->LSB
    692          	data_u8[1] - x->MSB
    693          	data_u8[2] - y->MSB
    694          	data_u8[3] - y->MSB
    695          	data_u8[4] - z->MSB
    696          	data_u8[5] - z->MSB
    697          	*/
    698          	u8 data_u8[BMA2x2_ACCEL_XYZ_DATA_SIZE] = {
    699          	BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE,
    700          	BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE,
    701          	BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE};
    702          
    703          	if (p_bma2x2 == BMA2x2_NULL) {
    704          		/* Check the struct p_bma2x2 is empty */
    705          		return E_BMA2x2_NULL_PTR;
    706          		} else {
    707          		switch (V_BMA2x2RESOLUTION_U8) {
    708          		/* This case used for the resolution bit 12*/
    709          		case BMA2x2_12_RESOLUTION:
    710          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    711          			(p_bma2x2->dev_addr, BMA2x2_ACCEL_X12_LSB_REG,
    712          			data_u8, BMA2x2_SHIFT_SIX_BITS);
    713          			/* read the x data_u8*/
    714          			accel->x = (s16)((((s32)((s8)
    715          			data_u8[BMA2x2_SENSOR_DATA_XYZ_X_MSB]))
    716          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    717          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_X_LSB] &
    718          			BMA2x2_12_BIT_SHIFT));
    719          			accel->x = accel->x >> BMA2x2_SHIFT_FOUR_BITS;
    720          
    721          			/* read the y data_u8*/
    722          			accel->y = (s16)((((s32)((s8)
    723          			data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_MSB]))
    724          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    725          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_LSB] &
    726          			BMA2x2_12_BIT_SHIFT));
    727          			accel->y = accel->y >> BMA2x2_SHIFT_FOUR_BITS;
    728          
    729          			/* read the z data_u8*/
    730          			accel->z = (s16)((((s32)((s8)
    731          			data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_MSB]))
    732          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    733          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_LSB] &
    734          			BMA2x2_12_BIT_SHIFT));
    735          			accel->z = accel->z >> BMA2x2_SHIFT_FOUR_BITS;
    736          
    737          		break;
    738          		case BMA2x2_10_RESOLUTION:
    739          		/* This case used for the resolution bit 10*/
    740          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    741          			(p_bma2x2->dev_addr, BMA2x2_ACCEL_X10_LSB_REG,
    742          			data_u8, BMA2x2_SHIFT_SIX_BITS);
    743          			/* read the x data_u8*/
    744          			accel->x = (s16)((((s32)((s8)
    745          			data_u8[BMA2x2_SENSOR_DATA_XYZ_X_MSB]))
    746          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    747          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_X_LSB] &
    748          			BMA2x2_10_BIT_SHIFT));
    749          			accel->x = accel->x >> BMA2x2_SHIFT_SIX_BITS;
    750          
    751          			/* read the y data_u8*/
    752          			accel->y = (s16)((((s32)((s8)
    753          			data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_MSB]))
    754          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    755          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_LSB] &
    756          			BMA2x2_10_BIT_SHIFT));
    757          			accel->y = accel->y >> BMA2x2_SHIFT_SIX_BITS;
    758          
    759          			/* read the z data_u8*/
    760          			accel->z = (s16)((((s32)((s8)
    761          			data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_MSB]))
    762          			<< BMA2x2_SHIFT_EIGHT_BITS) |
    763          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_LSB]
    764          			& BMA2x2_10_BIT_SHIFT));
    765          			accel->z = accel->z >> BMA2x2_SHIFT_SIX_BITS;
    766          		break;
    767          		/* This case used for the resolution bit 14*/
    768          		case BMA2x2_14_RESOLUTION:
    769          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    770          			(p_bma2x2->dev_addr, BMA2x2_ACCEL_X14_LSB_REG,
    771          			data_u8, BMA2x2_SHIFT_SIX_BITS);
    772          
    773          			/* read the x data_u8*/
    774          			accel->x = (s16)((((s32)((s8)
    775          			data_u8[BMA2x2_SENSOR_DATA_XYZ_X_MSB]))<<
    776          			BMA2x2_SHIFT_EIGHT_BITS) |
    777          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_X_LSB]
    778          			& BMA2x2_14_BIT_SHIFT));
    779          			accel->x = accel->x >> BMA2x2_SHIFT_TWO_BITS;
    780          
    781          			/* read the y data_u8*/
    782          			accel->y = (s16)((((s32)((s8)
    783          			data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_MSB]))<<
    784          			BMA2x2_SHIFT_EIGHT_BITS) |
    785          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_LSB]
    786          			& BMA2x2_14_BIT_SHIFT));
    787          			accel->y = accel->y >> BMA2x2_SHIFT_TWO_BITS;
    788          
    789          			/* read the z data_u8*/
    790          			accel->z = (s16)((((s32)((s8)
    791          			data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_MSB]))<<
    792          			BMA2x2_SHIFT_EIGHT_BITS) |
    793          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_LSB]
    794          			& BMA2x2_14_BIT_SHIFT));
    795          			accel->z = accel->z >> BMA2x2_SHIFT_TWO_BITS;
    796          		break;
    797          		default:
    798          		break;
    799          		}
    800          	}
    801          	return com_rslt;
    802          }
    803          /*!
    804           * @brief This API reads acceleration of 8 bit resolution
    805           * data of X,Y,Z values
    806           * from location 03h , 05h and 07h
    807           *
    808           *
    809           *
    810           *
    811           *  @param accel : pointer holding the data of accel
    812           *
    813           *
    814           *
    815           *	@return results of bus communication function
    816           *	@retval 0 -> Success
    817           *	@retval -1 -> Error
    818           *
    819           *
    820          */
    821          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_eight_resolution_xyz(
    822          struct bma2x2_accel_eight_resolution *accel)
    823          {
    824          	/*  Variable used to return value of
    825          	communication routine*/
    826          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    827          	u8	data_u8 = BMA2x2_INIT_VALUE;
    828          
    829          	if (p_bma2x2 == BMA2x2_NULL) {
    830          		/* Check the struct p_bma2x2 is empty */
    831          		return E_BMA2x2_NULL_PTR;
    832          		} else {
    833          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    834          		(p_bma2x2->dev_addr,
    835          		BMA2x2_X_AXIS_MSB_ADDR, &data_u8,
    836          		BMA2x2_GEN_READ_WRITE_LENGTH);
    837          		accel->x = BMA2x2_GET_BITSLICE(data_u8,
    838          		BMA2x2_ACCEL_X_MSB);
    839          
    840          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    841          		(p_bma2x2->dev_addr,
    842          		BMA2x2_Y_AXIS_MSB_ADDR, &data_u8,
    843          		BMA2x2_GEN_READ_WRITE_LENGTH);
    844          		accel->y = BMA2x2_GET_BITSLICE(data_u8,
    845          		BMA2x2_ACCEL_Y_MSB);
    846          
    847          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    848          		(p_bma2x2->dev_addr,
    849          		BMA2x2_Z_AXIS_MSB_ADDR, &data_u8,
    850          		BMA2x2_GEN_READ_WRITE_LENGTH);
    851          		accel->z = BMA2x2_GET_BITSLICE(data_u8,
    852          		BMA2x2_ACCEL_Z_MSB);
    853          		}
    854          	return com_rslt;
    855          }
    856          /*!
    857           *	@brief This API read tap-sign, tap-first-xyz
    858           *	slope-sign, slope-first-xyz status register byte
    859           *	from location 0Bh
    860           *
    861           *   @param stat_tap_u8 : The status of tap and slope
    862           *
    863           *
    864           *
    865           *	@return results of bus communication function
    866           *	@retval 0 -> Success
    867           *	@retval -1 -> Error
    868           *
    869           *
    870          */
    871          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_tap_stat(
    872          u8 *stat_tap_u8)
    873          {
    874          	/*  Variable used to return value of
    875          	communication routine*/
    876          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    877          
    878          	if (p_bma2x2 == BMA2x2_NULL) {
    879          		/* Check the struct p_bma2x2 is empty */
    880          		return E_BMA2x2_NULL_PTR;
    881          		} else {
    882          			/* Read the interrupt status register 0x0B*/
    883          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    884          			(p_bma2x2->dev_addr, BMA2x2_STAT_TAP_SLOPE_ADDR,
    885          			stat_tap_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
    886          		}
    887          	return com_rslt;
    888          }
    889          /*!
    890           *	@brief This API read orient, high-sign and high-first-xyz
    891           *	status register byte from location 0Ch
    892           *
    893           *
    894           *  @param stat_orient_u8 : The status of orient and high
    895           *
    896           *
    897           *
    898           *	@return results of bus communication function
    899           *	@retval 0 -> Success
    900           *	@retval -1 -> Error
    901           *
    902           *
    903           */
    904          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_orient_stat(
    905          u8 *stat_orient_u8)
    906          {
    907          	/*  Variable used to return value of
    908          	communication routine*/
    909          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    910          
    911          	if (p_bma2x2 == BMA2x2_NULL) {
    912          		/* Check the struct p_bma2x2 is empty */
    913          		return E_BMA2x2_NULL_PTR;
    914          		} else {
    915          			/* Read the interrupt status register 0x0C*/
    916          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    917          			(p_bma2x2->dev_addr, BMA2x2_STAT_ORIENT_HIGH_ADDR,
    918          			stat_orient_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
    919          		}
    920          	return com_rslt;
    921          }
    922          /*!
    923           *	@brief This API reads fifo overrun and fifo frame counter
    924           *	status register byte  from location 0Eh
    925           *
    926           *  @param stat_fifo_u8 : The status of fifo overrun and frame counter
    927           *
    928           *
    929           *
    930           *	@return results of bus communication function
    931           *	@retval 0 -> Success
    932           *	@retval -1 -> Error
    933           *
    934           *
    935           */
    936          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_stat(
    937          u8 *stat_fifo_u8)
    938          {
    939          	/*  Variable used to return value of
    940          	communication routine*/
    941          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    942          
    943          	if (p_bma2x2 == BMA2x2_NULL) {
    944          		/* Check the struct p_bma2x2 is empty */
    945          		return E_BMA2x2_NULL_PTR;
    946          		} else {
    947          			/* Read the interrupt status register 0x0E*/
    948          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
    949          			p_bma2x2->dev_addr,
    950          			BMA2x2_STAT_FIFO_ADDR,
    951          			stat_fifo_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
    952          		}
    953          	return com_rslt;
    954          }
    955          /*!
    956           *	@brief This API read fifo frame count
    957           *	from location 0Eh bit position 0 to 6
    958           *
    959           *
    960           * @param frame_count_u8 : The status of fifo frame count
    961           *
    962           *
    963           *
    964           *	@return results of bus communication function
    965           *	@retval 0 -> Success
    966           *	@retval -1 -> Error
    967           *
    968           *
    969           */
    970          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_frame_count(
    971          u8 *frame_count_u8)
    972          {
    973          	/*  Variable used to return value of
    974          	communication routine*/
    975          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    976          	u8 data_u8 = BMA2x2_INIT_VALUE;
    977          
    978          	if (p_bma2x2 == BMA2x2_NULL) {
    979          		/* Check the struct p_bma2x2 is empty */
    980          		return E_BMA2x2_NULL_PTR;
    981          		} else {
    982          			/* Read the FIFO frame count*/
    983          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
    984          			p_bma2x2->dev_addr,
    985          			BMA2x2_FIFO_FRAME_COUNT_STAT_REG,
    986          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
    987          			*frame_count_u8 = BMA2x2_GET_BITSLICE(data_u8,
    988          			BMA2x2_FIFO_FRAME_COUNT_STAT);
    989          		}
    990          	return com_rslt;
    991          }
    992          /*!
    993           *	@brief This API read fifo overrun
    994           *	from location 0Eh bit position 7
    995           *
    996           *
    997           * @param fifo_overrun_u8 : The status of fifo overrun
    998           *
    999           *
   1000           *
   1001           *	@return results of bus communication function
   1002           *	@retval 0 -> Success
   1003           *	@retval -1 -> Error
   1004           *
   1005           *
   1006           */
   1007          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_overrun(
   1008          u8 *fifo_overrun_u8)
   1009          {
   1010          		/*  Variable used to return value of
   1011          	communication routine*/
   1012          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1013          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1014          
   1015          	if (p_bma2x2 == BMA2x2_NULL) {
   1016          		/* Check the struct p_bma2x2 is empty */
   1017          		return E_BMA2x2_NULL_PTR;
   1018          		} else {
   1019          			/* Read the status of fifo over run*/
   1020          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   1021          			p_bma2x2->dev_addr,
   1022          			BMA2x2_FIFO_OVERRUN_STAT_REG,
   1023          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1024          			*fifo_overrun_u8 = BMA2x2_GET_BITSLICE(data_u8,
   1025          			BMA2x2_FIFO_OVERRUN_STAT);
   1026          		}
   1027          	return com_rslt;
   1028          }
   1029          /*!
   1030           *	@brief This API read interrupt status of flat, orient, single tap,
   1031           *	double tap, slow no motion, slope, highg and lowg from location 09h
   1032           *
   1033           *
   1034           *
   1035           *	@param  intr_stat_u8 : The value of interrupt status
   1036           *
   1037           *
   1038           *
   1039           *	@return results of bus communication function
   1040           *	@retval 0 -> Success
   1041           *	@retval -1 -> Error
   1042           *
   1043           *
   1044          */
   1045          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_stat(
   1046          u8 *intr_stat_u8)
   1047          {
   1048          	/*  Variable used to return value of
   1049          	communication routine*/
   1050          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1051          
   1052          	if (p_bma2x2 == BMA2x2_NULL) {
   1053          		/* Check the struct p_bma2x2 is empty */
   1054          		return E_BMA2x2_NULL_PTR;
   1055          		} else {
   1056          			/* Read the interrupt status register 0x09*/
   1057          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   1058          			p_bma2x2->dev_addr,
   1059          			BMA2x2_STAT1_ADDR, intr_stat_u8,
   1060          			BMA2x2_SHIFT_FOUR_BITS);
   1061          		}
   1062          	return com_rslt;
   1063          }
   1064          /*!
   1065           * @brief This API is used to get the ranges(g values) of the sensor
   1066           *	in the register 0x0F bit from 0 to 3
   1067           *
   1068           *
   1069           *	@param range_u8 : The value of range
   1070           *		  range_u8       |   result
   1071           *       ----------------- | --------------
   1072           *              0x03       | BMA2x2_RANGE_2G
   1073           *              0x05       | BMA2x2_RANGE_4G
   1074           *              0x08       | BMA2x2_RANGE_8G
   1075           *              0x0C       | BMA2x2_RANGE_16G
   1076           *
   1077           *
   1078           *
   1079           *	@return results of bus communication function
   1080           *	@retval 0 -> Success
   1081           *	@retval -1 -> Error
   1082           *
   1083           *
   1084           */
   1085          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_range(u8 *range_u8)
   1086          {
   1087          	/*  Variable used to return value of
   1088          	communication routine*/
   1089          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1090          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1091          
   1092          	if (p_bma2x2 == BMA2x2_NULL) {
   1093          		/* Check the struct p_bma2x2 is empty */
   1094          		return E_BMA2x2_NULL_PTR;
   1095          		} else {
   1096          		/* Read the range register 0x0F*/
   1097          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
   1098          		BMA2x2_RANGE_SELECT_REG, &data_u8,
   1099          		BMA2x2_GEN_READ_WRITE_LENGTH);
   1100          		data_u8 = BMA2x2_GET_BITSLICE(data_u8, BMA2x2_RANGE_SELECT);
   1101          		*range_u8 = data_u8;
   1102          	}
   1103          	return com_rslt;
   1104          }
   1105          /*!
   1106           * @brief This API is used to set the ranges(g values) of the sensor
   1107           *	in the register 0x0F bit from 0 to 3
   1108           *
   1109           *
   1110           *	@param range_u8 : The value of range
   1111           *		  range_u8 |   result
   1112           *       ----------------- | --------------
   1113           *              0x03       | BMA2x2_RANGE_2G
   1114           *              0x05       | BMA2x2_RANGE_4G
   1115           *              0x08       | BMA2x2_RANGE_8G
   1116           *              0x0C       | BMA2x2_RANGE_16G
   1117           *
   1118           *
   1119           *
   1120           *	@return results of bus communication function
   1121           *	@retval 0 -> Success
   1122           *	@retval -1 -> Error
   1123           *
   1124           *
   1125           */
   1126          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_range(u8 range_u8)
   1127          {
   1128          	/*  Variable used to return value of
   1129          	communication routine*/
   1130          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1131          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1132          
   1133          	if (p_bma2x2 == BMA2x2_NULL) {
   1134          		/* Check the struct p_bma2x2 is empty */
   1135          		return E_BMA2x2_NULL_PTR;
   1136          		} else {
   1137          		if ((range_u8 == BMA2x2_RANGE_2G) ||
   1138          		(range_u8 == BMA2x2_RANGE_4G) ||
   1139          		(range_u8 == BMA2x2_RANGE_8G) ||
   1140          		(range_u8 == BMA2x2_RANGE_16G)) {
   1141          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1142          			(p_bma2x2->dev_addr,
   1143          			BMA2x2_RANGE_SELECT_REG, &data_u8,
   1144          			BMA2x2_GEN_READ_WRITE_LENGTH);
   1145          			switch (range_u8) {
   1146          			case BMA2x2_RANGE_2G:
   1147          				data_u8  = BMA2x2_SET_BITSLICE(data_u8,
   1148          				BMA2x2_RANGE_SELECT,
   1149          				BMA2x2_RANGE_2G);
   1150          			break;
   1151          			case BMA2x2_RANGE_4G:
   1152          				data_u8  = BMA2x2_SET_BITSLICE(data_u8,
   1153          				BMA2x2_RANGE_SELECT,
   1154          				BMA2x2_RANGE_4G);
   1155          			break;
   1156          			case BMA2x2_RANGE_8G:
   1157          				data_u8  = BMA2x2_SET_BITSLICE(data_u8,
   1158          				BMA2x2_RANGE_SELECT,
   1159          				BMA2x2_RANGE_8G);
   1160          			break;
   1161          			case BMA2x2_RANGE_16G:
   1162          				data_u8  = BMA2x2_SET_BITSLICE(data_u8,
   1163          				BMA2x2_RANGE_SELECT,
   1164          				BMA2x2_RANGE_16G);
   1165          			break;
   1166          			default:
   1167          			break;
   1168          			}
   1169          			/* Write the range register 0x0F*/
   1170          			com_rslt += bma2x2_write_reg(BMA2x2_RANGE_SELECT_REG,
   1171          				&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1172          		} else {
   1173          		com_rslt = E_OUT_OF_RANGE;
   1174          		}
   1175          	}
   1176          	return com_rslt;
   1177          }
   1178          /*!
   1179           *  @brief This API is used to get the bandwidth of the sensor in the register
   1180           *  0x10 bit from 0 to 4
   1181           *
   1182           *
   1183           *  @param bw_u8 : The value of bandwidth
   1184           *          bw_u8          |   result
   1185           *       ----------------- | --------------
   1186           *              0x08       | BMA2x2_BW_7_81HZ
   1187           *              0x09       | BMA2x2_BW_15_63HZ
   1188           *              0x0A       | BMA2x2_BW_31_25HZ
   1189           *              0x0B       | BMA2x2_BW_62_50HZ
   1190           *              0x0C       | BMA2x2_BW_125HZ
   1191           *              0x0D       | BMA2x2_BW_250HZ
   1192           *              0x0E       | BMA2x2_BW_500HZ
   1193           *              0x0F       | BMA2x2_BW_1000HZ
   1194           *
   1195           *
   1196           *
   1197           *  @return results of bus communication function
   1198           *  @retval 0 -> Success
   1199           *  @retval -1 -> Error
   1200           *
   1201           *
   1202          */
   1203          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_bw(u8 *bw_u8)
   1204          {
   1205          	/*  Variable used to return value of
   1206          	communication routine*/
   1207          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1208          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1209          
   1210          	if (p_bma2x2 == BMA2x2_NULL) {
   1211          		/* Check the struct p_bma2x2 is empty */
   1212          		return E_BMA2x2_NULL_PTR;
   1213          		} else {
   1214          			/* Read the bandwidth register 0x10*/
   1215          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1216          			(p_bma2x2->dev_addr,
   1217          			BMA2x2_BW_REG, &data_u8,
   1218          			BMA2x2_GEN_READ_WRITE_LENGTH);
   1219          			data_u8 = BMA2x2_GET_BITSLICE(data_u8, BMA2x2_BW);
   1220          			*bw_u8 = data_u8;
   1221          		}
   1222          	return com_rslt;
   1223          }
   1224          /*!
   1225           *	@brief This API is used to set the bandwidth of the sensor
   1226           *      in the register
   1227           *	0x10 bit from 0 to 4
   1228           *
   1229           *
   1230           *  @param bw_u8 : The value of bandwidth
   1231           *		  bw_u8          |   result
   1232           *       ----------------- | --------------
   1233           *              0x08       | BMA2x2_BW_7_81HZ
   1234           *              0x09       | BMA2x2_BW_15_63HZ
   1235           *              0x0A       | BMA2x2_BW_31_25HZ
   1236           *              0x0B       | BMA2x2_BW_62_50HZ
   1237           *              0x0C       | BMA2x2_BW_125HZ
   1238           *              0x0D       | BMA2x2_BW_250HZ
   1239           *              0x0E       | BMA2x2_BW_500HZ
   1240           *              0x0F       | BMA2x2_BW_1000HZ
   1241           *
   1242           *
   1243           *
   1244           *	@return results of bus communication function
   1245           *	@retval 0 -> Success
   1246           *	@retval -1 -> Error
   1247           *
   1248           *
   1249          */
   1250          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_bw(u8 bw_u8)
   1251          {
   1252          /*  Variable used to return value of
   1253          communication routine*/
   1254          BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1255          u8 data_u8 = BMA2x2_INIT_VALUE;
   1256          u8 data_bw_u8 = BMA2x2_INIT_VALUE;
   1257          if (p_bma2x2 == BMA2x2_NULL) {
   1258          		/* Check the struct p_bma2x2 is empty */
   1259          		com_rslt = E_BMA2x2_NULL_PTR;
   1260          	} else {
   1261          	/* Check the chip id 0xFB, it support upto 500Hz*/
   1262          	if (p_bma2x2->chip_id == BANDWIDTH_DEFINE) {
   1263          		if (bw_u8 > BMA2x2_ACCEL_BW_MIN_RANGE &&
   1264          		bw_u8 < BMA2x2_ACCEL_BW_1000HZ_RANGE) {
   1265          			switch (bw_u8) {
   1266          			case BMA2x2_BW_7_81HZ:
   1267          				data_bw_u8 = BMA2x2_BW_7_81HZ;
   1268          
   1269          				/*  7.81 Hz      64000 uS   */
   1270          			break;
   1271          			case BMA2x2_BW_15_63HZ:
   1272          				data_bw_u8 = BMA2x2_BW_15_63HZ;
   1273          
   1274          			/*  15.63 Hz     32000 uS   */
   1275          			break;
   1276          			case BMA2x2_BW_31_25HZ:
   1277          				data_bw_u8 = BMA2x2_BW_31_25HZ;
   1278          
   1279          			/*  31.25 Hz     16000 uS   */
   1280          			break;
   1281          			case BMA2x2_BW_62_50HZ:
   1282          				data_bw_u8 = BMA2x2_BW_62_50HZ;
   1283          
   1284          			/*  62.50 Hz     8000 uS   */
   1285          			break;
   1286          			case BMA2x2_BW_125HZ:
   1287          				data_bw_u8 = BMA2x2_BW_125HZ;
   1288          
   1289          			/*  125 Hz       4000 uS   */
   1290          			break;
   1291          			case BMA2x2_BW_250HZ:
   1292          				data_bw_u8 = BMA2x2_BW_250HZ;
   1293          
   1294          			/*  250 Hz       2000 uS   */
   1295          			break;
   1296          			case BMA2x2_BW_500HZ:
   1297          				data_bw_u8 = BMA2x2_BW_500HZ;
   1298          
   1299          			/*  500 Hz       1000 uS   */
   1300          			break;
   1301          			default:
   1302          			break;
   1303          			}
   1304          			/* Write the bandwidth register */
   1305          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1306          			(p_bma2x2->dev_addr,
   1307          			BMA2x2_BW_REG, &data_u8,
   1308          			BMA2x2_GEN_READ_WRITE_LENGTH);
   1309          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   1310          			BMA2x2_BW, data_bw_u8);
   1311          			com_rslt += bma2x2_write_reg
   1312          			(BMA2x2_BW_REG, &data_u8,
   1313          			BMA2x2_GEN_READ_WRITE_LENGTH);
   1314          			} else {
   1315          			com_rslt = E_OUT_OF_RANGE;
   1316          			}
   1317          		} else {
   1318          		if (bw_u8 > BMA2x2_ACCEL_BW_MIN_RANGE &&
   1319          		bw_u8 < BMA2x2_ACCEL_BW_MAX_RANGE) {
   1320          			switch (bw_u8) {
   1321          			case BMA2x2_BW_7_81HZ:
   1322          				data_bw_u8 = BMA2x2_BW_7_81HZ;
   1323          
   1324          			/*  7.81 Hz      64000 uS   */
   1325          			break;
   1326          			case BMA2x2_BW_15_63HZ:
   1327          				data_bw_u8 = BMA2x2_BW_15_63HZ;
   1328          
   1329          			/*  15.63 Hz     32000 uS   */
   1330          			break;
   1331          			case BMA2x2_BW_31_25HZ:
   1332          				data_bw_u8 = BMA2x2_BW_31_25HZ;
   1333          
   1334          			/*  31.25 Hz     16000 uS   */
   1335          			break;
   1336          			case BMA2x2_BW_62_50HZ:
   1337          				data_bw_u8 = BMA2x2_BW_62_50HZ;
   1338          
   1339          			/*  62.50 Hz     8000 uS   */
   1340          			break;
   1341          			case BMA2x2_BW_125HZ:
   1342          				data_bw_u8 = BMA2x2_BW_125HZ;
   1343          
   1344          			/*  125 Hz       4000 uS   */
   1345          			break;
   1346          			case BMA2x2_BW_250HZ:
   1347          				data_bw_u8 = BMA2x2_BW_250HZ;
   1348          
   1349          			/*  250 Hz       2000 uS   */
   1350          			break;
   1351          			case BMA2x2_BW_500HZ:
   1352          				data_bw_u8 = BMA2x2_BW_500HZ;
   1353          
   1354          			/*!  500 Hz       1000 uS   */
   1355          			break;
   1356          			case BMA2x2_BW_1000HZ:
   1357          				data_bw_u8 = BMA2x2_BW_1000HZ;
   1358          
   1359          			/*  1000 Hz      500 uS   */
   1360          			break;
   1361          			default:
   1362          			break;
   1363          			}
   1364          			/* Write the bandwidth register */
   1365          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1366          			(p_bma2x2->dev_addr,
   1367          			BMA2x2_BW_REG, &data_u8,
   1368          			BMA2x2_GEN_READ_WRITE_LENGTH);
   1369          			data_u8 = BMA2x2_SET_BITSLICE
   1370          			(data_u8, BMA2x2_BW, data_bw_u8);
   1371          			com_rslt += bma2x2_write_reg(
   1372          			BMA2x2_BW_REG, &data_u8,
   1373          			BMA2x2_GEN_READ_WRITE_LENGTH);
   1374          			} else {
   1375          			com_rslt = E_OUT_OF_RANGE;
   1376          			}
   1377          		}
   1378          	}
   1379          	return com_rslt;
   1380          }
   1381          /*!
   1382           *	@brief This API is used to get the operating
   1383           *	modes of the sensor in the register 0x11 and 0x12
   1384           *	@note Register 0x11 - bit from 5 to 7
   1385           *	@note Register 0x12 - bit from 5 and 6
   1386           *
   1387           *
   1388           *  @param power_mode_u8 : The value of power mode
   1389           *	power_mode_u8           |value  |   0x11  |   0x12
   1390           *  ------------------------- |-------| --------|--------
   1391           *  BMA2x2_MODE_NORMAL        |  0    |  0x00   |  0x00
   1392           *  BMA2x2_MODE_LOWPOWER1     |  1    |  0x02   |  0x00
   1393           *  BMA2x2_MODE_SUSPEND       |  2    |  0x06   |  0x00
   1394           *  BMA2x2_MODE_DEEP_SUSPEND  |  3    |  0x01   |  0x00
   1395           *  BMA2x2_MODE_LOWPOWER2     |  4    |  0x02   |  0x01
   1396           *  BMA2x2_MODE_STANDBY       |  5    |  0x04   |  0x00
   1397           *
   1398           *
   1399           *
   1400           *	@return results of bus communication function
   1401           *	@retval 0 -> Success
   1402           *	@retval -1 -> Error
   1403           *
   1404           *
   1405           */
   1406          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_power_mode(
   1407          u8 *power_mode_u8)
   1408          {
   1409          	/*  Variable used to return value of
   1410          	communication routine*/
   1411          BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1412          u8 data_u8 = BMA2x2_INIT_VALUE;
   1413          u8 data2_u8 = BMA2x2_INIT_VALUE;
   1414          if (p_bma2x2 == BMA2x2_NULL) {
   1415          	/* Check the struct p_bma2x2 is empty */
   1416          		com_rslt = E_BMA2x2_NULL_PTR;
   1417          	} else {
   1418          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1419          		(p_bma2x2->dev_addr, BMA2x2_MODE_CTRL_REG,
   1420          		&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1421          		com_rslt += p_bma2x2->BMA2x2_BUS_READ_FUNC
   1422          		(p_bma2x2->dev_addr, BMA2x2_LOW_NOISE_CTRL_ADDR,
   1423          		&data2_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1424          
   1425          		data_u8  = (data_u8 &
   1426          		BMA2x2_POWER_MODE_HEX_E_ZERO_MASK) >>
   1427          		BMA2x2_SHIFT_FIVE_BITS;
   1428          		data2_u8  = (data2_u8 &
   1429          		BMA2x2_POWER_MODE_HEX_4_ZERO_MASK) >>
   1430          		BMA2x2_SHIFT_SIX_BITS;
   1431          
   1432          	if ((data_u8 ==
   1433          	BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK) &&
   1434          	(data2_u8 ==
   1435          	BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK)) {
   1436          		*power_mode_u8  = BMA2x2_MODE_NORMAL;
   1437          		} else {
   1438          		if ((data_u8 ==
   1439          		BMA2x2_POWER_MODE_HEX_ZERO_TWO_MASK) &&
   1440          		(data2_u8 ==
   1441          		BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK)) {
   1442          			*power_mode_u8  =
   1443          			BMA2x2_MODE_LOWPOWER1;
   1444          			} else {
   1445          			if ((data_u8 ==
   1446          			BMA2x2_POWER_MODE_HEX_ZERO_FOUR_MASK
   1447          			|| data_u8 ==
   1448          			BMA2x2_POWER_MODE_HEX_ZERO_SIX_MASK) &&
   1449          			(data2_u8 ==
   1450          			BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK)) {
   1451          				*power_mode_u8  =
   1452          				BMA2x2_MODE_SUSPEND;
   1453          				} else {
   1454          				if (((data_u8 &
   1455          				BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK)
   1456          				== BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK)) {
   1457          					*power_mode_u8  =
   1458          					BMA2x2_MODE_DEEP_SUSPEND;
   1459          					} else {
   1460          					if ((data_u8 ==
   1461          					BMA2x2_POWER_MODE_HEX_ZERO_TWO_MASK)
   1462          					&& (data2_u8 ==
   1463          					BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK)) {
   1464          						*power_mode_u8  =
   1465          						BMA2x2_MODE_LOWPOWER2;
   1466          					} else {
   1467          					if ((data_u8 ==
   1468          					BMA2x2_POWER_MODE_HEX_ZERO_FOUR_MASK) &&
   1469          					(data2_u8 ==
   1470          					BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK))
   1471          						*power_mode_u8  =
   1472          							BMA2x2_MODE_STANDBY;
   1473          					else
   1474          						*power_mode_u8 =
   1475          						BMA2x2_MODE_DEEP_SUSPEND;
   1476          						}
   1477          					}
   1478          				}
   1479          			}
   1480          		}
   1481          	}
   1482          	p_bma2x2->power_mode_u8 = *power_mode_u8;
   1483          return com_rslt;
   1484          }
   1485          /*!
   1486           *	@brief This API is used to set the operating
   1487           *	modes of the sensor in the register 0x11 and 0x12
   1488           *	@note Register 0x11 - bit from 5 to 7
   1489           *	@note Register 0x12 - bit from 5 and 6
   1490           *
   1491           *
   1492           *  @param power_mode_u8 : The value of power mode
   1493           *	power_mode_u8         |value  |   0x11  |   0x12
   1494           *  ------------------------- |-------| --------|--------
   1495           *  BMA2x2_MODE_NORMAL        |  0    |  0x00   |  0x00
   1496           *  BMA2x2_MODE_LOWPOWER1     |  1    |  0x02   |  0x00
   1497           *  BMA2x2_MODE_SUSPEND       |  2    |  0x06   |  0x00
   1498           *  BMA2x2_MODE_DEEP_SUSPEND  |  3    |  0x01   |  0x00
   1499           *  BMA2x2_MODE_LOWPOWER2     |  4    |  0x02   |  0x01
   1500           *  BMA2x2_MODE_STANDBY       |  5    |  0x04   |  0x00
   1501           *
   1502           *
   1503           *
   1504           *	@return results of bus communication function
   1505           *	@retval 0 -> Success
   1506           *	@retval -1 -> Error
   1507           *
   1508           *
   1509           */
   1510          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_power_mode(u8 power_mode_u8)
   1511          {
   1512          		/*  Variable used to return value of
   1513          	communication routine*/
   1514          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1515          	u8 mode_ctr_eleven_reg = BMA2x2_INIT_VALUE;
   1516          	u8 mode_ctr_twel_reg = BMA2x2_INIT_VALUE;
   1517          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1518          	u8 data2_u8 = BMA2x2_INIT_VALUE;
   1519          	u8 pre_fifo_config_data = BMA2x2_INIT_VALUE;
   1520          
   1521          	if (p_bma2x2 == BMA2x2_NULL) {
   1522          		/* Check the struct p_bma2x2 is empty */
   1523          		com_rslt = E_BMA2x2_NULL_PTR;
   1524          	} else {
   1525          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
   1526          			BMA2x2_MODE_CTRL_REG, &data_u8, 1);
   1527          		com_rslt += p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
   1528          			BMA2x2_LOW_POWER_MODE_REG, &data2_u8, 1);
   1529          
   1530          		/* write the previous FIFO mode and data select*/
   1531          		pre_fifo_config_data = p_bma2x2->fifo_config;
   1532          		pre_fifo_config_data |= 0x0C;
   1533          
   1534          		com_rslt += bma2x2_set_mode_value(power_mode_u8);
   1535          		mode_ctr_eleven_reg = p_bma2x2->ctrl_mode_reg;
   1536          		mode_ctr_twel_reg =  p_bma2x2->low_mode_reg;
   1537          
   1538          		/* write the power mode to the register 0x12*/
   1539          		data2_u8  = BMA2x2_SET_BITSLICE(data2_u8, BMA2x2_LOW_POWER_MODE,
   1540          					mode_ctr_twel_reg);
   1541          		com_rslt += bma2x2_write_reg(BMA2x2_LOW_POWER_MODE_REG,
   1542          					&data2_u8, 1);
   1543          
   1544          		/*A minimum delay of atleast 450us is required for
   1545          		the low power modes, as per the data sheet.*/
   1546          		p_bma2x2->delay_msec(BMA2x2_INTERFACE_IDLE_TIME_DELAY);
   1547          
   1548          		if (((p_bma2x2->power_mode_u8 == BMA2x2_MODE_LOWPOWER1) ||
   1549          			(p_bma2x2->power_mode_u8 == BMA2x2_MODE_LOWPOWER2)) &&
   1550          				(power_mode_u8 == BMA2x2_MODE_NORMAL)) {
   1551          				/* Enter the power mode to suspend*/
   1552          				data_u8  = BMA2x2_SET_BITSLICE(data_u8,
   1553          				BMA2x2_MODE_CTRL, BMA2x2_SHIFT_FOUR_BITS);
   1554          				/* write the power mode to suspend*/
   1555          				com_rslt += bma2x2_write_reg(
   1556          				BMA2x2_MODE_CTRL_REG, &data_u8,
   1557          				BMA2x2_GEN_READ_WRITE_LENGTH);
   1558          				/*re-write FIFO_CONFIG_0 register*/
   1559          				com_rslt += bma2x2_write_reg(
   1560          				BMA2x2_FIFO_MODE_REG, &pre_fifo_config_data, 1);
   1561          			}
   1562          
   1563          		/* write the power mode to 0x11 register*/
   1564          		data_u8  = BMA2x2_SET_BITSLICE(data_u8, BMA2x2_MODE_CTRL,
   1565          			mode_ctr_eleven_reg);
   1566          		com_rslt += bma2x2_write_reg(BMA2x2_MODE_CTRL_REG, &data_u8, 1);
   1567          		/*A minimum delay of atleast 450us is required for
   1568          		the low power modes, as per the data sheet.*/
   1569          		p_bma2x2->delay_msec(BMA2x2_INTERFACE_IDLE_TIME_DELAY);
   1570          
   1571          		com_rslt += bma2x2_write_reg(BMA2x2_FIFO_MODE_REG,
   1572          		&pre_fifo_config_data, 1);
   1573          
   1574          		/*Assigning the power mode to the global variable*/
   1575          		p_bma2x2->power_mode_u8 = power_mode_u8;
   1576          	}
   1577          	return com_rslt;
   1578          }
   1579          /*!
   1580           *	@brief This API is used to assign the power mode values
   1581           *	modes of the sensor in the register 0x11 and 0x12
   1582           *	@note Register 0x11 - bit from 5 to 7
   1583           *	@note Register 0x12 - bit from 5 and 6
   1584           *
   1585           *
   1586           *  @param power_mode_u8 : The value of power mode
   1587           *	power_mode_u8           |value  |   0x11  |   0x12
   1588           *  ------------------------- |-------| --------|--------
   1589           *  BMA2x2_MODE_NORMAL        |  0    |  0x00   |  0x00
   1590           *  BMA2x2_MODE_LOWPOWER1     |  1    |  0x02   |  0x00
   1591           *  BMA2x2_MODE_SUSPEND       |  2    |  0x06   |  0x00
   1592           *  BMA2x2_MODE_DEEP_SUSPEND  |  3    |  0x01   |  0x00
   1593           *  BMA2x2_MODE_LOWPOWER2     |  4    |  0x02   |  0x01
   1594           *  BMA2x2_MODE_STANDBY       |  5    |  0x04   |  0x00
   1595           *
   1596           *
   1597           *
   1598           *	@return results of bus communication function
   1599           *	@retval 0 -> Success
   1600           *	@retval -1 -> Error
   1601           *
   1602           *
   1603           */
   1604          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_mode_value(u8 power_mode_u8)
   1605          {
   1606          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = SUCCESS;
   1607          
   1608          	if (p_bma2x2 == BMA2x2_NULL) {
   1609          		/* Check the struct p_bma2x2 is empty */
   1610          		com_rslt = E_BMA2x2_NULL_PTR;
   1611          	} else {
   1612          	if (power_mode_u8 < BMA2x2_POWER_MODE_RANGE) {
   1613          		switch (power_mode_u8)	{
   1614          		case BMA2x2_MODE_NORMAL:
   1615          			p_bma2x2->ctrl_mode_reg =
   1616          			BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK;
   1617          			p_bma2x2->low_mode_reg =
   1618          			BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK;
   1619          		break;
   1620          		case BMA2x2_MODE_LOWPOWER1:
   1621          			p_bma2x2->ctrl_mode_reg =
   1622          			BMA2x2_POWER_MODE_HEX_ZERO_TWO_MASK;
   1623          			p_bma2x2->low_mode_reg =
   1624          			BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK;
   1625          		break;
   1626          		case BMA2x2_MODE_LOWPOWER2:
   1627          			p_bma2x2->ctrl_mode_reg =
   1628          			BMA2x2_POWER_MODE_HEX_ZERO_TWO_MASK;
   1629          			p_bma2x2->low_mode_reg =
   1630          			BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK;
   1631          		break;
   1632          		case BMA2x2_MODE_SUSPEND:
   1633          			p_bma2x2->ctrl_mode_reg =
   1634          			BMA2x2_POWER_MODE_HEX_ZERO_FOUR_MASK;
   1635          			p_bma2x2->low_mode_reg =
   1636          			BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK;
   1637          		break;
   1638          		case BMA2x2_MODE_STANDBY:
   1639          			p_bma2x2->ctrl_mode_reg =
   1640          			BMA2x2_POWER_MODE_HEX_ZERO_FOUR_MASK;
   1641          			p_bma2x2->low_mode_reg =
   1642          			BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK;
   1643          		break;
   1644          		case BMA2x2_MODE_DEEP_SUSPEND:
   1645          			p_bma2x2->ctrl_mode_reg =
   1646          			BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK;
   1647          		break;
   1648          		}
   1649          		} else {
   1650          			com_rslt = E_OUT_OF_RANGE;
   1651          		}
   1652          	}
   1653          	return com_rslt;
   1654          }
   1655          /*!
   1656           *	@brief This API is used to get
   1657           *	the sleep duration of the sensor in the register 0x11
   1658           *	Register 0x11 - bit from 0 to 3
   1659           *
   1660           *
   1661           *  @param  sleep_durn_u8 : The value of sleep duration time
   1662           *         sleep_durn_u8 |   result
   1663           *       ----------------- | ----------------------
   1664           *              0x05       | BMA2x2_SLEEP_DURN_0_5MS
   1665           *              0x06       | BMA2x2_SLEEP_DURN_1MS
   1666           *              0x07       | BMA2x2_SLEEP_DURN_2MS
   1667           *              0x08       | BMA2x2_SLEEP_DURN_4MS
   1668           *              0x09       | BMA2x2_SLEEP_DURN_6MS
   1669           *              0x0A       | BMA2x2_SLEEP_DURN_10MS
   1670           *              0x0B       | BMA2x2_SLEEP_DURN_25MS
   1671           *              0x0C       | BMA2x2_SLEEP_DURN_50MS
   1672           *              0x0D       | BMA2x2_SLEEP_DURN_100MS
   1673           *              0x0E       | BMA2x2_SLEEP_DURN_500MS
   1674           *              0x0F       | BMA2x2_SLEEP_DURN_1S
   1675           *
   1676           *
   1677           *
   1678           *	@return results of bus communication function
   1679           *	@retval 0 -> Success
   1680           *	@retval -1 -> Error
   1681           *
   1682           *
   1683           */
   1684          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_sleep_durn(u8 *sleep_durn_u8)
   1685          {
   1686          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1687          	/*  Variable used to return value of
   1688          	communication routine*/
   1689          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1690          
   1691          	if (p_bma2x2 == BMA2x2_NULL) {
   1692          		/* Check the struct p_bma2x2 is empty */
   1693          		return E_BMA2x2_NULL_PTR;
   1694          		} else {
   1695          			/* read the sleep duration */
   1696          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1697          			(p_bma2x2->dev_addr, BMA2x2_SLEEP_DURN_REG,
   1698          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1699          			*sleep_durn_u8 = BMA2x2_GET_BITSLICE
   1700          			(data_u8, BMA2x2_SLEEP_DURN);
   1701          		}
   1702          	return com_rslt;
   1703          }
   1704          /*!
   1705           *	@brief This API is used to set
   1706           *	the sleep duration of the sensor in the register 0x11
   1707           *	Register 0x11 - bit from 0 to 3
   1708           *
   1709           *
   1710           *
   1711           *
   1712           *  @param  sleep_durn_u8 : The value of sleep duration time
   1713           *        sleep_durn_u8  |   result
   1714           *       ----------------- | ----------------------
   1715           *              0x05       | BMA2x2_SLEEP_DURN_0_5MS
   1716           *              0x06       | BMA2x2_SLEEP_DURN_1MS
   1717           *              0x07       | BMA2x2_SLEEP_DURN_2MS
   1718           *              0x08       | BMA2x2_SLEEP_DURN_4MS
   1719           *              0x09       | BMA2x2_SLEEP_DURN_6MS
   1720           *              0x0A       | BMA2x2_SLEEP_DURN_10MS
   1721           *              0x0B       | BMA2x2_SLEEP_DURN_25MS
   1722           *              0x0C       | BMA2x2_SLEEP_DURN_50MS
   1723           *              0x0D       | BMA2x2_SLEEP_DURN_100MS
   1724           *              0x0E       | BMA2x2_SLEEP_DURN_500MS
   1725           *              0x0F       | BMA2x2_SLEEP_DURN_1S
   1726           *
   1727           *
   1728           *
   1729           *	@return results of bus communication function
   1730           *	@retval 0 -> Success
   1731           *	@retval -1 -> Error
   1732           *
   1733           *
   1734           */
   1735          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_sleep_durn(u8 sleep_durn_u8)
   1736          {
   1737          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1738          	/*  Variable used to return value of
   1739          	communication routine*/
   1740          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1741          	u8 data_sleep_durn_u8 = BMA2x2_INIT_VALUE;
   1742          
   1743          	if (p_bma2x2 == BMA2x2_NULL) {
   1744          		/* Check the struct p_bma2x2 is empty */
   1745          		return E_BMA2x2_NULL_PTR;
   1746          		} else {
   1747          		if (sleep_durn_u8 > BMA2x2_SLEEP_DURN_MIN_RANGE &&
   1748          		sleep_durn_u8 < BMA2x2_SLEEP_DURN_MAX_RANGE) {
   1749          			switch (sleep_durn_u8) {
   1750          			case BMA2x2_SLEEP_DURN_0_5MS:
   1751          				data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_0_5MS;
   1752          
   1753          				/*  0.5 MS   */
   1754          			break;
   1755          			case BMA2x2_SLEEP_DURN_1MS:
   1756          				data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_1MS;
   1757          
   1758          				/*  1 MS  */
   1759          			break;
   1760          			case BMA2x2_SLEEP_DURN_2MS:
   1761          				data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_2MS;
   1762          
   1763          				/*  2 MS  */
   1764          			break;
   1765          			case BMA2x2_SLEEP_DURN_4MS:
   1766          				data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_4MS;
   1767          
   1768          				/*  4 MS   */
   1769          			break;
   1770          			case BMA2x2_SLEEP_DURN_6MS:
   1771          				data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_6MS;
   1772          
   1773          				/*  6 MS  */
   1774          			break;
   1775          			case BMA2x2_SLEEP_DURN_10MS:
   1776          				data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_10MS;
   1777          
   1778          				/*  10 MS  */
   1779          			break;
   1780          			case BMA2x2_SLEEP_DURN_25MS:
   1781          				data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_25MS;
   1782          
   1783          				/*  25 MS  */
   1784          			break;
   1785          			case BMA2x2_SLEEP_DURN_50MS:
   1786          				data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_50MS;
   1787          
   1788          				/*  50 MS   */
   1789          			break;
   1790          			case BMA2x2_SLEEP_DURN_100MS:
   1791          				data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_100MS;
   1792          
   1793          				/*  100 MS  */
   1794          			break;
   1795          			case BMA2x2_SLEEP_DURN_500MS:
   1796          				data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_500MS;
   1797          
   1798          				/*  500 MS   */
   1799          			break;
   1800          			case BMA2x2_SLEEP_DURN_1S:
   1801          				data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_1S;
   1802          
   1803          				/*!  1 SECS   */
   1804          			break;
   1805          			default:
   1806          			break;
   1807          			}
   1808          			/* write the sleep duration */
   1809          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1810          			(p_bma2x2->dev_addr, BMA2x2_SLEEP_DURN_REG,
   1811          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1812          			data_u8 = BMA2x2_SET_BITSLICE
   1813          			(data_u8, BMA2x2_SLEEP_DURN, data_sleep_durn_u8);
   1814          			com_rslt += bma2x2_write_reg(BMA2x2_SLEEP_DURN_REG,
   1815          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1816          		} else {
   1817          		com_rslt = E_OUT_OF_RANGE;
   1818          		}
   1819          	}
   1820          	return com_rslt;
   1821          }
   1822          /*!
   1823           * @brief This API is used to get the sleep timer mode
   1824           *	in the register 0x12 bit 5
   1825           *
   1826           *
   1827           *
   1828           *
   1829           *  @param  sleep_timer_u8 : The value of sleep timer mode
   1830           *        sleep_timer_u8 |   result
   1831           *       ----------------- | ----------------------
   1832           *              0          | enable EventDrivenSampling(EDT)
   1833           *              1          | enable Equidistant sampling mode(EST)
   1834           *
   1835           *
   1836           *	@return results of bus communication function
   1837           *	@retval 0 -> Success
   1838           *	@retval -1 -> Error
   1839           *
   1840           *
   1841           */
   1842          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_sleep_timer_mode(
   1843          u8 *sleep_timer_u8)
   1844          {
   1845          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1846          	/*  Variable used to return value of
   1847          	communication routine*/
   1848          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1849          
   1850          	if (p_bma2x2 == BMA2x2_NULL) {
   1851          		/* Check the struct p_bma2x2 is empty */
   1852          		return E_BMA2x2_NULL_PTR;
   1853          		} else {
   1854          			/*Read the SLEEP TIMER MODE*/
   1855          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1856          			(p_bma2x2->dev_addr, BMA2x2_SLEEP_TIMER_REG,
   1857          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1858          			*sleep_timer_u8 = BMA2x2_GET_BITSLICE
   1859          			(data_u8, BMA2x2_SLEEP_TIMER);
   1860          		}
   1861          	return com_rslt;
   1862          }
   1863          /*!
   1864           * @brief This API is used to set the sleep timer mode
   1865           *	in the register 0x12 bit 5
   1866           *
   1867           *
   1868           *
   1869           *
   1870           *  @param  sleep_timer_u8 : The value of sleep timer mode
   1871           *        sleep_timer_u8 |   result
   1872           *       ----------------- | ----------------------
   1873           *              0          | enable EventDrivenSampling(EDT)
   1874           *              1          | enable Equidistant sampling mode(EST)
   1875           *
   1876           *
   1877           *	@return results of bus communication function
   1878           *	@retval 0 -> Success
   1879           *	@retval -1 -> Error
   1880           *
   1881           *
   1882           */
   1883          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_sleep_timer_mode(u8 sleep_timer_u8)
   1884          {
   1885          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1886          	/*  Variable used to return value of
   1887          	communication routine*/
   1888          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1889          
   1890          	if (p_bma2x2 == BMA2x2_NULL) {
   1891          		/* Check the struct p_bma2x2 is empty */
   1892          		return E_BMA2x2_NULL_PTR;
   1893          		} else {
   1894          		if (sleep_timer_u8 < BMA2x2_SLEEP_TIMER_MODE_RANGE) {
   1895          			/* write the SLEEP TIMER MODE*/
   1896          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1897          			(p_bma2x2->dev_addr, BMA2x2_SLEEP_TIMER_REG,
   1898          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1899          			data_u8 = BMA2x2_SET_BITSLICE
   1900          			(data_u8, BMA2x2_SLEEP_TIMER, sleep_timer_u8);
   1901          			com_rslt += bma2x2_write_reg(BMA2x2_SLEEP_TIMER_REG,
   1902          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1903          		} else {
   1904          		com_rslt = E_OUT_OF_RANGE;
   1905          		}
   1906          	}
   1907          	return com_rslt;
   1908          }
   1909          /*!
   1910           * @brief This API is used to get high bandwidth
   1911           *		in the register 0x13 bit 7
   1912           *
   1913           *  @param  high_bw_u8 : The value of high bandwidth
   1914           *         high_bw_u8    |   result
   1915           *       ----------------- | ----------------------
   1916           *              0          | Unfiltered High Bandwidth
   1917           *              1          | Filtered Low Bandwidth
   1918           *
   1919           *
   1920           *	@return results of bus communication function
   1921           *	@retval 0 -> Success
   1922           *	@retval -1 -> Error
   1923           *
   1924           *
   1925           */
   1926          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_high_bw(u8 *high_bw_u8)
   1927          {
   1928          	/*  Variable used to return value of
   1929          	communication routine*/
   1930          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1931          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1932          
   1933          	if (p_bma2x2 == BMA2x2_NULL) {
   1934          		return  E_BMA2x2_NULL_PTR;
   1935          		} else {
   1936          			/* Read the high bandwidth*/
   1937          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1938          			(p_bma2x2->dev_addr, BMA2x2_ENABLE_DATA_HIGH_BW_REG,
   1939          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1940          			*high_bw_u8 = BMA2x2_GET_BITSLICE
   1941          			(data_u8, BMA2x2_ENABLE_DATA_HIGH_BW);
   1942          		}
   1943          	return com_rslt;
   1944          }
   1945          /*!
   1946           * @brief This API is used to write high bandwidth
   1947           *		in the register 0x13 bit 7
   1948           *
   1949           *  @param  high_bw_u8 : The value of high bandwidth
   1950           *         high_bw_u8    |   result
   1951           *       ----------------- | ----------------------
   1952           *              0          | Unfiltered High Bandwidth
   1953           *              1          | Filtered Low Bandwidth
   1954           *
   1955           *
   1956           *	@return results of bus communication function
   1957           *	@retval 0 -> Success
   1958           *	@retval -1 -> Error
   1959           *
   1960           *
   1961           */
   1962          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_high_bw(u8 high_bw_u8)
   1963          {
   1964          	/*  Variable used to return value of
   1965          	communication routine*/
   1966          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1967          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1968          
   1969          	if (p_bma2x2 == BMA2x2_NULL) {
   1970          		return  E_BMA2x2_NULL_PTR;
   1971          		}  else {
   1972          			/* Write the high bandwidth*/
   1973          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1974          			(p_bma2x2->dev_addr, BMA2x2_ENABLE_DATA_HIGH_BW_REG,
   1975          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1976          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   1977          			BMA2x2_ENABLE_DATA_HIGH_BW, high_bw_u8);
   1978          			com_rslt += bma2x2_write_reg(
   1979          			BMA2x2_ENABLE_DATA_HIGH_BW_REG,
   1980          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1981          		}
   1982          	return com_rslt;
   1983          }
   1984          /*!
   1985           *	@brief This API is used to get shadow dis
   1986           *	in the register 0x13 bit 6
   1987           *
   1988           *  @param  shadow_dis_u8 : The value of shadow dis
   1989           *        shadow_dis_u8  |   result
   1990           *       ----------------- | ------------------
   1991           *              0          | MSB is Locked
   1992           *              1          | No MSB Locking
   1993           *
   1994           *
   1995           *
   1996           *	@return results of bus communication function
   1997           *	@retval 0 -> Success
   1998           *	@retval -1 -> Error
   1999           *
   2000           *
   2001           */
   2002          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_shadow_dis(u8 *shadow_dis_u8)
   2003          {
   2004          	/*  Variable used to return value of
   2005          	communication routine*/
   2006          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2007          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2008          
   2009          	if (p_bma2x2 == BMA2x2_NULL) {
   2010          		return  E_BMA2x2_NULL_PTR;
   2011          		} else {
   2012          			/*Read the shadow dis*/
   2013          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2014          			(p_bma2x2->dev_addr,
   2015          			BMA2x2_DIS_SHADOW_PROC_REG,
   2016          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2017          			*shadow_dis_u8 = BMA2x2_GET_BITSLICE
   2018          			(data_u8, BMA2x2_DIS_SHADOW_PROC);
   2019          		}
   2020          	return com_rslt;
   2021          }
   2022          /*!
   2023           *	@brief This API is used to set shadow dis
   2024           *	in the register 0x13 bit 6
   2025           *
   2026           *  @param  shadow_dis_u8 : The value of shadow dis
   2027           *        shadow_dis_u8  |   result
   2028           *       ----------------- | ------------------
   2029           *              0          | MSB is Locked
   2030           *              1          | No MSB Locking
   2031           *
   2032           *
   2033           *
   2034           *	@return results of bus communication function
   2035           *	@retval 0 -> Success
   2036           *	@retval -1 -> Error
   2037           *
   2038           *
   2039           */
   2040          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_shadow_dis(u8 shadow_dis_u8)
   2041          {
   2042          	/*  Variable used to return value of
   2043          	communication routine*/
   2044          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2045          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2046          
   2047          	if (p_bma2x2 == BMA2x2_NULL) {
   2048          		return  E_BMA2x2_NULL_PTR;
   2049          		} else {
   2050          			/* Write the shadow dis*/
   2051          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2052          			(p_bma2x2->dev_addr, BMA2x2_DIS_SHADOW_PROC_REG,
   2053          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2054          			data_u8 = BMA2x2_SET_BITSLICE
   2055          			(data_u8, BMA2x2_DIS_SHADOW_PROC, shadow_dis_u8);
   2056          			com_rslt += bma2x2_write_reg(BMA2x2_DIS_SHADOW_PROC_REG,
   2057          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2058          		}
   2059          	return com_rslt;
   2060          }
   2061          /*!
   2062           *	@brief This function is used for the soft reset
   2063           *	The soft reset register will be written
   2064           *	with 0xB6 in the register 0x14.
   2065           *
   2066           *
   2067           *
   2068           *  \param : None
   2069           *
   2070           *	@return results of bus communication function
   2071           *	@retval 0 -> Success
   2072           *	@retval -1 -> Error
   2073           *
   2074           *
   2075           */
   2076          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_soft_rst(void)
   2077          {
   2078          	/*  Variable used to return value of
   2079          	communication routine*/
   2080          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2081          	u8 data_u8 = BMA2x2_ENABLE_SOFT_RESET_VALUE;
   2082          
   2083          	if (p_bma2x2 == BMA2x2_NULL) {
   2084          		/* Check the struct p_bma2x2 is empty */
   2085          		return E_BMA2x2_NULL_PTR;
   2086          		}  else {
   2087          			/*! To reset the sensor
   2088          			0xB6 value_u8 will be written */
   2089          			com_rslt = bma2x2_write_reg(BMA2x2_RST_ADDR,
   2090          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2091          		}
   2092          	return com_rslt;
   2093          }
   2094          /*!
   2095           * @brief This API is used to update the register values
   2096           *
   2097           *
   2098           *
   2099           *
   2100           *  @param : None
   2101           *
   2102           *
   2103           *
   2104           *	@return results of bus communication function
   2105           *	@retval 0 -> Success
   2106           *	@retval -1 -> Error
   2107           *
   2108           *
   2109           */
   2110          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_update_image(void)
   2111          {
   2112          	/*  Variable used to return value of
   2113          	communication routine*/
   2114          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2115          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2116          
   2117          	if (p_bma2x2 == BMA2x2_NULL) {
   2118          		return  E_BMA2x2_NULL_PTR;
   2119          		} else {
   2120          			/* Write the update image*/
   2121          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2122          			(p_bma2x2->dev_addr, BMA2x2_UPDATE_IMAGE_REG,
   2123          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2124          			data_u8 = BMA2x2_SET_BITSLICE
   2125          			(data_u8, BMA2x2_UPDATE_IMAGE,
   2126          			BMA2x2_GEN_READ_WRITE_LENGTH);
   2127          			com_rslt += bma2x2_write_reg(BMA2x2_UPDATE_IMAGE_REG,
   2128          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2129          		}
   2130          	return com_rslt;
   2131          }
   2132          /*!
   2133           *	@brief This API is used to get
   2134           *  interrupt enable bits of the sensor in the registers 0x16 and 0x17
   2135           *	@note It reads the flat enable, orient enable,
   2136           *	@note single tap enable, double tap enable
   2137           *	@note slope-x enable, slope-y enable, slope-z enable,
   2138           *	@note fifo watermark enable,
   2139           *	@note fifo full enable, data enable, low-g enable,
   2140           *	@note high-z enable, high-y enable
   2141           *	@note high-z enable
   2142           *
   2143           *
   2144           *
   2145           *  @param intr_type_u8: The value of interrupts
   2146           *        intr_type_u8   |   result
   2147           *       ----------------- | ------------------
   2148           *              0          | BMA2x2_LOW_G_INTR
   2149           *              1          | BMA2x2_HIGH_G_X_INTR
   2150           *              2          | BMA2x2_HIGH_G_Y_INTR
   2151           *              3          | BMA2x2_HIGH_G_Z_INTR
   2152           *              4          | BMA2x2_DATA_ENABLE
   2153           *              5          | SLOPE_X_INTR
   2154           *              6          | SLOPE_Y_INTR
   2155           *              7          | SLOPE_Z_INTR
   2156           *              8          | SINGLE_TAP_INTR
   2157           *              9          | SINGLE_TAP_INTR
   2158           *              10         | ORIENT_INT
   2159           *              11         | FLAT_INT
   2160           *
   2161           *  @param value_u8 : The value of interrupts enable
   2162           *        value_u8       |   result
   2163           *       ----------------- | ------------------
   2164           *              0x00       | INTR_DISABLE
   2165           *              0x01       | INTR_ENABLE
   2166           *
   2167           *
   2168           *
   2169           *
   2170           *	@return results of bus communication function
   2171           *	@retval 0 -> Success
   2172           *	@retval -1 -> Error
   2173           *
   2174           *
   2175           */
   2176          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_enable(u8 intr_type_u8,
   2177          u8 *value_u8)
   2178          {
   2179          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2180          		/*  Variable used to return value of
   2181          	communication routine*/
   2182          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2183          
   2184          	if (p_bma2x2 == BMA2x2_NULL) {
   2185          		/* Check the struct p_bma2x2 is empty */
   2186          		return E_BMA2x2_NULL_PTR;
   2187          		} else {
   2188          		switch (intr_type_u8) {
   2189          		case BMA2x2_LOW_G_INTR:
   2190          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2191          			(p_bma2x2->dev_addr,
   2192          			BMA2x2_ENABLE_LOW_G_INTR_REG,
   2193          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2194          			*value_u8 = BMA2x2_GET_BITSLICE
   2195          			(data_u8, BMA2x2_ENABLE_LOW_G_INTR);
   2196          		break;
   2197          		case BMA2x2_HIGH_G_X_INTR:
   2198          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2199          			(p_bma2x2->dev_addr,
   2200          			BMA2x2_ENABLE_HIGH_G_X_INTR_REG,
   2201          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2202          			*value_u8 = BMA2x2_GET_BITSLICE
   2203          			(data_u8, BMA2x2_ENABLE_HIGH_G_X_INTR);
   2204          		break;
   2205          		case BMA2x2_HIGH_G_Y_INTR:
   2206          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2207          			(p_bma2x2->dev_addr,
   2208          			BMA2x2_ENABLE_HIGH_G_Y_INTR_REG,
   2209          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2210          			*value_u8 = BMA2x2_GET_BITSLICE
   2211          			(data_u8, BMA2x2_ENABLE_HIGH_G_Y_INTR);
   2212          		break;
   2213          		case BMA2x2_HIGH_G_Z_INTR:
   2214          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2215          			(p_bma2x2->dev_addr,
   2216          			BMA2x2_ENABLE_HIGH_G_Z_INTR_REG,
   2217          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2218          			*value_u8 = BMA2x2_GET_BITSLICE
   2219          			(data_u8, BMA2x2_ENABLE_HIGH_G_Z_INTR);
   2220          		break;
   2221          		case BMA2x2_DATA_ENABLE:
   2222          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2223          			(p_bma2x2->dev_addr,
   2224          			BMA2x2_ENABLE_NEW_DATA_INTR_REG,
   2225          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2226          			*value_u8 = BMA2x2_GET_BITSLICE
   2227          			(data_u8, BMA2x2_ENABLE_NEW_DATA_INTR);
   2228          		break;
   2229          		case BMA2x2_SLOPE_X_INTR:
   2230          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2231          			(p_bma2x2->dev_addr,
   2232          			BMA2x2_ENABLE_SLOPE_X_INTR_REG,
   2233          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2234          			*value_u8 = BMA2x2_GET_BITSLICE
   2235          			(data_u8, BMA2x2_ENABLE_SLOPE_X_INTR);
   2236          		break;
   2237          		case BMA2x2_SLOPE_Y_INTR:
   2238          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2239          			(p_bma2x2->dev_addr,
   2240          			BMA2x2_ENABLE_SLOPE_Y_INTR_REG,
   2241          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2242          			*value_u8 = BMA2x2_GET_BITSLICE
   2243          			(data_u8, BMA2x2_ENABLE_SLOPE_Y_INTR);
   2244          		break;
   2245          		case BMA2x2_SLOPE_Z_INTR:
   2246          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2247          			(p_bma2x2->dev_addr,
   2248          			BMA2x2_ENABLE_SLOPE_Z_INTR_REG,
   2249          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2250          			*value_u8 = BMA2x2_GET_BITSLICE
   2251          			(data_u8, BMA2x2_ENABLE_SLOPE_Z_INTR);
   2252          		break;
   2253          		case BMA2x2_SINGLE_TAP_INTR:
   2254          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2255          			(p_bma2x2->dev_addr,
   2256          			BMA2x2_ENABLE_SINGLE_TAP_INTR_REG,
   2257          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2258          			*value_u8 = BMA2x2_GET_BITSLICE
   2259          			(data_u8, BMA2x2_ENABLE_SINGLE_TAP_INTR);
   2260          		break;
   2261          		case BMA2x2_DOUBLE_TAP_INTR:
   2262          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2263          			(p_bma2x2->dev_addr,
   2264          			BMA2x2_ENABLE_DOUBLE_TAP_INTR_REG,
   2265          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2266          			*value_u8 = BMA2x2_GET_BITSLICE
   2267          			(data_u8, BMA2x2_ENABLE_DOUBLE_TAP_INTR);
   2268          		break;
   2269          		case BMA2x2_ORIENT_INTR:
   2270          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2271          			(p_bma2x2->dev_addr,
   2272          			BMA2x2_ENABLE_ORIENT_INTR_REG,
   2273          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2274          			*value_u8 = BMA2x2_GET_BITSLICE
   2275          			(data_u8, BMA2x2_ENABLE_ORIENT_INTR);
   2276          		break;
   2277          		case BMA2x2_FLAT_INTR:
   2278          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2279          			(p_bma2x2->dev_addr,
   2280          			BMA2x2_ENABLE_FLAT_INTR_REG,
   2281          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2282          			*value_u8 = BMA2x2_GET_BITSLICE
   2283          			(data_u8, BMA2x2_ENABLE_FLAT_INTR);
   2284          		break;
   2285          		default:
   2286          		com_rslt = E_OUT_OF_RANGE;
   2287          		break;
   2288          		}
   2289          	}
   2290          	return com_rslt;
   2291          }
   2292          /*!
   2293           *	@brief This API is used to set
   2294           *  interrupt enable bits of the sensor in the registers 0x16 and 0x17
   2295           *	@note It reads the flat enable, orient enable,
   2296           *	@note single tap enable, double tap enable
   2297           *	@note slope-x enable, slope-y enable, slope-z enable,
   2298           *	@note fifo watermark enable,
   2299           *	@note fifo full enable, data enable, low-g enable,
   2300           *	@note high-z enable, high-y enable
   2301           *	@note high-z enable
   2302           *
   2303           *
   2304           *
   2305           *  @param intr_type_u8: The value of interrupts
   2306           *        intr_type_u8   |   result
   2307           *       ----------------- | ------------------
   2308           *              0          | BMA2x2_LOW_G_INTR
   2309           *              1          | BMA2x2_HIGH_G_X_INTR
   2310           *              2          | BMA2x2_HIGH_G_Y_INTR
   2311           *              3          | BMA2x2_HIGH_G_Z_INTR
   2312           *              4          | BMA2x2_DATA_ENABLE
   2313           *              5          | SLOPE_X_INTR
   2314           *              6          | SLOPE_Y_INTR
   2315           *              7          | SLOPE_Z_INTR
   2316           *              8          | SINGLE_TAP_INTR
   2317           *              9          | SINGLE_TAP_INTR
   2318           *              10         | ORIENT_INT
   2319           *              11         | FLAT_INT
   2320           *
   2321           *  @param value_u8 : The value of interrupts enable
   2322           *        value_u8       |   result
   2323           *       ----------------- | ------------------
   2324           *              0x00       | INTR_DISABLE
   2325           *              0x01       | INTR_ENABLE
   2326           *
   2327           *
   2328           *
   2329           *
   2330           *	@return results of bus communication function
   2331           *	@retval 0 -> Success
   2332           *	@retval -1 -> Error
   2333           *
   2334           *
   2335           */
   2336          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_enable(u8 intr_type_u8,
   2337          u8 value_u8)
   2338          {
   2339          		/*  Variable used to return value of
   2340          	communication routine*/
   2341          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2342          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2343          	u8 data2_u8 = BMA2x2_INIT_VALUE;
   2344          
   2345          	if (p_bma2x2 == BMA2x2_NULL) {
   2346          		/* Check the struct p_bma2x2 is empty */
   2347          		return E_BMA2x2_NULL_PTR;
   2348          		} else {
   2349          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2350          		(p_bma2x2->dev_addr, BMA2x2_INTR_ENABLE1_ADDR,
   2351          		&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2352          		com_rslt += p_bma2x2->BMA2x2_BUS_READ_FUNC
   2353          		(p_bma2x2->dev_addr, BMA2x2_INTR_ENABLE2_ADDR,
   2354          		&data2_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2355          		value_u8 = value_u8 & BMA2x2_GEN_READ_WRITE_LENGTH;
   2356          		switch (intr_type_u8) {
   2357          		case BMA2x2_LOW_G_INTR:
   2358          			/* Low G Interrupt  */
   2359          			data2_u8 = BMA2x2_SET_BITSLICE(data2_u8,
   2360          			BMA2x2_ENABLE_LOW_G_INTR, value_u8);
   2361          		break;
   2362          		case BMA2x2_HIGH_G_X_INTR:
   2363          			/* High G X Interrupt */
   2364          			data2_u8 = BMA2x2_SET_BITSLICE(data2_u8,
   2365          			BMA2x2_ENABLE_HIGH_G_X_INTR, value_u8);
   2366          		break;
   2367          		case BMA2x2_HIGH_G_Y_INTR:
   2368          			/* High G Y Interrupt */
   2369          			data2_u8 = BMA2x2_SET_BITSLICE(data2_u8,
   2370          			BMA2x2_ENABLE_HIGH_G_Y_INTR, value_u8);
   2371          		break;
   2372          		case BMA2x2_HIGH_G_Z_INTR:
   2373          			/* High G Z Interrupt */
   2374          			data2_u8 = BMA2x2_SET_BITSLICE(data2_u8,
   2375          			BMA2x2_ENABLE_HIGH_G_Z_INTR, value_u8);
   2376          		break;
   2377          		case BMA2x2_DATA_ENABLE:
   2378          			/*Data En Interrupt  */
   2379          			data2_u8 = BMA2x2_SET_BITSLICE(data2_u8,
   2380          			BMA2x2_ENABLE_NEW_DATA_INTR, value_u8);
   2381          		break;
   2382          		case BMA2x2_SLOPE_X_INTR:
   2383          			/* Slope X Interrupt */
   2384          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2385          			BMA2x2_ENABLE_SLOPE_X_INTR, value_u8);
   2386          		break;
   2387          		case BMA2x2_SLOPE_Y_INTR:
   2388          			/* Slope Y Interrupt */
   2389          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2390          			BMA2x2_ENABLE_SLOPE_Y_INTR, value_u8);
   2391          		break;
   2392          		case BMA2x2_SLOPE_Z_INTR:
   2393          			/* Slope Z Interrupt */
   2394          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2395          			BMA2x2_ENABLE_SLOPE_Z_INTR, value_u8);
   2396          		break;
   2397          		case BMA2x2_SINGLE_TAP_INTR:
   2398          			/* Single Tap Interrupt */
   2399          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2400          				BMA2x2_ENABLE_SINGLE_TAP_INTR, value_u8);
   2401          		break;
   2402          		case BMA2x2_DOUBLE_TAP_INTR:
   2403          			/* Double Tap Interrupt */
   2404          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2405          				BMA2x2_ENABLE_DOUBLE_TAP_INTR, value_u8);
   2406          		break;
   2407          		case BMA2x2_ORIENT_INTR:
   2408          			/* Orient Interrupt  */
   2409          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2410          			BMA2x2_ENABLE_ORIENT_INTR, value_u8);
   2411          		break;
   2412          		case BMA2x2_FLAT_INTR:
   2413          			/* Flat Interrupt */
   2414          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2415          			BMA2x2_ENABLE_FLAT_INTR, value_u8);
   2416          		break;
   2417          		default:
   2418          			com_rslt = E_OUT_OF_RANGE;
   2419          		break;
   2420          		}
   2421          		/* write the interrupt*/
   2422          		com_rslt += bma2x2_write_reg
   2423          		(BMA2x2_INTR_ENABLE1_ADDR,
   2424          		&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2425          		com_rslt += bma2x2_write_reg
   2426          		(BMA2x2_INTR_ENABLE2_ADDR,
   2427          		&data2_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2428          	}
   2429          	return com_rslt;
   2430          }
   2431          /*!
   2432           *	@brief This API is used to get
   2433           *	the interrupt fifo full enable interrupt status
   2434           *	in the register 0x17 bit 5
   2435           *
   2436           *
   2437           *  @param fifo_full_u8 The value of fifo full interrupt enable
   2438           *        fifo_full_u8   |   result
   2439           *       ----------------- | ------------------
   2440           *              0x00       | INTR_DISABLE
   2441           *              0x01       | INTR_ENABLE
   2442           *
   2443           *
   2444           *
   2445           *	@return results of bus communication function
   2446           *	@retval 0 -> Success
   2447           *	@retval -1 -> Error
   2448           *
   2449           *
   2450           */
   2451          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_fifo_full(u8 *fifo_full_u8)
   2452          {
   2453          	/*  Variable used to return value of
   2454          	communication routine*/
   2455          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2456          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2457          
   2458          	if (p_bma2x2 == BMA2x2_NULL) {
   2459          		/* Check the struct p_bma2x2 is empty */
   2460          		return E_BMA2x2_NULL_PTR;
   2461          		} else {
   2462          			/* Read fifo full interrupt */
   2463          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2464          			(p_bma2x2->dev_addr,
   2465          			BMA2x2_INTR_FIFO_FULL_ENABLE_INTR_REG,
   2466          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2467          			*fifo_full_u8 = BMA2x2_GET_BITSLICE(data_u8,
   2468          			BMA2x2_INTR_FIFO_FULL_ENABLE_INTR);
   2469          		}
   2470          	return com_rslt;
   2471          }
   2472          /*!
   2473           *	@brief This API is used to set
   2474           *	the interrupt fifo full enable interrupt status
   2475           *	in the register 0x17 bit 5
   2476           *
   2477           *
   2478           *  @param fifo_full_u8 The value of fifo full interrupt enable
   2479           *        fifo_full_u8   |   result
   2480           *       ----------------- | ------------------
   2481           *              0x00       | INTR_DISABLE
   2482           *              0x01       | INTR_ENABLE
   2483           *
   2484           *
   2485           *
   2486           *	@return results of bus communication function
   2487           *	@retval 0 -> Success
   2488           *	@retval -1 -> Error
   2489           *
   2490           *
   2491           */
   2492          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_fifo_full(u8 fifo_full_u8)
   2493          {
   2494          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2495          		/*  Variable used to return value of
   2496          	communication routine*/
   2497          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2498          
   2499          	if (p_bma2x2 == BMA2x2_NULL) {
   2500          		/* Check the struct p_bma2x2 is empty */
   2501          		return E_BMA2x2_NULL_PTR;
   2502          		} else {
   2503          		if (fifo_full_u8 < BMA2x2_FIFO_MODE_STATUS_RANGE) {
   2504          			/* Write fifo full interrupt */
   2505          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2506          			(p_bma2x2->dev_addr,
   2507          			BMA2x2_INTR_FIFO_FULL_ENABLE_INTR_REG,
   2508          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2509          			data_u8 = BMA2x2_SET_BITSLICE
   2510          			(data_u8, BMA2x2_INTR_FIFO_FULL_ENABLE_INTR,
   2511          			fifo_full_u8);
   2512          			com_rslt += bma2x2_write_reg(
   2513          			BMA2x2_INTR_FIFO_FULL_ENABLE_INTR_REG,
   2514          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2515          		} else {
   2516          		com_rslt = E_OUT_OF_RANGE;
   2517          		}
   2518          	}
   2519          	return com_rslt;
   2520          }
   2521          /*!
   2522           * @brief This API is used to get
   2523           *	the interrupt fifo watermark enable interrupt status
   2524           *	in the register 0x17 bit 6
   2525           *
   2526           *
   2527           *
   2528           *
   2529           *  @param fifo_wm_u8 : the value FIFO Water Mark
   2530           *        fifo_wm_u8     |   result
   2531           *       ----------------- | ------------------
   2532           *              0x00       | INTR_DISABLE
   2533           *              0x01       | INTR_ENABLE
   2534           *
   2535           *
   2536           *
   2537           *	@return results of bus communication function
   2538           *	@retval 0 -> Success
   2539           *	@retval -1 -> Error
   2540           *
   2541           *
   2542           */
   2543          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_fifo_wm(u8 *fifo_wm_u8)
   2544          {
   2545          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2546          		/*  Variable used to return value of
   2547          	communication routine*/
   2548          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2549          
   2550          	if (p_bma2x2 == BMA2x2_NULL) {
   2551          		/* Check the struct p_bma2x2 is empty */
   2552          		return E_BMA2x2_NULL_PTR;
   2553          		} else {
   2554          			/* Read the fifo water mark*/
   2555          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2556          			(p_bma2x2->dev_addr,
   2557          			BMA2x2_INTR_FIFO_WM_ENABLE_INTR_REG,
   2558          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2559          			*fifo_wm_u8 = BMA2x2_GET_BITSLICE
   2560          			(data_u8, BMA2x2_INTR_FIFO_WM_ENABLE_INTR);
   2561          		}
   2562          	return com_rslt;
   2563          }
   2564          /*!
   2565           * @brief This API is used to set
   2566           *	the interrupt fifo watermark enable interrupt status
   2567           *	in the register 0x17 bit 6
   2568           *
   2569           *
   2570           *
   2571           *
   2572           *  @param fifo_wm_u8 : the value FIFO Water Mark
   2573           *        fifo_wm_u8     |   result
   2574           *       ----------------- | ------------------
   2575           *              0x00       | INTR_DISABLE
   2576           *              0x01       | INTR_ENABLE
   2577           *
   2578           *
   2579           *
   2580           *	@return results of bus communication function
   2581           *	@retval 0 -> Success
   2582           *	@retval -1 -> Error
   2583           *
   2584           *
   2585           */
   2586          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_fifo_wm(u8 fifo_wm_u8)
   2587          {
   2588          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2589          		/*  Variable used to return value of
   2590          	communication routine*/
   2591          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2592          
   2593          	if (p_bma2x2 == BMA2x2_NULL) {
   2594          		/* Check the struct p_bma2x2 is empty */
   2595          		return E_BMA2x2_NULL_PTR;
   2596          		} else {
   2597          		if (fifo_wm_u8 < BMA2x2_FIFO_MODE_STATUS_RANGE) {
   2598          			/* Write the fifo water mark interrupt*/
   2599          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2600          			(p_bma2x2->dev_addr,
   2601          			BMA2x2_INTR_FIFO_WM_ENABLE_INTR_REG,
   2602          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2603          			data_u8 = BMA2x2_SET_BITSLICE
   2604          			(data_u8, BMA2x2_INTR_FIFO_WM_ENABLE_INTR,
   2605          			fifo_wm_u8);
   2606          			com_rslt += bma2x2_write_reg(
   2607          			BMA2x2_INTR_FIFO_WM_ENABLE_INTR_REG,
   2608          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2609          		} else {
   2610          		com_rslt = E_OUT_OF_RANGE;
   2611          		}
   2612          	}
   2613          	return com_rslt;
   2614          }
   2615          /*!
   2616           * @brief This API is used to get
   2617           * the interrupt status of slow/no motion select and slow no motion
   2618           * enable xyz interrupt in the register 0x18 bit from 0 to 3
   2619           *
   2620           *
   2621           *  @param  channel_u8 : The value of slow/no motion select
   2622           *        channel_u8     |   result
   2623           *       ----------------- | ------------------
   2624           *              0          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_X
   2625           *              1          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_Y
   2626           *              2          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_Z
   2627           *              3          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_SEL
   2628           *
   2629           *	@param slow_no_motion_u8 : The value of slow no motion interrupt enable
   2630           *        slow_no_motion_u8     |   result
   2631           *       ------------------------ | ------------------
   2632           *              0x00              | INTR_DISABLE
   2633           *              0x01              | INTR_ENABLE
   2634           *
   2635           *
   2636           *	@return results of bus communication function
   2637           *	@retval 0 -> Success
   2638           *	@retval -1 -> Error
   2639           *
   2640           *
   2641           */
   2642          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_slow_no_motion(u8 channel_u8,
   2643          u8 *slow_no_motion_u8)
   2644          {
   2645          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2646          		/*  Variable used to return value of
   2647          	communication routine*/
   2648          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2649          
   2650          	if (p_bma2x2 == BMA2x2_NULL) {
   2651          		/* Check the struct p_bma2x2 is empty */
   2652          		return E_BMA2x2_NULL_PTR;
   2653          		} else {
   2654          		/* Read the slow no motion interrupt */
   2655          		switch (channel_u8) {
   2656          		case BMA2x2_SLOW_NO_MOTION_ENABLE_X:
   2657          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2658          			(p_bma2x2->dev_addr,
   2659          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR_REG,
   2660          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2661          			*slow_no_motion_u8 = BMA2x2_GET_BITSLICE
   2662          			(data_u8, BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR);
   2663          		break;
   2664          		case BMA2x2_SLOW_NO_MOTION_ENABLE_Y:
   2665          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2666          			(p_bma2x2->dev_addr,
   2667          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR_REG,
   2668          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2669          			*slow_no_motion_u8 = BMA2x2_GET_BITSLICE
   2670          			(data_u8, BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR);
   2671          		break;
   2672          		case BMA2x2_SLOW_NO_MOTION_ENABLE_Z:
   2673          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2674          			(p_bma2x2->dev_addr,
   2675          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR_REG,
   2676          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2677          			*slow_no_motion_u8 = BMA2x2_GET_BITSLICE
   2678          			(data_u8, BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR);
   2679          		break;
   2680          		case BMA2x2_SLOW_NO_MOTION_ENABLE_SELECT:
   2681          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2682          			(p_bma2x2->dev_addr,
   2683          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR_REG,
   2684          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2685          			*slow_no_motion_u8 = BMA2x2_GET_BITSLICE
   2686          			(data_u8,
   2687          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR);
   2688          		break;
   2689          		default:
   2690          			com_rslt = E_OUT_OF_RANGE;
   2691          		break;
   2692          		}
   2693          	}
   2694          	return com_rslt;
   2695          }
   2696          /*!
   2697           * @brief This API is used to set
   2698           * the interrupt status of slow/no motion select and slow no motion
   2699           * enable xyz interrupt in the register 0x18 bit from 0 to 3
   2700           *
   2701           *
   2702           *  @param  channel_u8 : The value of slow/no motion select
   2703           *        channel_u8     |   result
   2704           *       ----------------- | ------------------
   2705           *              0          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_X
   2706           *              1          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_Y
   2707           *              2          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_Z
   2708           *              3          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_SEL
   2709           *
   2710           *	@param slow_no_motion_u8 : The value of slow no motion
   2711           *      interrupt enable
   2712           *        slow_no_motion_u8     |   result
   2713           *       ------------------------ | ------------------
   2714           *              0x00              | INTR_DISABLE
   2715           *              0x01              | INTR_ENABLE
   2716           *
   2717           *
   2718           *	@return results of bus communication function
   2719           *	@retval 0 -> Success
   2720           *	@retval -1 -> Error
   2721           *
   2722           *
   2723           */
   2724          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_slow_no_motion(u8 channel_u8,
   2725          u8 slow_no_motion_u8)
   2726          {
   2727          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2728          		/*  Variable used to return value of
   2729          	communication routine*/
   2730          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2731          
   2732          	if (p_bma2x2 == BMA2x2_NULL) {
   2733          		/* Check the struct p_bma2x2 is empty */
   2734          		return E_BMA2x2_NULL_PTR;
   2735          		} else {
   2736          		/* Write the slow no motion interrupt*/
   2737          		switch (channel_u8) {
   2738          		case BMA2x2_SLOW_NO_MOTION_ENABLE_X:
   2739          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2740          			(p_bma2x2->dev_addr,
   2741          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR_REG,
   2742          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2743          			data_u8 = BMA2x2_SET_BITSLICE
   2744          			(data_u8,
   2745          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR,
   2746          			slow_no_motion_u8);
   2747          			com_rslt += bma2x2_write_reg(
   2748          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR_REG,
   2749          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2750          		break;
   2751          		case BMA2x2_SLOW_NO_MOTION_ENABLE_Y:
   2752          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2753          			(p_bma2x2->dev_addr,
   2754          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR_REG,
   2755          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2756          			data_u8 = BMA2x2_SET_BITSLICE
   2757          			(data_u8,
   2758          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR,
   2759          			slow_no_motion_u8);
   2760          			com_rslt += bma2x2_write_reg(
   2761          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR_REG,
   2762          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2763          		break;
   2764          		case BMA2x2_SLOW_NO_MOTION_ENABLE_Z:
   2765          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2766          			(p_bma2x2->dev_addr,
   2767          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR_REG,
   2768          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2769          			data_u8 = BMA2x2_SET_BITSLICE
   2770          			(data_u8,
   2771          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR,
   2772          			slow_no_motion_u8);
   2773          			com_rslt += bma2x2_write_reg(
   2774          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR_REG,
   2775          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2776          		break;
   2777          		case BMA2x2_SLOW_NO_MOTION_ENABLE_SELECT:
   2778          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2779          			(p_bma2x2->dev_addr,
   2780          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR_REG,
   2781          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2782          			data_u8 = BMA2x2_SET_BITSLICE
   2783          			(data_u8,
   2784          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR,
   2785          			slow_no_motion_u8);
   2786          			com_rslt += bma2x2_write_reg(
   2787          			BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR_REG,
   2788          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2789          		break;
   2790          		default:
   2791          			com_rslt = E_OUT_OF_RANGE;
   2792          		break;
   2793          		}
   2794          	}
   2795          	return com_rslt;
   2796          }
   2797          /*!
   2798           * @brief  This API is used to get
   2799           * the interrupt enable of low_g interrupt in the register 0x19 and 0x1B
   2800           * @note INTR1_Low_g -> register 0x19 bit 0
   2801           * @note INTR2_Low_g -> register 0x1B bit 0
   2802           *
   2803           *
   2804           *
   2805           *
   2806           * @param channel_u8 : The value of low interrupt selection channel
   2807           *        channel_u8     |   result
   2808           *       ----------------- | ------------------
   2809           *              0          | BMA2x2_ACCEL_INTR1_LOW_G
   2810           *              1          | BMA2x2_ACCEL_INTR2_LOW_G
   2811           *
   2812           * @param intr_low_g_u8 : the value of low_g interrupt
   2813           *        intr_low_u8           |   result
   2814           *       ------------------------ | ------------------
   2815           *              0x00              | INTR_DISABLE
   2816           *              0x01              | INTR_ENABLE
   2817           *
   2818           *
   2819           *
   2820           *	@return results of bus communication function
   2821           *	@retval 0 -> Success
   2822           *	@retval -1 -> Error
   2823           *
   2824           *
   2825           */
   2826          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_low_g(u8 channel_u8,
   2827          u8 *intr_low_g_u8)
   2828          {
   2829          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2830          	/*  Variable used to return value of
   2831          	communication routine*/
   2832          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2833          
   2834          	if (p_bma2x2 == BMA2x2_NULL) {
   2835          		/* Check the struct p_bma2x2 is empty */
   2836          		return E_BMA2x2_NULL_PTR;
   2837          		} else {
   2838          		switch (channel_u8) {
   2839          		/* Read the low_g interrupt*/
   2840          		case BMA2x2_INTR1_LOW_G:
   2841          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2842          			(p_bma2x2->dev_addr,
   2843          			BMA2x2_ENABLE_INTR1_PAD_LOW_G_REG,
   2844          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2845          			*intr_low_g_u8 = BMA2x2_GET_BITSLICE
   2846          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_LOW_G);
   2847          		break;
   2848          		case BMA2x2_INTR2_LOW_G:
   2849          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2850          			(p_bma2x2->dev_addr,
   2851          			BMA2x2_ENABLE_INTR2_PAD_LOW_G_REG,
   2852          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2853          			*intr_low_g_u8 = BMA2x2_GET_BITSLICE
   2854          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_LOW_G);
   2855          		break;
   2856          		default:
   2857          			com_rslt = E_OUT_OF_RANGE;
   2858          		break;
   2859          		}
   2860          	}
   2861          	return com_rslt;
   2862          }
   2863          /*!
   2864           * @brief  This API is used to set
   2865           * the interrupt enable of low_g interrupt in the register 0x19 and 0x1B
   2866           * @note INTR1_Low_g -> register 0x19 bit 0
   2867           * @note INTR2_Low_g -> register 0x1B bit 0
   2868           *
   2869           *
   2870           *
   2871           *
   2872           * @param channel_u8 : The value of low interrupt selection channel
   2873           *        channel_u8     |   result
   2874           *       ----------------- | ------------------
   2875           *              0          | BMA2x2_ACCEL_INTR1_LOW_G
   2876           *              1          | BMA2x2_ACCEL_INTR2_LOW_G
   2877           *
   2878           * @param intr_low_u8 : the value of low_g interrupt
   2879           *        intr_low_u8           |   result
   2880           *       ------------------------ | ------------------
   2881           *              0x00              | INTR_DISABLE
   2882           *              0x01              | INTR_ENABLE
   2883           *
   2884           *
   2885           *
   2886           *	@return results of bus communication function
   2887           *	@retval 0 -> Success
   2888           *	@retval -1 -> Error
   2889           *
   2890           *
   2891           */
   2892          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_low_g(u8 channel_u8,
   2893          u8 intr_low_u8)
   2894          {
   2895          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2896          		/*  Variable used to return value of
   2897          	communication routine*/
   2898          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2899          
   2900          	if (p_bma2x2 == BMA2x2_NULL) {
   2901          		/* Check the struct p_bma2x2 is empty */
   2902          		return E_BMA2x2_NULL_PTR;
   2903          		} else {
   2904          		switch (channel_u8) {
   2905          		case BMA2x2_INTR1_LOW_G:
   2906          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2907          			(p_bma2x2->dev_addr,
   2908          			BMA2x2_ENABLE_INTR1_PAD_LOW_G_REG,
   2909          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2910          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2911          			BMA2x2_ENABLE_INTR1_PAD_LOW_G, intr_low_u8);
   2912          			com_rslt += bma2x2_write_reg(
   2913          			BMA2x2_ENABLE_INTR1_PAD_LOW_G_REG,
   2914          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2915          		break;
   2916          		case BMA2x2_INTR2_LOW_G:
   2917          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2918          			(p_bma2x2->dev_addr,
   2919          			BMA2x2_ENABLE_INTR2_PAD_LOW_G_REG,
   2920          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2921          			data_u8 = BMA2x2_SET_BITSLICE
   2922          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_LOW_G,
   2923          			intr_low_u8);
   2924          			com_rslt += bma2x2_write_reg(
   2925          			BMA2x2_ENABLE_INTR2_PAD_LOW_G_REG,
   2926          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2927          		break;
   2928          		default:
   2929          			com_rslt = E_OUT_OF_RANGE;
   2930          		break;
   2931          		}
   2932          	}
   2933          	return com_rslt;
   2934          }
   2935          /*!
   2936           * @brief This API is used to get
   2937           * the interrupt enable of high_g interrupt in the register 0x19 and 0x1B
   2938           * @note INTR1_high_g -> register 0x19 bit 1
   2939           * @note INTR2_high_g -> register 0x1B bit 1
   2940           *
   2941           *
   2942           *  @param  channel_u8: The value of high_g interrupt selection
   2943           *        channel_u8     |   result
   2944           *       ----------------- | ------------------
   2945           *              0          | BMA2x2_ACCEL_INTR1_HIGH_G
   2946           *              1          | BMA2x2_ACCEL_INTR2_HIGH_G
   2947           *
   2948           * @param intr_high_g_u8 : the value of high_g interrupt
   2949           *        intr_high_g_u8        |   result
   2950           *       ------------------------ | ------------------
   2951           *              0x00              | INTR_DISABLE
   2952           *              0x01              | INTR_ENABLE
   2953           *
   2954           *
   2955           *	@return results of bus communication function
   2956           *	@retval 0 -> Success
   2957           *	@retval -1 -> Error
   2958           *
   2959           *
   2960           */
   2961          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_high_g(u8 channel_u8,
   2962          u8 *intr_high_g_u8)
   2963          {
   2964          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2965          	/*  Variable used to return value of
   2966          	communication routine*/
   2967          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2968          
   2969          	if (p_bma2x2 == BMA2x2_NULL) {
   2970          		/* Check the struct p_bma2x2 is empty */
   2971          		return E_BMA2x2_NULL_PTR;
   2972          		} else {
   2973          		switch (channel_u8) {
   2974          		/* read the high_g interrupt*/
   2975          		case BMA2x2_INTR1_HIGH_G:
   2976          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2977          			(p_bma2x2->dev_addr,
   2978          			BMA2x2_ENABLE_INTR1_PAD_HIGH_G_REG,
   2979          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2980          			*intr_high_g_u8 = BMA2x2_GET_BITSLICE
   2981          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_HIGH_G);
   2982          		break;
   2983          		case BMA2x2_INTR2_HIGH_G:
   2984          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2985          			(p_bma2x2->dev_addr,
   2986          			BMA2x2_ENABLE_INTR2_PAD_HIGH_G_REG,
   2987          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2988          			*intr_high_g_u8 = BMA2x2_GET_BITSLICE
   2989          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_HIGH_G);
   2990          		break;
   2991          		default:
   2992          		com_rslt = E_OUT_OF_RANGE;
   2993          		break;
   2994          		}
   2995          	}
   2996          	return com_rslt;
   2997          }
   2998          /*!
   2999           * @brief This API is used to set
   3000           * the interrupt enable of high_g interrupt in the register 0x19 and 0x1B
   3001           * @note INTR1_high_g -> register 0x19 bit 1
   3002           * @note INTR2_high_g -> register 0x1B bit 1
   3003           *
   3004           *
   3005           *  @param  channel_u8: The value of high_g interrupt selection
   3006           *        channel_u8     |   result
   3007           *       ----------------- | ------------------
   3008           *              0          | BMA2x2_ACCEL_INTR1_HIGH_G
   3009           *              1          | BMA2x2_ACCEL_INTR2_HIGH_G
   3010           *
   3011           * @param intr_high_g_u8 : the value of high_g interrupt
   3012           *        intr_high_g_u8        |   result
   3013           *       ------------------------ | ------------------
   3014           *              0x00              | INTR_DISABLE
   3015           *              0x01              | INTR_ENABLE
   3016           *
   3017           *
   3018           *	@return results of bus communication function
   3019           *	@retval 0 -> Success
   3020           *	@retval -1 -> Error
   3021           *
   3022           *
   3023           */
   3024          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_high_g(u8 channel_u8,
   3025          u8 intr_high_g_u8)
   3026          {
   3027          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3028          	/*  Variable used to return value of
   3029          	communication routine*/
   3030          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3031          
   3032          	if (p_bma2x2 == BMA2x2_NULL) {
   3033          		/* Check the struct p_bma2x2 is empty */
   3034          		return E_BMA2x2_NULL_PTR;
   3035          		} else {
   3036          		/* write the high_g interrupt*/
   3037          		switch (channel_u8) {
   3038          		case BMA2x2_INTR1_HIGH_G:
   3039          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3040          			(p_bma2x2->dev_addr,
   3041          			BMA2x2_ENABLE_INTR1_PAD_HIGH_G_REG,
   3042          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3043          			data_u8 = BMA2x2_SET_BITSLICE
   3044          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_HIGH_G,
   3045          			intr_high_g_u8);
   3046          			com_rslt += bma2x2_write_reg(
   3047          			BMA2x2_ENABLE_INTR1_PAD_HIGH_G_REG,
   3048          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3049          		break;
   3050          		case BMA2x2_INTR2_HIGH_G:
   3051          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3052          			(p_bma2x2->dev_addr,
   3053          			BMA2x2_ENABLE_INTR2_PAD_HIGH_G_REG,
   3054          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3055          			data_u8 = BMA2x2_SET_BITSLICE
   3056          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_HIGH_G,
   3057          			intr_high_g_u8);
   3058          			com_rslt += bma2x2_write_reg(
   3059          			BMA2x2_ENABLE_INTR2_PAD_HIGH_G_REG,
   3060          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3061          		break;
   3062          		default:
   3063          		com_rslt = E_OUT_OF_RANGE;
   3064          		break;
   3065          		}
   3066          	}
   3067          	return com_rslt;
   3068          }
   3069          /*!
   3070           * @brief This API is used to get
   3071           * the interrupt enable of slope interrupt in the register 0x19 and 0x1B
   3072           * @note INTR1_slope -> register 0x19 bit 2
   3073           * @note INTR2_slope -> register 0x1B bit 2
   3074           *
   3075           *
   3076           *
   3077           * @param channel_u8: the value of slope channel select
   3078           *        channel_u8     |   result
   3079           *       ----------------- | ------------------
   3080           *              0          | BMA2x2_ACCEL_INTR1_SLOPE
   3081           *              1          | BMA2x2_ACCEL_INTR2_SLOPE
   3082           *
   3083           * @param intr_slope_u8 : The slope value enable value
   3084           *        intr_slope_u8         |   result
   3085           *       ------------------------ | ------------------
   3086           *              0x00              | INTR_DISABLE
   3087           *              0x01              | INTR_ENABLE
   3088           *
   3089           *
   3090           *
   3091           *	@return results of bus communication function
   3092           *	@retval 0 -> Success
   3093           *	@retval -1 -> Error
   3094           *
   3095           *
   3096           */
   3097          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_slope(u8 channel_u8,
   3098          u8 *intr_slope_u8)
   3099          {
   3100          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3101          		/*  Variable used to return value of
   3102          	communication routine*/
   3103          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3104          
   3105          	if (p_bma2x2 == BMA2x2_NULL) {
   3106          		/* Check the struct p_bma2x2 is empty */
   3107          		return E_BMA2x2_NULL_PTR;
   3108          		} else {
   3109          		/* Read the slope value */
   3110          		switch (channel_u8) {
   3111          		case BMA2x2_INTR1_SLOPE:
   3112          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3113          			(p_bma2x2->dev_addr,
   3114          			BMA2x2_ENABLE_INTR1_PAD_SLOPE_REG,
   3115          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3116          			*intr_slope_u8 = BMA2x2_GET_BITSLICE
   3117          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_SLOPE);
   3118          		break;
   3119          		case BMA2x2_INTR2_SLOPE:
   3120          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3121          			(p_bma2x2->dev_addr,
   3122          			BMA2x2_ENABLE_INTR2_PAD_SLOPE_REG,
   3123          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3124          			*intr_slope_u8 = BMA2x2_GET_BITSLICE
   3125          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_SLOPE);
   3126          		break;
   3127          		default:
   3128          		com_rslt = E_OUT_OF_RANGE;
   3129          		break;
   3130          		}
   3131          	}
   3132          	return com_rslt;
   3133          }
   3134          /*!
   3135           * @brief This API is used to set
   3136           * the interrupt enable of slope interrupt in the register 0x19 and 0x1B
   3137           * @note INTR1_slope -> register 0x19 bit 2
   3138           * @note INTR2_slope -> register 0x1B bit 2
   3139           *
   3140           *
   3141           *
   3142           * @param channel_u8: the value of slope channel select
   3143           *        channel_u8     |   result
   3144           *       ----------------- | ------------------
   3145           *              0          | BMA2x2_ACCEL_INTR1_SLOPE
   3146           *              1          | BMA2x2_ACCEL_INTR2_SLOPE
   3147           *
   3148           * @param intr_slope_u8 : The slope value enable value
   3149           *        intr_slope_u8         |   result
   3150           *       ------------------------ | ------------------
   3151           *              0x00              | INTR_DISABLE
   3152           *              0x01              | INTR_ENABLE
   3153           *
   3154           *
   3155           *
   3156           *	@return results of bus communication function
   3157           *	@retval 0 -> Success
   3158           *	@retval -1 -> Error
   3159           *
   3160           *
   3161           */
   3162          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_slope(u8 channel_u8,
   3163          u8 intr_slope_u8)
   3164          {
   3165          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3166          		/*  Variable used to return value of
   3167          	communication routine*/
   3168          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3169          
   3170          	if (p_bma2x2 == BMA2x2_NULL) {
   3171          		/* Check the struct p_bma2x2 is empty */
   3172          		return E_BMA2x2_NULL_PTR;
   3173          		} else {
   3174          		switch (channel_u8) {
   3175          		/* Write the slope value */
   3176          		case BMA2x2_INTR1_SLOPE:
   3177          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3178          			(p_bma2x2->dev_addr,
   3179          			BMA2x2_ENABLE_INTR1_PAD_SLOPE_REG,
   3180          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3181          			data_u8 = BMA2x2_SET_BITSLICE
   3182          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_SLOPE,
   3183          			intr_slope_u8);
   3184          			com_rslt += bma2x2_write_reg(
   3185          			BMA2x2_ENABLE_INTR1_PAD_SLOPE_REG,
   3186          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3187          		break;
   3188          		case BMA2x2_INTR2_SLOPE:
   3189          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3190          			(p_bma2x2->dev_addr,
   3191          			BMA2x2_ENABLE_INTR2_PAD_SLOPE_REG,
   3192          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3193          			data_u8 = BMA2x2_SET_BITSLICE
   3194          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_SLOPE,
   3195          			intr_slope_u8);
   3196          			com_rslt += bma2x2_write_reg(
   3197          			BMA2x2_ENABLE_INTR2_PAD_SLOPE_REG,
   3198          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3199          		break;
   3200          		default:
   3201          			com_rslt = E_OUT_OF_RANGE;
   3202          		break;
   3203          		}
   3204          	}
   3205          	return com_rslt;
   3206          }
   3207          /*!
   3208           * @brief This API is used to get
   3209           * the interrupt enable of slow/no motion interrupt in
   3210           * the register 0x19 and 0x1B
   3211           * @note INTR1_slow_no_motion -> register 0x19 bit 3
   3212           * @note INTR2_slow_no_motion -> register 0x1B bit 3
   3213           *
   3214           *
   3215           *
   3216           *
   3217           *  @param channel_u8 : The value of slow/no motion selection
   3218           *        channel_u8     |   result
   3219           *       ----------------- | ------------------
   3220           *              0          | BMA2x2_INTR1_SLOW_NO_MOTION
   3221           *              1          | BMA2x2_INTR2_SLOW_NO_MOTION
   3222           *
   3223           *  @param intr_slow_no_motion_u8:  the slow_no_motion enable value
   3224           *       intr_slow_no_motion_u8 |   result
   3225           *       ------------------------ | ------------------
   3226           *              0x00              | INTR_DISABLE
   3227           *              0x01              | INTR_ENABLE
   3228           *
   3229           *
   3230           *	@return results of bus communication function
   3231           *	@retval 0 -> Success
   3232           *	@retval -1 -> Error
   3233           *
   3234           *
   3235           */
   3236          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_slow_no_motion(u8 channel_u8,
   3237          u8 *intr_slow_no_motion_u8)
   3238          {
   3239          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3240          		/*  Variable used to return value of
   3241          	communication routine*/
   3242          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3243          
   3244          	if (p_bma2x2 == BMA2x2_NULL) {
   3245          		/* Check the struct p_bma2x2 is empty */
   3246          		return E_BMA2x2_NULL_PTR;
   3247          		} else {
   3248          		/* Read the slow no motion interrupt */
   3249          		switch (channel_u8) {
   3250          		case BMA2x2_INTR1_SLOW_NO_MOTION:
   3251          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3252          			(p_bma2x2->dev_addr,
   3253          			BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION_REG,
   3254          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3255          			*intr_slow_no_motion_u8 = BMA2x2_GET_BITSLICE
   3256          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION);
   3257          		break;
   3258          		case BMA2x2_INTR2_SLOW_NO_MOTION:
   3259          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3260          			(p_bma2x2->dev_addr,
   3261          			BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION_REG,
   3262          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3263          			*intr_slow_no_motion_u8 = BMA2x2_GET_BITSLICE
   3264          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION);
   3265          		break;
   3266          		default:
   3267          			com_rslt = E_OUT_OF_RANGE;
   3268          		break;
   3269          		}
   3270          	}
   3271          	return com_rslt;
   3272          }
   3273          /*!
   3274           * @brief This API is used to set
   3275           * the interrupt enable of slow/no motion interrupt in
   3276           * the register 0x19 and 0x1B
   3277           * @note INTR1_slow_no_motion -> register 0x19 bit 3
   3278           * @note INTR2_slow_no_motion -> register 0x1B bit 3
   3279           *
   3280           *
   3281           *
   3282           *
   3283           *  @param channel_u8 : The value of slow/no motion selection
   3284           *        channel_u8     |   result
   3285           *       ----------------- | ------------------
   3286           *              0          | BMA2x2_INTR1_SLOW_NO_MOTION
   3287           *              1          | BMA2x2_INTR2_SLOW_NO_MOTION
   3288           *
   3289           *  @param intr_slow_no_motion_u8:  the slow_no_motion enable value
   3290           *       intr_slow_no_motion_u8 |   result
   3291           *       ------------------------ | ------------------
   3292           *              0x00              | INTR_DISABLE
   3293           *              0x01              | INTR_ENABLE
   3294           *
   3295           *
   3296           *	@return results of bus communication function
   3297           *	@retval 0 -> Success
   3298           *	@retval -1 -> Error
   3299           *
   3300           *
   3301           */
   3302          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_slow_no_motion(u8 channel_u8,
   3303          u8 intr_slow_no_motion_u8)
   3304          {
   3305          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3306          	/*  Variable used to return value of
   3307          	communication routine*/
   3308          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3309          
   3310          	if (p_bma2x2 == BMA2x2_NULL) {
   3311          		/* Check the struct p_bma2x2 is empty */
   3312          		return E_BMA2x2_NULL_PTR;
   3313          		} else {
   3314          		switch (channel_u8) {
   3315          		/* Write the slow no motion interrupt */
   3316          		case BMA2x2_INTR1_SLOW_NO_MOTION:
   3317          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3318          			(p_bma2x2->dev_addr,
   3319          			BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION_REG,
   3320          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3321          			data_u8 = BMA2x2_SET_BITSLICE
   3322          			(data_u8,
   3323          			BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION,
   3324          			intr_slow_no_motion_u8);
   3325          			com_rslt += bma2x2_write_reg(
   3326          			BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION_REG,
   3327          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3328          		break;
   3329          		case BMA2x2_INTR2_SLOW_NO_MOTION:
   3330          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3331          			(p_bma2x2->dev_addr,
   3332          			BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION_REG,
   3333          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3334          			data_u8 = BMA2x2_SET_BITSLICE
   3335          			(data_u8,
   3336          			BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION,
   3337          			intr_slow_no_motion_u8);
   3338          			com_rslt += bma2x2_write_reg(
   3339          			BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION_REG,
   3340          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3341          		break;
   3342          		default:
   3343          			com_rslt = E_OUT_OF_RANGE;
   3344          		break;
   3345          		}
   3346          	}
   3347          	return com_rslt;
   3348          }
   3349          /*!
   3350           * @brief This API is used to get
   3351           * the interrupt enable of double tap interrupt
   3352           * in the register 0x19 and 0x1B
   3353           * @note INTR1_double -> register 0x19 bit 4
   3354           * @note INTR2_double -> register 0x1B bit 4
   3355           *
   3356           *
   3357           *
   3358           *
   3359           *  @param channel_u8: The value of double tap selection
   3360           *        channel_u8     |   result
   3361           *       ----------------- | ------------------
   3362           *              0          | BMA2x2_ACCEL_INTR1_DOUBLE_TAP
   3363           *              1          | BMA2x2_ACCEL_INTR2_DOUBLE_TAP
   3364           *
   3365           *	@param intr_double_tap_u8: The double tap interrupt enable value
   3366           *       intr_double_tap_u8     |   result
   3367           *       ------------------------ | ------------------
   3368           *              0x00              | INTR_DISABLE
   3369           *              0x01              | INTR_ENABLE
   3370           *
   3371           *	@return results of bus communication function
   3372           *	@retval 0 -> Success
   3373           *	@retval -1 -> Error
   3374           *
   3375           *
   3376           */
   3377          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_double_tap(u8 channel_u8,
   3378          u8 *intr_double_tap_u8)
   3379          {
   3380          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3381          		/*  Variable used to return value of
   3382          	communication routine*/
   3383          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3384          
   3385          	if (p_bma2x2 == BMA2x2_NULL) {
   3386          		/* Check the struct p_bma2x2 is empty */
   3387          		return E_BMA2x2_NULL_PTR;
   3388          		} else {
   3389          		/* read the double tap*/
   3390          		switch (channel_u8) {
   3391          		case BMA2x2_INTR1_DOUBLE_TAP:
   3392          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3393          			(p_bma2x2->dev_addr,
   3394          			BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP_REG,
   3395          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3396          			*intr_double_tap_u8 = BMA2x2_GET_BITSLICE
   3397          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP);
   3398          		break;
   3399          		case BMA2x2_INTR2_DOUBLE_TAP:
   3400          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3401          			(p_bma2x2->dev_addr,
   3402          			BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP_REG,
   3403          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3404          			*intr_double_tap_u8 = BMA2x2_GET_BITSLICE
   3405          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP);
   3406          		break;
   3407          		default:
   3408          			com_rslt = E_OUT_OF_RANGE;
   3409          		break;
   3410          		}
   3411          	}
   3412          	return com_rslt;
   3413          }
   3414          /*!
   3415           * @brief This API is used to set
   3416           * the interrupt enable of double tap interrupt
   3417           * in the register 0x19 and 0x1B
   3418           * @note INTR1_double -> register 0x19 bit 4
   3419           * @note INTR2_double -> register 0x1B bit 4
   3420           *
   3421           *
   3422           *
   3423           *
   3424           *  @param channel_u8: The value of double tap selection
   3425           *        channel_u8     |   result
   3426           *       ----------------- | ------------------
   3427           *              0          | BMA2x2_ACCEL_INTR1_DOUBLE_TAP
   3428           *              1          | BMA2x2_ACCEL_INTR2_DOUBLE_TAP
   3429           *
   3430           *	@param intr_double_tap_u8: The double tap interrupt enable value
   3431           *       intr_double_tap_u8     |   result
   3432           *       ------------------------ | ------------------
   3433           *              0x00              | INTR_DISABLE
   3434           *              0x01              | INTR_ENABLE
   3435           *
   3436           *	@return results of bus communication function
   3437           *	@retval 0 -> Success
   3438           *	@retval -1 -> Error
   3439           *
   3440           *
   3441           */
   3442          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_double_tap(u8 channel_u8,
   3443          u8 intr_double_tap_u8)
   3444          {
   3445          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3446          		/*  Variable used to return value of
   3447          	communication routine*/
   3448          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3449          
   3450          	if (p_bma2x2 == BMA2x2_NULL) {
   3451          		/* Check the struct p_bma2x2 is empty */
   3452          		return E_BMA2x2_NULL_PTR;
   3453          		} else {
   3454          		switch (channel_u8) {
   3455          		/* write the double tap*/
   3456          		case BMA2x2_INTR1_DOUBLE_TAP:
   3457          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3458          			(p_bma2x2->dev_addr,
   3459          			BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP_REG,
   3460          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3461          			data_u8 = BMA2x2_SET_BITSLICE
   3462          			(data_u8,
   3463          			BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP,
   3464          			intr_double_tap_u8);
   3465          			com_rslt += bma2x2_write_reg(
   3466          			BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP_REG,
   3467          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3468          		break;
   3469          		case BMA2x2_INTR2_DOUBLE_TAP:
   3470          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3471          			(p_bma2x2->dev_addr,
   3472          			BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP_REG,
   3473          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3474          			data_u8 = BMA2x2_SET_BITSLICE
   3475          			(data_u8,
   3476          			BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP,
   3477          			intr_double_tap_u8);
   3478          			com_rslt += bma2x2_write_reg(
   3479          			BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP_REG,
   3480          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3481          		break;
   3482          		default:
   3483          		com_rslt = E_OUT_OF_RANGE;
   3484          		break;
   3485          		}
   3486          	}
   3487          	return com_rslt;
   3488          }
   3489          /*!
   3490           * @brief This API is used to get
   3491           * the interrupt enable of single tap
   3492           * interrupt in the register 0x19 and 0x1B
   3493           * @note INTR1_single_tap -> register 0x19 bit 5
   3494           * @note INTR2_single_tap -> register 0x1B bit 5
   3495           *
   3496           *
   3497           *  @param channel_u8: The value of single tap interrupt select
   3498           *        channel_u8     |   result
   3499           *       ----------------- | ------------------
   3500           *              0          | BMA2x2_ACCEL_INTR1_SINGLE_TAP
   3501           *              1          | BMA2x2_ACCEL_INTR2_SINGLE_TAP
   3502           *
   3503           *  @param intr_single_tap_u8: The single tap interrupt enable value
   3504           *       intr_single_tap_u8     |   result
   3505           *       ------------------------ | ------------------
   3506           *              0x00              | INTR_DISABLE
   3507           *              0x01              | INTR_ENABLE
   3508           *
   3509           *
   3510           *	@return results of bus communication function
   3511           *	@retval 0 -> Success
   3512           *	@retval -1 -> Error
   3513           *
   3514           *
   3515           */
   3516          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_single_tap(u8 channel_u8,
   3517          u8 *intr_single_tap_u8)
   3518          {
   3519          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3520          		/*  Variable used to return value of
   3521          	communication routine*/
   3522          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3523          
   3524          	if (p_bma2x2 == BMA2x2_NULL) {
   3525          		/* Check the struct p_bma2x2 is empty */
   3526          		return E_BMA2x2_NULL_PTR;
   3527          		} else {
   3528          		switch (channel_u8) {
   3529          		/* Read the single tap value*/
   3530          		case BMA2x2_INTR1_SINGLE_TAP:
   3531          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3532          			(p_bma2x2->dev_addr,
   3533          			BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP_REG,
   3534          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3535          			*intr_single_tap_u8 = BMA2x2_GET_BITSLICE
   3536          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP);
   3537          		break;
   3538          		case BMA2x2_INTR2_SINGLE_TAP:
   3539          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3540          			(p_bma2x2->dev_addr,
   3541          			BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP_REG,
   3542          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3543          			*intr_single_tap_u8 = BMA2x2_GET_BITSLICE
   3544          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP);
   3545          		break;
   3546          		default:
   3547          			com_rslt = E_OUT_OF_RANGE;
   3548          		break;
   3549          		}
   3550          	}
   3551          	return com_rslt;
   3552          }
   3553          /*!
   3554           * @brief This API is used to set
   3555           * the interrupt enable of single tap
   3556           * interrupt in the register 0x19 and 0x1B
   3557           * @note INTR1_single_tap -> register 0x19 bit 5
   3558           * @note INTR2_single_tap -> register 0x1B bit 5
   3559           *
   3560           *
   3561           *  @param channel_u8: The value of single tap interrupt select
   3562           *        channel_u8     |   result
   3563           *       ----------------- | ------------------
   3564           *              0          | BMA2x2_ACCEL_INTR1_SINGLE_TAP
   3565           *              1          | BMA2x2_ACCEL_INTR2_SINGLE_TAP
   3566           *
   3567           *  @param intr_single_tap_u8: The single tap interrupt enable value
   3568           *       intr_single_tap_u8     |   result
   3569           *       ------------------------ | ------------------
   3570           *              0x00              | INTR_DISABLE
   3571           *              0x01              | INTR_ENABLE
   3572           *
   3573           *
   3574           *	@return results of bus communication function
   3575           *	@retval 0 -> Success
   3576           *	@retval -1 -> Error
   3577           *
   3578           *
   3579           */
   3580          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_single_tap(u8 channel_u8,
   3581          u8 intr_single_tap_u8)
   3582          {
   3583          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3584          		/*  Variable used to return value of
   3585          	communication routine*/
   3586          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3587          
   3588          	if (p_bma2x2 == BMA2x2_NULL) {
   3589          		/* Check the struct p_bma2x2 is empty */
   3590          		return E_BMA2x2_NULL_PTR;
   3591          		} else {
   3592          		switch (channel_u8) {
   3593          		/* write the single tap value*/
   3594          		case BMA2x2_INTR1_SINGLE_TAP:
   3595          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3596          			(p_bma2x2->dev_addr,
   3597          			BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP_REG,
   3598          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3599          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   3600          			BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP,
   3601          			intr_single_tap_u8);
   3602          			com_rslt += bma2x2_write_reg(
   3603          			BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP_REG,
   3604          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3605          		break;
   3606          		case BMA2x2_INTR2_SINGLE_TAP:
   3607          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3608          			(p_bma2x2->dev_addr,
   3609          			BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP_REG,
   3610          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3611          			data_u8 = BMA2x2_SET_BITSLICE
   3612          			(data_u8,
   3613          			BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP,
   3614          			intr_single_tap_u8);
   3615          			com_rslt += bma2x2_write_reg(
   3616          			BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP_REG,
   3617          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3618          		break;
   3619          		default:
   3620          			com_rslt = E_OUT_OF_RANGE;
   3621          		break;
   3622          		}
   3623          	}
   3624          	return com_rslt;
   3625          }
   3626          /*!
   3627           * @brief This API is used to get
   3628           * the interrupt status of orient interrupt in the register 0x19 and 0x1B
   3629           * @note INTR1_orient -> register 0x19 bit 6
   3630           * @note INTR2_orient -> register 0x1B bit 6
   3631           *
   3632           *
   3633           * @param channel_u8: The value of orient interrupt select
   3634           *        channel_u8     |   result
   3635           *       ----------------- | ------------------
   3636           *              0          | BMA2x2_ACCEL_INTR1_ORIENT
   3637           *              1          | BMA2x2_ACCEL_INTR2_ORIENT
   3638           *
   3639           *  @param intr_orient_u8: The value of orient interrupt enable
   3640           *       intr_orient_u8         |   result
   3641           *       ------------------------ | ------------------
   3642           *              0x00              | INTR_DISABLE
   3643           *              0x01              | INTR_ENABLE
   3644           *
   3645           *
   3646           *	@return results of bus communication function
   3647           *	@retval 0 -> Success
   3648           *	@retval -1 -> Error
   3649           *
   3650           *
   3651          */
   3652          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_orient(u8 channel_u8,
   3653          u8 *intr_orient_u8)
   3654          {
   3655          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3656          		/*  Variable used to return value of
   3657          	communication routine*/
   3658          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3659          
   3660          	if (p_bma2x2 == BMA2x2_NULL) {
   3661          		/* Check the struct p_bma2x2 is empty */
   3662          		return E_BMA2x2_NULL_PTR;
   3663          		} else {
   3664          		switch (channel_u8) {
   3665          		/* Read orient interrupt*/
   3666          		case BMA2x2_INTR1_ORIENT:
   3667          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3668          			(p_bma2x2->dev_addr,
   3669          			BMA2x2_ENABLE_INTR1_PAD_ORIENT_REG,
   3670          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3671          			*intr_orient_u8 = BMA2x2_GET_BITSLICE
   3672          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_ORIENT);
   3673          		break;
   3674          		case BMA2x2_INTR2_ORIENT:
   3675          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3676          			(p_bma2x2->dev_addr,
   3677          			BMA2x2_ENABLE_INTR2_PAD_ORIENT_REG,
   3678          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3679          			*intr_orient_u8 = BMA2x2_GET_BITSLICE
   3680          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_ORIENT);
   3681          		break;
   3682          		default:
   3683          			com_rslt = E_OUT_OF_RANGE;
   3684          		break;
   3685          		}
   3686          	}
   3687          	return com_rslt;
   3688          }
   3689          /*!
   3690           * @brief This API is used to set
   3691           * the interrupt status of orient interrupt in the register 0x19 and 0x1B
   3692           * @note INTR1_orient -> register 0x19 bit 6
   3693           * @note INTR2_orient -> register 0x1B bit 6
   3694           *
   3695           *
   3696           * @param channel_u8: The value of orient interrupt select
   3697           *        channel_u8     |   result
   3698           *       ----------------- | ------------------
   3699           *              0          | BMA2x2_ACCEL_INTR1_ORIENT
   3700           *              1          | BMA2x2_ACCEL_INTR2_ORIENT
   3701           *
   3702           *  @param intr_orient_u8: The value of orient interrupt enable
   3703           *       intr_orient_u8         |   result
   3704           *       ------------------------ | ------------------
   3705           *              0x00              | INTR_DISABLE
   3706           *              0x01              | INTR_ENABLE
   3707           *
   3708           *
   3709           *	@return results of bus communication function
   3710           *	@retval 0 -> Success
   3711           *	@retval -1 -> Error
   3712           *
   3713           *
   3714          */
   3715          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_orient(u8 channel_u8,
   3716          u8 intr_orient_u8)
   3717          {
   3718          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3719          	/*  Variable used to return value of
   3720          	communication routine*/
   3721          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3722          
   3723          	if (p_bma2x2 == BMA2x2_NULL) {
   3724          		/* Check the struct p_bma2x2 is empty */
   3725          		return E_BMA2x2_NULL_PTR;
   3726          		} else {
   3727          		switch (channel_u8) {
   3728          		/* Write orient interrupt */
   3729          		case BMA2x2_INTR1_ORIENT:
   3730          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3731          			(p_bma2x2->dev_addr,
   3732          			BMA2x2_ENABLE_INTR1_PAD_ORIENT_REG,
   3733          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3734          			data_u8 = BMA2x2_SET_BITSLICE
   3735          			(data_u8,
   3736          			BMA2x2_ENABLE_INTR1_PAD_ORIENT, intr_orient_u8);
   3737          			com_rslt += bma2x2_write_reg(
   3738          			BMA2x2_ENABLE_INTR1_PAD_ORIENT_REG,
   3739          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3740          		break;
   3741          		case BMA2x2_INTR2_ORIENT:
   3742          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3743          			(p_bma2x2->dev_addr,
   3744          			BMA2x2_ENABLE_INTR2_PAD_ORIENT_REG,
   3745          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3746          			data_u8 = BMA2x2_SET_BITSLICE
   3747          			(data_u8,
   3748          			BMA2x2_ENABLE_INTR2_PAD_ORIENT, intr_orient_u8);
   3749          			com_rslt += bma2x2_write_reg(
   3750          			BMA2x2_ENABLE_INTR2_PAD_ORIENT_REG,
   3751          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3752          		break;
   3753          		default:
   3754          			com_rslt = E_OUT_OF_RANGE;
   3755          		break;
   3756          		}
   3757          	}
   3758          	return com_rslt;
   3759          }
   3760          /*!
   3761           * @brief This API is used to get
   3762           * the interrupt enable of flat interrupt in the register 0x19 and 0x1B
   3763           * @note INTR1_flat -> register 0x19 bit 7
   3764           * @note INTR2_flat -> register 0x1B bit 7
   3765           *
   3766           *
   3767           *
   3768           *
   3769           * @param channel_u8: The value of flat interrupt select
   3770           *        channel_u8     |   result
   3771           *       ----------------- | ------------------
   3772           *              0          | BMA2x2_ACCEL_INTR1_FLAT
   3773           *              1          | BMA2x2_ACCEL_INTR2_FLAT
   3774           *
   3775           * @param intr_flat_u8: The flat interrupt enable value
   3776           *       intr_flat_u8           |   result
   3777           *       ------------------------ | ------------------
   3778           *              0x00              | INTR_DISABLE
   3779           *              0x01              | INTR_ENABLE
   3780           *
   3781           *
   3782           *	@return results of bus communication function
   3783           *	@retval 0 -> Success
   3784           *	@retval -1 -> Error
   3785           *
   3786           *
   3787          */
   3788          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_flat(u8 channel_u8,
   3789          u8 *intr_flat_u8)
   3790          {
   3791          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3792          		/*  Variable used to return value of
   3793          	communication routine*/
   3794          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3795          
   3796          	if (p_bma2x2 == BMA2x2_NULL) {
   3797          		/* Check the struct p_bma2x2 is empty */
   3798          		return E_BMA2x2_NULL_PTR;
   3799          		} else {
   3800          		switch (channel_u8) {
   3801          		/* Read flat interrupt */
   3802          		case BMA2x2_INTR1_FLAT:
   3803          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3804          			(p_bma2x2->dev_addr,
   3805          			BMA2x2_ENABLE_INTR1_PAD_FLAT_REG,
   3806          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3807          			*intr_flat_u8 = BMA2x2_GET_BITSLICE
   3808          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_FLAT);
   3809          		break;
   3810          		case BMA2x2_INTR2_FLAT:
   3811          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3812          			(p_bma2x2->dev_addr,
   3813          			BMA2x2_ENABLE_INTR2_PAD_FLAT_REG,
   3814          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3815          			*intr_flat_u8 = BMA2x2_GET_BITSLICE
   3816          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_FLAT);
   3817          		break;
   3818          		default:
   3819          			com_rslt = E_OUT_OF_RANGE;
   3820          		break;
   3821          		}
   3822          	}
   3823          	return com_rslt;
   3824          }
   3825          /*!
   3826           * @brief This API is used to set
   3827           * the interrupt enable of flat interrupt in the register 0x19 and 0x1B
   3828           * @note INTR1_flat -> register 0x19 bit 7
   3829           * @note INTR2_flat -> register 0x1B bit 7
   3830           *
   3831           *
   3832           *
   3833           *
   3834           * @param channel_u8: The value of flat interrupt select
   3835           *        channel_u8     |   result
   3836           *       ----------------- | ------------------
   3837           *              0          | BMA2x2_ACCEL_INTR1_FLAT
   3838           *              1          | BMA2x2_ACCEL_INTR2_FLAT
   3839           *
   3840           * @param intr_flat_u8: The flat interrupt enable value
   3841           *       intr_flat_u8           |   result
   3842           *       ------------------------ | ------------------
   3843           *              0x00              | INTR_DISABLE
   3844           *              0x01              | INTR_ENABLE
   3845           *
   3846           *
   3847           *	@return results of bus communication function
   3848           *	@retval 0 -> Success
   3849           *	@retval -1 -> Error
   3850           *
   3851           *
   3852          */
   3853          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_flat(u8 channel_u8,
   3854          u8 intr_flat_u8)
   3855          {
   3856          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3857          	/*  Variable used to return value of
   3858          	communication routine*/
   3859          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3860          
   3861          	if (p_bma2x2 == BMA2x2_NULL) {
   3862          		/* Check the struct p_bma2x2 is empty */
   3863          		return E_BMA2x2_NULL_PTR;
   3864          		} else {
   3865          		switch (channel_u8) {
   3866          		/* write flat interrupt */
   3867          		case BMA2x2_INTR1_FLAT:
   3868          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3869          			(p_bma2x2->dev_addr,
   3870          			BMA2x2_ENABLE_INTR1_PAD_FLAT_REG,
   3871          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3872          			data_u8 = BMA2x2_SET_BITSLICE
   3873          			(data_u8,
   3874          			BMA2x2_ENABLE_INTR1_PAD_FLAT, intr_flat_u8);
   3875          			com_rslt += bma2x2_write_reg(
   3876          			BMA2x2_ENABLE_INTR1_PAD_FLAT_REG,
   3877          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3878          		break;
   3879          		case BMA2x2_INTR2_FLAT:
   3880          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3881          			(p_bma2x2->dev_addr,
   3882          			BMA2x2_ENABLE_INTR2_PAD_FLAT_REG,
   3883          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3884          			data_u8 = BMA2x2_SET_BITSLICE
   3885          			(data_u8,
   3886          			BMA2x2_ENABLE_INTR2_PAD_FLAT, intr_flat_u8);
   3887          			com_rslt += bma2x2_write_reg(
   3888          			BMA2x2_ENABLE_INTR2_PAD_FLAT_REG,
   3889          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3890          		break;
   3891          		default:
   3892          			com_rslt = E_OUT_OF_RANGE;
   3893          		break;
   3894          		}
   3895          	}
   3896          	return com_rslt;
   3897          }
   3898          /*!
   3899           * @brief This API is used to get
   3900           * the interrupt status of new data in the register 0x19
   3901           * @note INTR1_data -> register 0x19 bit 0
   3902           * @note INTR2_data -> register 0x19 bit 7
   3903           *
   3904           *
   3905           *
   3906           *  @param channel_u8: The value of new data interrupt select
   3907           *        channel_u8     |   result
   3908           *       ----------------- | ------------------
   3909           *              0          | BMA2x2_ACCEL_INTR1_NEWDATA
   3910           *              1          | BMA2x2_ACCEL_INTR2_NEWDATA
   3911           *
   3912           *	@param intr_newdata_u8: The new data interrupt enable value
   3913           *       intr_newdata_u8          |    result
   3914           *       ------------------------ | ------------------
   3915           *              0x00              | INTR_DISABLE
   3916           *              0x01              | INTR_ENABLE
   3917           *
   3918           *
   3919           *	@return results of bus communication function
   3920           *	@retval 0 -> Success
   3921           *	@retval -1 -> Error
   3922           *
   3923           *
   3924           */
   3925          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_new_data(u8 channel_u8,
   3926          u8 *intr_newdata_u8)
   3927          {
   3928          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3929          		/*  Variable used to return value of
   3930          	communication routine*/
   3931          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3932          
   3933          	if (p_bma2x2 == BMA2x2_NULL) {
   3934          		/* Check the struct p_bma2x2 is empty */
   3935          		return E_BMA2x2_NULL_PTR;
   3936          		} else {
   3937          		switch (channel_u8) {
   3938          		/* Read the data interrupt*/
   3939          		case BMA2x2_INTR1_NEWDATA:
   3940          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3941          			(p_bma2x2->dev_addr,
   3942          			BMA2x2_ENABLE_INTR1_PAD_NEWDATA_REG,
   3943          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3944          			*intr_newdata_u8 = BMA2x2_GET_BITSLICE
   3945          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_NEWDATA);
   3946          		break;
   3947          		case BMA2x2_INTR2_NEWDATA:
   3948          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3949          			(p_bma2x2->dev_addr,
   3950          			BMA2x2_ENABLE_INTR2_PAD_NEWDATA_REG,
   3951          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3952          			*intr_newdata_u8 = BMA2x2_GET_BITSLICE
   3953          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_NEWDATA);
   3954          		break;
   3955          		default:
   3956          			com_rslt = E_OUT_OF_RANGE;
   3957          		break;
   3958          		}
   3959          	}
   3960          	return com_rslt;
   3961          }
   3962          /*!
   3963           * @brief This API is used to set
   3964           * the interrupt status of new data in the register 0x19
   3965           * @note INTR1_data -> register 0x19 bit 0
   3966           * @note INTR2_data -> register 0x19 bit 7
   3967           *
   3968           *
   3969           *
   3970           *  @param channel_u8: The value of new data interrupt select
   3971           *        channel_u8     |   result
   3972           *       ----------------- | ------------------
   3973           *              0          | BMA2x2_ACCEL_INTR1_NEWDATA
   3974           *              1          | BMA2x2_ACCEL_INTR2_NEWDATA
   3975           *
   3976           *	@param intr_newdata_u8: The new data interrupt enable value
   3977           *       intr_newdata_u8          |    result
   3978           *       ------------------------ | ------------------
   3979           *              0x00              | INTR_DISABLE
   3980           *              0x01              | INTR_ENABLE
   3981           *
   3982           *
   3983           *	@return results of bus communication function
   3984           *	@retval 0 -> Success
   3985           *	@retval -1 -> Error
   3986           *
   3987           *
   3988           */
   3989          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_new_data(u8 channel_u8,
   3990          u8 intr_newdata_u8)
   3991          {
   3992          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3993          	/*  Variable used to return value of
   3994          	communication routine*/
   3995          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3996          
   3997          	if (p_bma2x2 == BMA2x2_NULL) {
   3998          		/* Check the struct p_bma2x2 is empty */
   3999          		return E_BMA2x2_NULL_PTR;
   4000          		} else {
   4001          		switch (channel_u8) {
   4002          		/* write the new data interrupt */
   4003          		case BMA2x2_INTR1_NEWDATA:
   4004          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4005          			(p_bma2x2->dev_addr,
   4006          			BMA2x2_ENABLE_INTR1_PAD_NEWDATA_REG,
   4007          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4008          			data_u8 = BMA2x2_SET_BITSLICE
   4009          			(data_u8,
   4010          			BMA2x2_ENABLE_INTR1_PAD_NEWDATA, intr_newdata_u8);
   4011          			com_rslt += bma2x2_write_reg(
   4012          			BMA2x2_ENABLE_INTR1_PAD_NEWDATA_REG,
   4013          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4014          		break;
   4015          		case BMA2x2_INTR2_NEWDATA:
   4016          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4017          			(p_bma2x2->dev_addr,
   4018          			BMA2x2_ENABLE_INTR2_PAD_NEWDATA_REG,
   4019          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4020          			data_u8 = BMA2x2_SET_BITSLICE
   4021          			(data_u8,
   4022          			BMA2x2_ENABLE_INTR2_PAD_NEWDATA, intr_newdata_u8);
   4023          			com_rslt += bma2x2_write_reg(
   4024          			BMA2x2_ENABLE_INTR2_PAD_NEWDATA_REG,
   4025          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4026          		break;
   4027          		default:
   4028          			com_rslt = E_OUT_OF_RANGE;
   4029          		break;
   4030          		}
   4031          	}
   4032          	return com_rslt;
   4033          }
   4034          /*!
   4035           * @brief This API is used to get the fifo watermark interrupt1 data
   4036           * in the register 0x1A bit 1
   4037           *
   4038           *  @param  intr1_fifo_wm_u8 : The value of interrupt1 FIFO watermark enable
   4039           *       intr1_fifo_wm_u8       |    result
   4040           *       ------------------------ | ------------------
   4041           *              0x00              | INTR_DISABLE
   4042           *              0x01              | INTR_ENABLE
   4043           *
   4044           *
   4045           *
   4046           *	@return results of bus communication function
   4047           *	@retval 0 -> Success
   4048           *	@retval -1 -> Error
   4049           *
   4050           *
   4051          */
   4052          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr1_fifo_wm(u8 *intr1_fifo_wm_u8)
   4053          {
   4054          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4055          		/*  Variable used to return value of
   4056          	communication routine*/
   4057          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4058          
   4059          	if (p_bma2x2 == BMA2x2_NULL) {
   4060          		/* Check the struct p_bma2x2 is empty */
   4061          		return E_BMA2x2_NULL_PTR;
   4062          		} else {
   4063          			/* read the fifo watermark interrupt */
   4064          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4065          			(p_bma2x2->dev_addr,
   4066          			BMA2x2_ENABLE_INTR1_PAD_FIFO_WM_REG,
   4067          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4068          			*intr1_fifo_wm_u8 = BMA2x2_GET_BITSLICE
   4069          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_FIFO_WM);
   4070          		}
   4071          	return com_rslt;
   4072          }
   4073          /*!
   4074           * @brief This API is used to set the fifo watermark interrupt1 data
   4075           * in the register 0x1A bit 1
   4076           *
   4077           *  @param  intr1_fifo_wm_u8 : The value of interrupt1 FIFO watermark enable
   4078           *       intr1_fifo_wm_u8       |    result
   4079           *       ------------------------ | ------------------
   4080           *              0x00              | INTR_DISABLE
   4081           *              0x01              | INTR_ENABLE
   4082           *
   4083           *
   4084           *
   4085           *	@return results of bus communication function
   4086           *	@retval 0 -> Success
   4087           *	@retval -1 -> Error
   4088           *
   4089           *
   4090          */
   4091          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr1_fifo_wm(u8 intr1_fifo_wm_u8)
   4092          {
   4093          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4094          	/*  Variable used to return value of
   4095          	communication routine*/
   4096          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4097          
   4098          	if (p_bma2x2 == BMA2x2_NULL) {
   4099          		/* Check the struct p_bma2x2 is empty */
   4100          		return E_BMA2x2_NULL_PTR;
   4101          		} else {
   4102          		if (intr1_fifo_wm_u8 <
   4103          		BMA2x2_FIFO_MODE_STATUS_RANGE) {
   4104          			/* write the fifo watermark interrupt */
   4105          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4106          			(p_bma2x2->dev_addr,
   4107          			BMA2x2_ENABLE_INTR1_PAD_FIFO_WM_REG,
   4108          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4109          			data_u8 = BMA2x2_SET_BITSLICE
   4110          			(data_u8,
   4111          			BMA2x2_ENABLE_INTR1_PAD_FIFO_WM, intr1_fifo_wm_u8);
   4112          			com_rslt += bma2x2_write_reg(
   4113          			BMA2x2_ENABLE_INTR1_PAD_FIFO_WM_REG,
   4114          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4115          		} else {
   4116          		com_rslt = E_OUT_OF_RANGE;
   4117          		}
   4118          	}
   4119          	return com_rslt;
   4120          }
   4121          /*!
   4122           * @brief This API is used to get the fifo watermark interrupt2 data
   4123           * in the register 0x1A bit 6
   4124           *
   4125           *  @param  intr2_fifo_wm_u8 : The value of interrupt1 FIFO watermark enable
   4126           *       intr2_fifo_wm_u8       |    result
   4127           *       ------------------------ | ------------------
   4128           *              0x00              | INTR_DISABLE
   4129           *              0x01              | INTR_ENABLE
   4130           *
   4131           *
   4132           *
   4133           *	@return results of bus communication function
   4134           *	@retval 0 -> Success
   4135           *	@retval -1 -> Error
   4136           *
   4137           *
   4138           */
   4139          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr2_fifo_wm(u8 *intr2_fifo_wm_u8)
   4140          {
   4141          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4142          		/*  Variable used to return value of
   4143          	communication routine*/
   4144          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4145          
   4146          	if (p_bma2x2 == BMA2x2_NULL) {
   4147          		/* Check the struct p_bma2x2 is empty */
   4148          		return E_BMA2x2_NULL_PTR;
   4149          		} else {
   4150          			/* read the fifo watermark interrupt2*/
   4151          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4152          			(p_bma2x2->dev_addr,
   4153          			BMA2x2_ENABLE_INTR2_PAD_FIFO_WM_REG,
   4154          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4155          			*intr2_fifo_wm_u8 = BMA2x2_GET_BITSLICE
   4156          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_FIFO_WM);
   4157          		}
   4158          	return com_rslt;
   4159          }
   4160          /*!
   4161           * @brief This API is used to set the fifo watermark interrupt2 data
   4162           * in the register 0x1A bit 6
   4163           *
   4164           *  @param  intr2_fifo_wm_u8 : The value of interrupt1 FIFO watermark enable
   4165           *       intr2_fifo_wm_u8       |    result
   4166           *       ------------------------ | ------------------
   4167           *              0x00              | INTR_DISABLE
   4168           *              0x01              | INTR_ENABLE
   4169           *
   4170           *
   4171           *
   4172           *	@return results of bus communication function
   4173           *	@retval 0 -> Success
   4174           *	@retval -1 -> Error
   4175           *
   4176           *
   4177           */
   4178          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr2_fifo_wm(u8 intr2_fifo_wm_u8)
   4179          {
   4180          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4181          	/*  Variable used to return value of
   4182          	communication routine*/
   4183          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4184          
   4185          	if (p_bma2x2 == BMA2x2_NULL) {
   4186          		/* Check the struct p_bma2x2 is empty */
   4187          		return E_BMA2x2_NULL_PTR;
   4188          		} else {
   4189          		if (intr2_fifo_wm_u8 <
   4190          		BMA2x2_FIFO_MODE_STATUS_RANGE) {
   4191          			/* write the fifo watermark interrupt2*/
   4192          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4193          			(p_bma2x2->dev_addr,
   4194          			BMA2x2_ENABLE_INTR2_PAD_FIFO_WM_REG,
   4195          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4196          			data_u8 = BMA2x2_SET_BITSLICE
   4197          			(data_u8,
   4198          			BMA2x2_ENABLE_INTR2_PAD_FIFO_WM, intr2_fifo_wm_u8);
   4199          			com_rslt += bma2x2_write_reg(
   4200          			BMA2x2_ENABLE_INTR2_PAD_FIFO_WM_REG,
   4201          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4202          		} else {
   4203          		com_rslt = E_OUT_OF_RANGE;
   4204          		}
   4205          	}
   4206          	return com_rslt;
   4207          }
   4208          /*!
   4209           *	@brief This API is used to get
   4210           *	the fifo full interrupt1 in the register 0x1A bit 2
   4211           *
   4212           *
   4213           *
   4214           *  @param intr1_fifo_full_u8 : The value of fifo full interrupt enable
   4215           *       intr1_fifo_full_u8     |    result
   4216           *       ------------------------ | ------------------
   4217           *              0x00              | INTR_DISABLE
   4218           *              0x01              | INTR_ENABLE
   4219           *
   4220           *
   4221           *
   4222           *	@return results of bus communication function
   4223           *	@retval 0 -> Success
   4224           *	@retval -1 -> Error
   4225           *
   4226           *
   4227           */
   4228          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr1_fifo_full(u8 *intr1_fifo_full_u8)
   4229          {
   4230          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4231          		/*  Variable used to return value of
   4232          	communication routine*/
   4233          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4234          
   4235          	if (p_bma2x2 == BMA2x2_NULL) {
   4236          		/* Check the struct p_bma2x2 is empty */
   4237          		return E_BMA2x2_NULL_PTR;
   4238          		} else {
   4239          			/* read the fifo full interrupt1*/
   4240          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4241          			(p_bma2x2->dev_addr,
   4242          			BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL_REG,
   4243          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4244          			*intr1_fifo_full_u8 = BMA2x2_GET_BITSLICE
   4245          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL);
   4246          		}
   4247          	return com_rslt;
   4248          }
   4249          /*!
   4250           *	@brief This API is used to set
   4251           *	the fifo full interrupt1 in the register 0x1A bit 2
   4252           *
   4253           *
   4254           *
   4255           *  @param intr1_fifo_full_u8 : The value of fifo full interrupt enable
   4256           *       intr1_fifo_full_u8     |    result
   4257           *       ------------------------ | ------------------
   4258           *              0x00              | INTR_DISABLE
   4259           *              0x01              | INTR_ENABLE
   4260           *
   4261           *
   4262           *
   4263           *	@return results of bus communication function
   4264           *	@retval 0 -> Success
   4265           *	@retval -1 -> Error
   4266           *
   4267           *
   4268           */
   4269          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr1_fifo_full(u8 intr1_fifo_full_u8)
   4270          {
   4271          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4272          		/*  Variable used to return value of
   4273          	communication routine*/
   4274          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4275          
   4276          	if (p_bma2x2 == BMA2x2_NULL) {
   4277          		/* Check the struct p_bma2x2 is empty */
   4278          		return E_BMA2x2_NULL_PTR;
   4279          		} else {
   4280          		if (intr1_fifo_full_u8 <
   4281          		BMA2x2_FIFO_MODE_STATUS_RANGE) {
   4282          			/* write the fifo full interrupt1*/
   4283          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4284          			(p_bma2x2->dev_addr,
   4285          			BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL_REG,
   4286          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4287          			data_u8 = BMA2x2_SET_BITSLICE
   4288          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL,
   4289          			intr1_fifo_full_u8);
   4290          			com_rslt += bma2x2_write_reg(
   4291          			BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL_REG,
   4292          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4293          			} else {
   4294          			com_rslt = E_OUT_OF_RANGE;
   4295          		}
   4296          	}
   4297          	return com_rslt;
   4298          }
   4299          /*!
   4300           *	@brief This API is used to get
   4301           *	the fifo full interrupt2 in the register 0x1A bit 5
   4302           *
   4303           *
   4304           *
   4305           *  @param intr2_fifo_full_u8 : Thee vale of fifo full enable
   4306           *       intr2_fifo_full_u8     |    result
   4307           *       ------------------------ | ------------------
   4308           *              0x00              | INTR_DISABLE
   4309           *              0x01              | INTR_ENABLE
   4310           *
   4311           *
   4312           *
   4313           *	@return results of bus communication function
   4314           *	@retval 0 -> Success
   4315           *	@retval -1 -> Error
   4316           *
   4317           *
   4318           *
   4319           */
   4320          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr2_fifo_full(u8 *intr2_fifo_full_u8)
   4321          {
   4322          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4323          		/*  Variable used to return value of
   4324          	communication routine*/
   4325          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4326          
   4327          	if (p_bma2x2 == BMA2x2_NULL) {
   4328          		/* Check the struct p_bma2x2 is empty */
   4329          		return E_BMA2x2_NULL_PTR;
   4330          		} else {
   4331          			/* read the fifo full interrupt2*/
   4332          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4333          			(p_bma2x2->dev_addr,
   4334          			BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL_REG,
   4335          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4336          			*intr2_fifo_full_u8 = BMA2x2_GET_BITSLICE
   4337          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL);
   4338          		}
   4339          	return com_rslt;
   4340          }
   4341          /*!
   4342           *	@brief This API is used to set
   4343           *	the fifo full interrupt2 in the register 0x1A bit 5
   4344           *
   4345           *
   4346           *
   4347           *  @param intr2_fifo_full_u8 : Thee vale of fifo full enable
   4348           *       intr2_fifo_full_u8     |    result
   4349           *       ------------------------ | ------------------
   4350           *              0x00              | INTR_DISABLE
   4351           *              0x01              | INTR_ENABLE
   4352           *
   4353           *
   4354           *
   4355           *	@return results of bus communication function
   4356           *	@retval 0 -> Success
   4357           *	@retval -1 -> Error
   4358           *
   4359           *
   4360           *
   4361           */
   4362          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr2_fifo_full(u8 intr2_fifo_full_u8)
   4363          {
   4364          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4365          	/*  Variable used to return value of
   4366          	communication routine*/
   4367          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4368          
   4369          	if (p_bma2x2 == BMA2x2_NULL) {
   4370          		/* Check the struct p_bma2x2 is empty */
   4371          		return E_BMA2x2_NULL_PTR;
   4372          		} else {
   4373          		if (intr2_fifo_full_u8 <
   4374          		BMA2x2_FIFO_MODE_STATUS_RANGE) {
   4375          			/* write the fifo full interrupt2*/
   4376          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4377          			(p_bma2x2->dev_addr,
   4378          			BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL_REG,
   4379          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4380          			data_u8 = BMA2x2_SET_BITSLICE
   4381          			(data_u8,
   4382          			BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL,
   4383          			intr2_fifo_full_u8);
   4384          			com_rslt += bma2x2_write_reg(
   4385          			BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL_REG,
   4386          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4387          			} else {
   4388          			com_rslt = E_OUT_OF_RANGE;
   4389          			}
   4390          		}
   4391          	return com_rslt;
   4392          }
   4393          /*!
   4394           *	@brief This API is used to get
   4395           *	the source data status of source data,
   4396           *	source slow no motion, source slope, source high
   4397           *	and source low in the register 0x1E bit from 0 to 5
   4398           *
   4399           *
   4400           *
   4401           *  @param channel_u8 : The value of source select
   4402           *       channel_u8     |    result
   4403           *       -----------------| ------------------
   4404           *               0        | BMA2x2_ACCEL_SOURCE_LOW_G
   4405           *               1        | BMA2x2_ACCEL_SOURCE_HIGH_G
   4406           *               2        | BMA2x2_ACCEL_SOURCE_SLOPE
   4407           *               3        | BMA2x2_ACCEL_SOURCE_SLOW_NO_MOTION
   4408           *               4        | BMA2x2_ACCEL_SOURCE_TAP
   4409           *               5        | BMA2x2_ACCEL_SOURCE_DATA
   4410           *
   4411           *	@param intr_source_u8: The source status enable value
   4412           *       intr_source_u8         |    result
   4413           *       ------------------------ | ------------------
   4414           *              0x00              | INTR_DISABLE
   4415           *              0x01              | INTR_ENABLE
   4416           *
   4417           *	@return results of bus communication function
   4418           *	@retval 0 -> Success
   4419           *	@retval -1 -> Error
   4420           *
   4421           */
   4422          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_source(u8 channel_u8,
   4423          u8 *intr_source_u8)
   4424          {
   4425          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4426          	/*  Variable used to return value of
   4427          	communication routine*/
   4428          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4429          
   4430          	if (p_bma2x2 == BMA2x2_NULL) {
   4431          		return  E_BMA2x2_NULL_PTR;
   4432          		} else {
   4433          		/* read the source interrupt register */
   4434          		switch (channel_u8) {
   4435          		case BMA2x2_SOURCE_LOW_G:
   4436          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4437          			(p_bma2x2->dev_addr,
   4438          			BMA2x2_UNFILT_INTR_SOURCE_LOW_G_REG,
   4439          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4440          			*intr_source_u8 = BMA2x2_GET_BITSLICE
   4441          			(data_u8, BMA2x2_UNFILT_INTR_SOURCE_LOW_G);
   4442          		break;
   4443          		case BMA2x2_SOURCE_HIGH_G:
   4444          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4445          			(p_bma2x2->dev_addr,
   4446          			BMA2x2_UNFILT_INTR_SOURCE_HIGH_G_REG,
   4447          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4448          			*intr_source_u8 = BMA2x2_GET_BITSLICE
   4449          			(data_u8, BMA2x2_UNFILT_INTR_SOURCE_HIGH_G);
   4450          		break;
   4451          		case BMA2x2_SOURCE_SLOPE:
   4452          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4453          			(p_bma2x2->dev_addr,
   4454          			BMA2x2_UNFILT_INTR_SOURCE_SLOPE_REG,
   4455          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4456          			*intr_source_u8 = BMA2x2_GET_BITSLICE
   4457          			(data_u8, BMA2x2_UNFILT_INTR_SOURCE_SLOPE);
   4458          		break;
   4459          		case BMA2x2_SOURCE_SLOW_NO_MOTION:
   4460          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4461          			(p_bma2x2->dev_addr,
   4462          			BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION_REG,
   4463          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4464          			*intr_source_u8 = BMA2x2_GET_BITSLICE
   4465          			(data_u8, BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION);
   4466          		break;
   4467          		case BMA2x2_SOURCE_TAP:
   4468          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4469          			(p_bma2x2->dev_addr,
   4470          			BMA2x2_UNFILT_INTR_SOURCE_TAP_REG,
   4471          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4472          			*intr_source_u8 = BMA2x2_GET_BITSLICE
   4473          			(data_u8, BMA2x2_UNFILT_INTR_SOURCE_TAP);
   4474          		break;
   4475          		case BMA2x2_SOURCE_DATA:
   4476          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4477          			(p_bma2x2->dev_addr,
   4478          			BMA2x2_UNFILT_INTR_SOURCE_DATA_REG,
   4479          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4480          			*intr_source_u8 = BMA2x2_GET_BITSLICE
   4481          			(data_u8, BMA2x2_UNFILT_INTR_SOURCE_DATA);
   4482          		break;
   4483          		default:
   4484          			com_rslt = E_OUT_OF_RANGE;
   4485          		break;
   4486          			}
   4487          		}
   4488          	return com_rslt;
   4489          }
   4490          /*!
   4491           *	@brief This API is used to set
   4492           *	the source data status of source data,
   4493           *	source slow no motion, source slope, source high
   4494           *	and source low in the register 0x1E bit from 0 to 5
   4495           *
   4496           *
   4497           *
   4498           *  @param channel_u8 : The value of source select
   4499           *       channel_u8     |    result
   4500           *       -----------------| ------------------
   4501           *               0        | BMA2x2_ACCEL_SOURCE_LOW_G
   4502           *               1        | BMA2x2_ACCEL_SOURCE_HIGH_G
   4503           *               2        | BMA2x2_ACCEL_SOURCE_SLOPE
   4504           *               3        | BMA2x2_ACCEL_SOURCE_SLOW_NO_MOTION
   4505           *               4        | BMA2x2_ACCEL_SOURCE_TAP
   4506           *               5        | BMA2x2_ACCEL_SOURCE_DATA
   4507           *
   4508           *	@param intr_source_u8: The source status enable value
   4509           *       intr_source_u8         |    result
   4510           *       ------------------------ | ------------------
   4511           *              0x00              | INTR_DISABLE
   4512           *              0x01              | INTR_ENABLE
   4513           *
   4514           *	@return results of bus communication function
   4515           *	@retval 0 -> Success
   4516           *	@retval -1 -> Error
   4517           *
   4518           */
   4519          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_source(u8 channel_u8,
   4520          u8 intr_source_u8)
   4521          {
   4522          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4523          	/*  Variable used to return value of
   4524          	communication routine*/
   4525          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4526          		if (p_bma2x2 == BMA2x2_NULL) {
   4527          			com_rslt = E_BMA2x2_NULL_PTR;
   4528          		} else {
   4529          		switch (channel_u8) {
   4530          		/* write the source interrupt register*/
   4531          		case BMA2x2_SOURCE_LOW_G:
   4532          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4533          			(p_bma2x2->dev_addr,
   4534          			BMA2x2_UNFILT_INTR_SOURCE_LOW_G_REG,
   4535          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4536          			data_u8 = BMA2x2_SET_BITSLICE
   4537          			(data_u8,
   4538          			BMA2x2_UNFILT_INTR_SOURCE_LOW_G, intr_source_u8);
   4539          			com_rslt += bma2x2_write_reg(
   4540          			BMA2x2_UNFILT_INTR_SOURCE_LOW_G_REG,
   4541          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4542          		break;
   4543          		case BMA2x2_SOURCE_HIGH_G:
   4544          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4545          			(p_bma2x2->dev_addr,
   4546          			BMA2x2_UNFILT_INTR_SOURCE_HIGH_G_REG,
   4547          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4548          			data_u8 = BMA2x2_SET_BITSLICE
   4549          			(data_u8,
   4550          			BMA2x2_UNFILT_INTR_SOURCE_HIGH_G, intr_source_u8);
   4551          			com_rslt += bma2x2_write_reg(
   4552          			BMA2x2_UNFILT_INTR_SOURCE_HIGH_G_REG,
   4553          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4554          		break;
   4555          		case BMA2x2_SOURCE_SLOPE:
   4556          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4557          			(p_bma2x2->dev_addr,
   4558          			BMA2x2_UNFILT_INTR_SOURCE_SLOPE_REG,
   4559          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4560          			data_u8 = BMA2x2_SET_BITSLICE
   4561          			(data_u8,
   4562          			BMA2x2_UNFILT_INTR_SOURCE_SLOPE, intr_source_u8);
   4563          			com_rslt += bma2x2_write_reg(
   4564          			BMA2x2_UNFILT_INTR_SOURCE_SLOPE_REG,
   4565          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4566          		break;
   4567          		case BMA2x2_SOURCE_SLOW_NO_MOTION:
   4568          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4569          			(p_bma2x2->dev_addr,
   4570          			BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION_REG,
   4571          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4572          			data_u8 = BMA2x2_SET_BITSLICE
   4573          			(data_u8,
   4574          			BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION,
   4575          			intr_source_u8);
   4576          			com_rslt += bma2x2_write_reg(
   4577          			BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION_REG,
   4578          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4579          		break;
   4580          		case BMA2x2_SOURCE_TAP:
   4581          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4582          			(p_bma2x2->dev_addr,
   4583          			BMA2x2_UNFILT_INTR_SOURCE_TAP_REG,
   4584          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4585          			data_u8 = BMA2x2_SET_BITSLICE
   4586          			(data_u8, BMA2x2_UNFILT_INTR_SOURCE_TAP,
   4587          			intr_source_u8);
   4588          			com_rslt += bma2x2_write_reg(
   4589          			BMA2x2_UNFILT_INTR_SOURCE_TAP_REG,
   4590          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4591          		break;
   4592          		case BMA2x2_SOURCE_DATA:
   4593          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4594          			(p_bma2x2->dev_addr,
   4595          			BMA2x2_UNFILT_INTR_SOURCE_DATA_REG,
   4596          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4597          			data_u8 = BMA2x2_SET_BITSLICE
   4598          			(data_u8, BMA2x2_UNFILT_INTR_SOURCE_DATA,
   4599          			intr_source_u8);
   4600          			com_rslt += bma2x2_write_reg(
   4601          			BMA2x2_UNFILT_INTR_SOURCE_DATA_REG,
   4602          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4603          		break;
   4604          		default:
   4605          			com_rslt = E_OUT_OF_RANGE;
   4606          		break;
   4607          		}
   4608          	}
   4609          	return com_rslt;
   4610          }
   4611          /*!
   4612           *	@brief This API is used to get
   4613           *	the interrupt output type in the register 0x20.
   4614           *	@note INTR1 -> bit 1
   4615           *	@note INTR2 -> bit 3
   4616           *
   4617           *  @param channel_u8: The value of output type select
   4618           *       channel_u8     |    result
   4619           *       -----------------| ------------------
   4620           *               0        | BMA2x2_ACCEL_INTR1_OUTPUT
   4621           *               1        | BMA2x2_ACCEL_INTR2_OUTPUT
   4622           *
   4623           *	@param intr_output_type_u8: The value of output type select
   4624           *       intr_source_u8         |    result
   4625           *       ------------------------ | ------------------
   4626           *              0x01              | OPEN_DRAIN
   4627           *              0x00              | PUSS_PULL
   4628           *
   4629           *
   4630           *
   4631           *	@return results of bus communication function
   4632           *	@retval 0 -> Success
   4633           *	@retval -1 -> Error
   4634           *
   4635           *
   4636           */
   4637          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_output_type(u8 channel_u8,
   4638          u8 *intr_output_type_u8)
   4639          {
   4640          		u8 data_u8 = BMA2x2_INIT_VALUE;
   4641          		/*  Variable used to return value of
   4642          		communication routine*/
   4643          		BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4644          
   4645          		if (p_bma2x2 == BMA2x2_NULL) {
   4646          			com_rslt = E_BMA2x2_NULL_PTR;
   4647          		} else {
   4648          		switch (channel_u8) {
   4649          		/* read the output type */
   4650          		case BMA2x2_INTR1_OUTPUT:
   4651          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4652          			(p_bma2x2->dev_addr,
   4653          			BMA2x2_INTR1_PAD_OUTPUT_TYPE_REG,
   4654          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4655          			*intr_output_type_u8 = BMA2x2_GET_BITSLICE
   4656          			(data_u8, BMA2x2_INTR1_PAD_OUTPUT_TYPE);
   4657          		break;
   4658          		case BMA2x2_INTR2_OUTPUT:
   4659          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4660          			(p_bma2x2->dev_addr,
   4661          			BMA2x2_INTR2_PAD_OUTPUT_TYPE_REG,
   4662          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4663          			*intr_output_type_u8 = BMA2x2_GET_BITSLICE
   4664          			(data_u8, BMA2x2_INTR2_PAD_OUTPUT_TYPE);
   4665          		break;
   4666          		default:
   4667          			com_rslt = E_OUT_OF_RANGE;
   4668          		break;
   4669          		}
   4670          	}
   4671          	return com_rslt;
   4672          }
   4673          /*!
   4674           *	@brief This API is used to set
   4675           *	the interrupt output type in the register 0x20.
   4676           *	@note INTR1 -> bit 1
   4677           *	@note INTR2 -> bit 3
   4678           *
   4679           *  @param channel_u8: The value of output type select
   4680           *         channel_u8   |    result
   4681           *       -----------------| ------------------
   4682           *               0        | BMA2x2_ACCEL_INTR1_OUTPUT
   4683           *               1        | BMA2x2_ACCEL_INTR2_OUTPUT
   4684           *
   4685           *	@param intr_output_type_u8: The value of output type select
   4686           *       intr_source_u8         |    result
   4687           *       ------------------------ | ------------------
   4688           *              0x01              | OPEN_DRAIN
   4689           *              0x00              | PUSS_PULL
   4690           *
   4691           *
   4692           *
   4693           *	@return results of bus communication function
   4694           *	@retval 0 -> Success
   4695           *	@retval -1 -> Error
   4696           *
   4697           *
   4698           */
   4699          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_output_type(u8 channel_u8,
   4700          u8 intr_output_type_u8)
   4701          {
   4702          		u8 data_u8 = BMA2x2_INIT_VALUE;
   4703          		/*  Variable used to return value of
   4704          		communication routine*/
   4705          		BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4706          
   4707          		if (p_bma2x2 == BMA2x2_NULL) {
   4708          			com_rslt = E_BMA2x2_NULL_PTR;
   4709          		}  else {
   4710          		switch (channel_u8) {
   4711          		/* write the output type*/
   4712          		case BMA2x2_INTR1_OUTPUT:
   4713          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4714          			(p_bma2x2->dev_addr,
   4715          			BMA2x2_INTR1_PAD_OUTPUT_TYPE_REG,
   4716          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4717          			data_u8 = BMA2x2_SET_BITSLICE
   4718          			(data_u8,
   4719          			BMA2x2_INTR1_PAD_OUTPUT_TYPE, intr_output_type_u8);
   4720          			com_rslt += bma2x2_write_reg(
   4721          			BMA2x2_INTR1_PAD_OUTPUT_TYPE_REG,
   4722          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4723          		break;
   4724          		case BMA2x2_INTR2_OUTPUT:
   4725          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4726          			(p_bma2x2->dev_addr,
   4727          			BMA2x2_INTR2_PAD_OUTPUT_TYPE_REG,
   4728          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4729          			data_u8 = BMA2x2_SET_BITSLICE
   4730          			(data_u8,
   4731          			BMA2x2_INTR2_PAD_OUTPUT_TYPE, intr_output_type_u8);
   4732          			com_rslt += bma2x2_write_reg(
   4733          			BMA2x2_INTR2_PAD_OUTPUT_TYPE_REG,
   4734          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4735          		break;
   4736          		default:
   4737          			com_rslt = E_OUT_OF_RANGE;
   4738          		break;
   4739          		}
   4740          	}
   4741          	return com_rslt;
   4742          }
   4743          /*!
   4744           *	@brief This API is used to get
   4745           *	Active Level status in the register 0x20
   4746           *	@note INTR1 -> bit 0
   4747           *	@note INTR2 -> bit 2
   4748           *
   4749           *  @param channel_u8: The value of Active Level select
   4750           *       channel_u8     |    result
   4751           *       -----------------| ------------------
   4752           *               0        | BMA2x2_ACCEL_INTR1_LEVEL
   4753           *               1        | BMA2x2_ACCEL_INTR2_LEVEL
   4754           *
   4755           *  @param intr_level_u8: The Active Level status enable value
   4756           *        intr_level_u8         |    result
   4757           *       ------------------------ | ------------------
   4758           *              0x01              | ACTIVE_HIGH
   4759           *              0x00              | ACTIVE_LOW
   4760           *
   4761           *
   4762           *	@return results of bus communication function
   4763           *	@retval 0 -> Success
   4764           *	@retval -1 -> Error
   4765           *
   4766           *
   4767           */
   4768          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_level(u8 channel_u8,
   4769          u8 *intr_level_u8)
   4770          {
   4771          		u8 data_u8 = BMA2x2_INIT_VALUE;
   4772          		/*  Variable used to return value of
   4773          		communication routine*/
   4774          		BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4775          
   4776          		if (p_bma2x2 == BMA2x2_NULL) {
   4777          			com_rslt = E_BMA2x2_NULL_PTR;
   4778          		} else {
   4779          		switch (channel_u8) {
   4780          		/* read the active level*/
   4781          		case BMA2x2_INTR1_LEVEL:
   4782          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4783          			(p_bma2x2->dev_addr,
   4784          			BMA2x2_INTR1_PAD_ACTIVE_LEVEL_REG,
   4785          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4786          			*intr_level_u8 = BMA2x2_GET_BITSLICE
   4787          			(data_u8, BMA2x2_INTR1_PAD_ACTIVE_LEVEL);
   4788          		break;
   4789          		case BMA2x2_INTR2_LEVEL:
   4790          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4791          			(p_bma2x2->dev_addr,
   4792          			BMA2x2_INTR2_PAD_ACTIVE_LEVEL_REG,
   4793          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4794          			*intr_level_u8 = BMA2x2_GET_BITSLICE
   4795          			(data_u8, BMA2x2_INTR2_PAD_ACTIVE_LEVEL);
   4796          		break;
   4797          		default:
   4798          			com_rslt = E_OUT_OF_RANGE;
   4799          		break;
   4800          		}
   4801          	}
   4802          	return com_rslt;
   4803          }
   4804          /*!
   4805           *	@brief This API is used to set
   4806           *	Active Level status in the register 0x20
   4807           *	@note INTR1 -> bit 0
   4808           *	@note INTR2 -> bit 2
   4809           *
   4810           *  @param channel_u8: The value of Active Level select
   4811           *       channel_u8     |    result
   4812           *       -----------------| ------------------
   4813           *               0        | BMA2x2_ACCEL_INTR1_LEVEL
   4814           *               1        | BMA2x2_ACCEL_INTR2_LEVEL
   4815           *
   4816           *  @param intr_level_u8: The Active Level status enable value
   4817           *       intr_level_u8          |    result
   4818           *       ------------------------ | ------------------
   4819           *              0x01              | ACTIVE_HIGH
   4820           *              0x00              | ACTIVE_LOW
   4821           *
   4822           *
   4823           *	@return results of bus communication function
   4824           *	@retval 0 -> Success
   4825           *	@retval -1 -> Error
   4826           *
   4827           *
   4828           */
   4829          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_level(u8 channel_u8,
   4830          u8 intr_level_u8)
   4831          {
   4832          		u8 data_u8 = BMA2x2_INIT_VALUE;
   4833          		/*  Variable used to return value of
   4834          		communication routine*/
   4835          		BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4836          
   4837          		if (p_bma2x2 == BMA2x2_NULL) {
   4838          			com_rslt = E_BMA2x2_NULL_PTR;
   4839          		} else {
   4840          		switch (channel_u8) {
   4841          		/* write the active level */
   4842          		case BMA2x2_INTR1_LEVEL:
   4843          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4844          			(p_bma2x2->dev_addr,
   4845          			BMA2x2_INTR1_PAD_ACTIVE_LEVEL_REG,
   4846          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4847          			data_u8 = BMA2x2_SET_BITSLICE
   4848          			(data_u8,
   4849          			BMA2x2_INTR1_PAD_ACTIVE_LEVEL, intr_level_u8);
   4850          			com_rslt += bma2x2_write_reg(
   4851          			BMA2x2_INTR1_PAD_ACTIVE_LEVEL_REG,
   4852          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4853          		break;
   4854          		case BMA2x2_INTR2_LEVEL:
   4855          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4856          			(p_bma2x2->dev_addr,
   4857          			BMA2x2_INTR2_PAD_ACTIVE_LEVEL_REG,
   4858          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4859          			data_u8 = BMA2x2_SET_BITSLICE
   4860          			(data_u8,
   4861          			BMA2x2_INTR2_PAD_ACTIVE_LEVEL, intr_level_u8);
   4862          			com_rslt += bma2x2_write_reg(
   4863          			BMA2x2_INTR2_PAD_ACTIVE_LEVEL_REG,
   4864          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4865          		break;
   4866          		default:
   4867          			com_rslt = E_OUT_OF_RANGE;
   4868          		break;
   4869          		}
   4870          	}
   4871          	return com_rslt;
   4872          }
   4873          /*!
   4874           *	@brief This API is used to set
   4875           *	the reset interrupt in the register 0x21 bit 7
   4876           *
   4877           *
   4878           *
   4879           *  @param  rst_intr_u8: The value of reset interrupt
   4880           *          rst_intr_u8         |  result
   4881           *       ------------------------ | ------------------
   4882           *              0x01              | clear any latch interrupt
   4883           *              0x00              | keep latch interrupt active
   4884           *
   4885           *
   4886           *	@return results of bus communication function
   4887           *	@retval 0 -> Success
   4888           *	@retval -1 -> Error
   4889           *
   4890           *
   4891           */
   4892          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_rst_intr(u8 rst_intr_u8)
   4893          {
   4894          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4895          		/*  Variable used to return value of
   4896          	communication routine*/
   4897          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4898          
   4899          	if (p_bma2x2 == BMA2x2_NULL) {
   4900          		/* Check the struct p_bma2x2 is empty */
   4901          		return E_BMA2x2_NULL_PTR;
   4902          		} else {
   4903          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4904          			(p_bma2x2->dev_addr, BMA2x2_RESET_INTR_REG,
   4905          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4906          			data_u8 = BMA2x2_SET_BITSLICE
   4907          			(data_u8, BMA2x2_RESET_INTR, rst_intr_u8);
   4908          			com_rslt += bma2x2_write_reg(BMA2x2_RESET_INTR_REG,
   4909          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4910          		}
   4911          	return com_rslt;
   4912          }
   4913          /*!
   4914           *	@brief This API is used to get
   4915           *	the latch duration in the register 0x21 bit from 0 to 3
   4916           *
   4917           *	@param latch_intr_u8: The value of latch duration
   4918           *        latch_intr_u8 |  result
   4919           *       -----------------| ------------------
   4920           *               0x00     | BMA2x2_LATCH_DURN_NON_LATCH
   4921           *               0x01     | BMA2x2_LATCH_DURN_250MS
   4922           *               0x02     | BMA2x2_LATCH_DURN_500MS
   4923           *               0x03     | BMA2x2_LATCH_DURN_1S
   4924           *               0x04     | BMA2x2_LATCH_DURN_2S
   4925           *               0x05     | BMA2x2_LATCH_DURN_4S
   4926           *               0x06     | BMA2x2_LATCH_DURN_8S
   4927           *               0x07     | BMA2x2_LATCH_DURN_LATCH
   4928           *               0x08     | BMA2x2_LATCH_DURN_NON_LATCH1
   4929           *               0x09     | BMA2x2_LATCH_DURN_250US
   4930           *               0x0A     | BMA2x2_LATCH_DURN_500US
   4931           *               0x0B     | BMA2x2_LATCH_DURN_1MS
   4932           *               0x0C     | BMA2x2_LATCH_DURN_12_5MS
   4933           *               0x0D     | BMA2x2_LATCH_DURN_25MS
   4934           *               0x0E     | BMA2x2_LATCH_DURN_50MS
   4935           *               0x0F     | BMA2x2_LATCH_DURN_LATCH1
   4936           *
   4937           *
   4938           *
   4939           *	@return results of bus communication function
   4940           *	@retval 0 -> Success
   4941           *	@retval -1 -> Error
   4942           *
   4943           *
   4944           */
   4945          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_latch_intr(u8 *latch_intr_u8)
   4946          {
   4947          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4948          	/*  Variable used to return value of
   4949          	communication routine*/
   4950          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4951          
   4952          	if (p_bma2x2 == BMA2x2_NULL) {
   4953          		/* Check the struct p_bma2x2 is empty */
   4954          		return E_BMA2x2_NULL_PTR;
   4955          		} else {
   4956          			/* read the latch duration */
   4957          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4958          			(p_bma2x2->dev_addr, BMA2x2_LATCH_INTR_REG,
   4959          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4960          			*latch_intr_u8 = BMA2x2_GET_BITSLICE
   4961          			(data_u8, BMA2x2_LATCH_INTR);
   4962          		}
   4963          	return com_rslt;
   4964          }
   4965          /*!
   4966           *	@brief This API is used to set
   4967           *	the latch duration in the register 0x21 bit from 0 to 3
   4968           *
   4969           *	@param latch_intr_u8: The value of latch duration
   4970           *        latch_intr_u8 |  result
   4971           *       -----------------| ------------------
   4972           *               0x00     | BMA2x2_LATCH_DURN_NON_LATCH
   4973           *               0x01     | BMA2x2_LATCH_DURN_250MS
   4974           *               0x02     | BMA2x2_LATCH_DURN_500MS
   4975           *               0x03     | BMA2x2_LATCH_DURN_1S
   4976           *               0x04     | BMA2x2_LATCH_DURN_2S
   4977           *               0x05     | BMA2x2_LATCH_DURN_4S
   4978           *               0x06     | BMA2x2_LATCH_DURN_8S
   4979           *               0x07     | BMA2x2_LATCH_DURN_LATCH
   4980           *               0x08     | BMA2x2_LATCH_DURN_NON_LATCH1
   4981           *               0x09     | BMA2x2_LATCH_DURN_250US
   4982           *               0x0A     | BMA2x2_LATCH_DURN_500US
   4983           *               0x0B     | BMA2x2_LATCH_DURN_1MS
   4984           *               0x0C     | BMA2x2_LATCH_DURN_12_5MS
   4985           *               0x0D     | BMA2x2_LATCH_DURN_25MS
   4986           *               0x0E     | BMA2x2_LATCH_DURN_50MS
   4987           *               0x0F     | BMA2x2_LATCH_DURN_LATCH1
   4988           *
   4989           *
   4990           *
   4991           *	@return results of bus communication function
   4992           *	@retval 0 -> Success
   4993           *	@retval -1 -> Error
   4994           *
   4995           *
   4996           */
   4997          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_latch_intr(u8 latch_intr_u8)
   4998          {
   4999          u8 data_u8 = BMA2x2_INIT_VALUE;
   5000          /*  Variable used to return value of
   5001          communication routine*/
   5002          BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5003          u8 latch_durn_u8 = BMA2x2_INIT_VALUE;
   5004          if (p_bma2x2 == BMA2x2_NULL)  {
   5005          		/* Check the struct p_bma2x2 is empty */
   5006          		return E_BMA2x2_NULL_PTR;
   5007          		} else  {
   5008          		if (latch_intr_u8 < BMA2x2_ACCEL_BW_MAX_RANGE) {
   5009          			switch (latch_intr_u8) {
   5010          			case BMA2x2_LATCH_DURN_NON_LATCH:
   5011          				latch_durn_u8 = BMA2x2_LATCH_DURN_NON_LATCH;
   5012          
   5013          				/*  NON LATCH   */
   5014          			break;
   5015          			case BMA2x2_LATCH_DURN_250MS:
   5016          				latch_durn_u8 = BMA2x2_LATCH_DURN_250MS;
   5017          
   5018          				/*  250 MS  */
   5019          			break;
   5020          			case BMA2x2_LATCH_DURN_500MS:
   5021          				latch_durn_u8 = BMA2x2_LATCH_DURN_500MS;
   5022          
   5023          				/*  500 MS  */
   5024          			break;
   5025          			case BMA2x2_LATCH_DURN_1S:
   5026          				latch_durn_u8 = BMA2x2_LATCH_DURN_1S;
   5027          
   5028          				/*  1 S   */
   5029          			break;
   5030          			case BMA2x2_LATCH_DURN_2S:
   5031          				latch_durn_u8 = BMA2x2_LATCH_DURN_2S;
   5032          
   5033          				/*  2 S  */
   5034          			break;
   5035          			case BMA2x2_LATCH_DURN_4S:
   5036          				latch_durn_u8 = BMA2x2_LATCH_DURN_4S;
   5037          
   5038          				/*  4 S  */
   5039          			break;
   5040          			case BMA2x2_LATCH_DURN_8S:
   5041          				latch_durn_u8 = BMA2x2_LATCH_DURN_8S;
   5042          
   5043          				/*  8 S  */
   5044          			break;
   5045          			case BMA2x2_LATCH_DURN_LATCH:
   5046          				latch_durn_u8 = BMA2x2_LATCH_DURN_LATCH;
   5047          
   5048          				/*  LATCH  */
   5049          			break;
   5050          			case BMA2x2_LATCH_DURN_NON_LATCH1:
   5051          				latch_durn_u8 = BMA2x2_LATCH_DURN_NON_LATCH1;
   5052          
   5053          				/*  NON LATCH1  */
   5054          			break;
   5055          			case BMA2x2_LATCH_DURN_250US:
   5056          				latch_durn_u8 = BMA2x2_LATCH_DURN_250US;
   5057          
   5058          				/*  250 US   */
   5059          			break;
   5060          			case BMA2x2_LATCH_DURN_500US:
   5061          				latch_durn_u8 = BMA2x2_LATCH_DURN_500US;
   5062          
   5063          				/*  500 US   */
   5064          			break;
   5065          			case BMA2x2_LATCH_DURN_1MS:
   5066          				latch_durn_u8 = BMA2x2_LATCH_DURN_1MS;
   5067          
   5068          				/*  1 MS   */
   5069          			break;
   5070          			case BMA2x2_LATCH_DURN_12_5MS:
   5071          				latch_durn_u8 = BMA2x2_LATCH_DURN_12_5MS;
   5072          
   5073          				/*  12.5 MS   */
   5074          			break;
   5075          			case BMA2x2_LATCH_DURN_25MS:
   5076          				latch_durn_u8 = BMA2x2_LATCH_DURN_25MS;
   5077          
   5078          				/*  25 MS   */
   5079          			break;
   5080          			case BMA2x2_LATCH_DURN_50MS:
   5081          				latch_durn_u8 = BMA2x2_LATCH_DURN_50MS;
   5082          
   5083          				/*  50 MS   */
   5084          			break;
   5085          			case BMA2x2_LATCH_DURN_LATCH1:
   5086          				latch_durn_u8 = BMA2x2_LATCH_DURN_LATCH1;
   5087          
   5088          				/*  LATCH1   */
   5089          			break;
   5090          			default:
   5091          			break;
   5092          			}
   5093          			/* write the latch duration */
   5094          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5095          			(p_bma2x2->dev_addr, BMA2x2_LATCH_INTR_REG,
   5096          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5097          			data_u8 = BMA2x2_SET_BITSLICE
   5098          			(data_u8, BMA2x2_LATCH_INTR, latch_durn_u8);
   5099          			com_rslt += bma2x2_write_reg(BMA2x2_LATCH_INTR_REG,
   5100          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5101          		} else {
   5102          		com_rslt = E_OUT_OF_RANGE;
   5103          		}
   5104          	}
   5105          	return com_rslt;
   5106          }
   5107          /*!
   5108           *	@brief This API is used to get the duration of
   5109           *	Low, High, Slope and slow no motion interrupts in the registers
   5110           *	@note LOW_DURN		-> register 0x22 bit form 0 to 7
   5111           *	@note HIGH_DURN		-> register 0x25 bit form 0 to 7
   5112           *	@note SLOPE_DURN		-> register 0x27 bit form 0 to 1
   5113           *	@note SLO_NO_MOT_DURN -> register 0x27 bit form 2 to 7
   5114           *
   5115           *  @param channel_u8: The value of duration select
   5116           *     channel_u8   | result
   5117           *   -----------------| ------------------
   5118           *               0    | BMA2x2_ACCEL_LOW_DURN
   5119           *               1    | BMA2x2_ACCEL_HIGH_DURN
   5120           *               2    | BMA2x2_ACCEL_SLOPE_DURN
   5121           *               3    | BMA2x2_ACCEL_SLOW_NO_MOTION_DURN
   5122           *
   5123           *	@param durn_u8: The value of duration
   5124           *
   5125           *	@note :
   5126           *     Duration           |    result
   5127           * -----------------------| ------------------
   5128           * BMA2x2_ACCEL_LOW_DURN  | Low-g interrupt trigger
   5129           *         -              | delay according to([durn_u8 +1]*2)ms
   5130           *         -              | range from 2ms to 512ms. default is 20ms
   5131           * BMA2x2_ACCEL_HIGH_DURN | high-g interrupt trigger
   5132           *         -              | delay according to([durn_u8 +1]*2)ms
   5133           *         -              | range from 2ms to 512ms. default is 32ms
   5134           * BMA2x2_ACCEL_SLOPE_DURN| slope interrupt trigger
   5135           *         -              | if[durn_u8<1:0>+1] consecutive data points
   5136           *         -              | are above the slope interrupt threshold
   5137           * SLO_NO_MOT_DURN        | Refer data sheet for clear information
   5138           *
   5139           *
   5140           *	@return results of bus communication function
   5141           *	@retval 0 -> Success
   5142           *	@retval -1 -> Error
   5143           *
   5144           *
   5145           */
   5146          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_durn(u8 channel_u8,
   5147          u8 *durn_u8)
   5148          {
   5149          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5150          	/*  Variable used to return value of
   5151          	communication routine*/
   5152          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5153          
   5154          	if (p_bma2x2 == BMA2x2_NULL) {
   5155          		/* Check the struct p_bma2x2 is empty */
   5156          		return E_BMA2x2_NULL_PTR;
   5157          		} else {
   5158          		/* write the duration data */
   5159          		switch (channel_u8) {
   5160          		case BMA2x2_LOW_DURN:
   5161          			/*LOW DURATION*/
   5162          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5163          			(p_bma2x2->dev_addr, BMA2x2_LOW_DURN_ADDR,
   5164          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5165          			*durn_u8 = data_u8;
   5166          		break;
   5167          		case BMA2x2_HIGH_DURN:
   5168          			/*HIGH DURATION*/
   5169          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5170          			(p_bma2x2->dev_addr, BMA2x2_HIGH_DURN_ADDR,
   5171          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5172          			*durn_u8 = data_u8;
   5173          		break;
   5174          		case BMA2x2_SLOPE_DURN:
   5175          			/*SLOPE DURATION*/
   5176          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5177          			(p_bma2x2->dev_addr, BMA2x2_SLOPE_DURN_REG,
   5178          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5179          			*durn_u8 = BMA2x2_GET_BITSLICE
   5180          			(data_u8, BMA2x2_SLOPE_DURN);
   5181          		break;
   5182          		case BMA2x2_SLOW_NO_MOTION_DURN:
   5183          			/*SLO NO MOT DURATION*/
   5184          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5185          			(p_bma2x2->dev_addr,
   5186          			BMA2x2_SLOW_NO_MOTION_DURN_REG,
   5187          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5188          			*durn_u8 = BMA2x2_GET_BITSLICE
   5189          			(data_u8, BMA2x2_SLOW_NO_MOTION_DURN);
   5190          		break;
   5191          		default:
   5192          			com_rslt = E_OUT_OF_RANGE;
   5193          		break;
   5194          		}
   5195          	}
   5196          	return com_rslt;
   5197          }
   5198          /*!
   5199           *	@brief This API is used to set the duration of
   5200           *	Low, High, Slope and slow no motion interrupts in the registers
   5201           *	@note LOW_DURN		-> register 0x22 bit form 0 to 7
   5202           *	@note HIGH_DURN		-> register 0x25 bit form 0 to 7
   5203           *	@note SLOPE_DURN		-> register 0x27 bit form 0 to 1
   5204           *	@note SLO_NO_MOT_DURN -> register 0x27 bit form 2 to 7
   5205           *
   5206           *  @param channel_u8: The value of duration select
   5207           *     channel_u8   | result
   5208           *   -----------------| ------------------
   5209           *               0    | BMA2x2_ACCEL_LOW_DURN
   5210           *               1    | BMA2x2_ACCEL_HIGH_DURN
   5211           *               2    | BMA2x2_ACCEL_SLOPE_DURN
   5212           *               3    | BMA2x2_ACCEL_SLOW_NO_MOTION_DURN
   5213           *
   5214           *	@param durn_u8: The value of duration
   5215           *
   5216           *	@note :
   5217           *     Duration           |    result
   5218           * -----------------------| ------------------
   5219           * BMA2x2_ACCEL_LOW_DURN  | Low-g interrupt trigger
   5220           *         -              | delay according to([durn_u8 +1]*2)ms
   5221           *         -              | range from 2ms to 512ms. default is 20ms
   5222           * BMA2x2_ACCEL_HIGH_DURN | high-g interrupt trigger
   5223           *         -              | delay according to([durn_u8 +1]*2)ms
   5224           *         -              | range from 2ms to 512ms. default is 32ms
   5225           * BMA2x2_ACCEL_SLOPE_DURN| slope interrupt trigger
   5226           *         -              | if[durn_u8<1:0>+1] consecutive data points
   5227           *         -              | are above the slope interrupt threshold
   5228           * SLO_NO_MOT_DURN        | Refer data sheet for clear information
   5229           *
   5230           *
   5231           *	@return results of bus communication function
   5232           *	@retval 0 -> Success
   5233           *	@retval -1 -> Error
   5234           *
   5235           *
   5236           */
   5237          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_durn(u8 channel_u8,
   5238          u8 durn_u8)
   5239          {
   5240          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5241          		/*  Variable used to return value of
   5242          	communication routine*/
   5243          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5244          
   5245          	if (p_bma2x2 == BMA2x2_NULL)  {
   5246          		/* Check the struct p_bma2x2 is empty */
   5247          		return E_BMA2x2_NULL_PTR;
   5248          		}  else  {
   5249          		/* write duration data */
   5250          		switch (channel_u8)   {
   5251          		case BMA2x2_LOW_DURN:
   5252          			/*LOW DURATION*/
   5253          			data_u8 = durn_u8;
   5254          			com_rslt = bma2x2_write_reg(BMA2x2_LOW_DURN_ADDR,
   5255          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5256          		break;
   5257          		case BMA2x2_HIGH_DURN:
   5258          			/*HIGH DURATION*/
   5259          			data_u8 = durn_u8;
   5260          			com_rslt = bma2x2_write_reg(
   5261          			BMA2x2_HIGH_DURN_ADDR,
   5262          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5263          		break;
   5264          		case BMA2x2_SLOPE_DURN:
   5265          			/*SLOPE DURATION*/
   5266          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5267          			(p_bma2x2->dev_addr,
   5268          			BMA2x2_SLOPE_DURN_REG,
   5269          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5270          			data_u8 = BMA2x2_SET_BITSLICE
   5271          			(data_u8, BMA2x2_SLOPE_DURN, durn_u8);
   5272          			com_rslt += bma2x2_write_reg(
   5273          			BMA2x2_SLOPE_DURN_REG,
   5274          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5275          		break;
   5276          		case BMA2x2_SLOW_NO_MOTION_DURN:
   5277          			/*SLO NO MOT DURATION*/
   5278          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5279          			(p_bma2x2->dev_addr,
   5280          			BMA2x2_SLOW_NO_MOTION_DURN_REG,
   5281          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5282          			data_u8 = BMA2x2_SET_BITSLICE
   5283          			(data_u8, BMA2x2_SLOW_NO_MOTION_DURN, durn_u8);
   5284          			com_rslt += bma2x2_write_reg(
   5285          			BMA2x2_SLOW_NO_MOTION_DURN_REG,
   5286          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5287          		break;
   5288          		default:
   5289          			com_rslt = E_OUT_OF_RANGE;
   5290          		break;
   5291          		}
   5292          	}
   5293          	return com_rslt;
   5294          }
   5295          /*!
   5296           * @brief This API is used to get the threshold of
   5297           *	Low, High, Slope and slow no motion interrupts in the registers
   5298           *	@note LOW_THRES		-> register 0x23 bit form 0 to 7
   5299           *	@note HIGH_THRES		-> register 0x26 bit form 0 to 7
   5300           *	@note SLOPE_THRES		-> register 0x28 bit form 0 to 7
   5301           *	@note SLO_NO_MOT_THRES -> register 0x29 bit form 0 to 7
   5302           *
   5303           *  @param channel_u8: The value of threshold selection
   5304           *     channel_u8   | result
   5305           *   -----------------| ------------------
   5306           *               0    | BMA2x2_ACCEL_LOW_THRES
   5307           *               1    | BMA2x2_ACCEL_HIGH_THRES
   5308           *               2    | BMA2x2_ACCEL_SLOPE_THRES
   5309           *               3    | BMA2x2_ACCEL_SLOW_NO_MOTION_THRES
   5310           *
   5311           *  @param thres_u8: The threshold value of selected interrupts
   5312           *
   5313           *	@note : LOW-G THRESHOLD
   5314           *     Threshold                    |    result
   5315           * ---------------------------------| ------------------
   5316           * BMA2x2_ACCEL_LOW_THRES           | Low-threshold interrupt trigger
   5317           *                                  | according to(thres_u8 * 7.81) mg
   5318           *                                  | range from 0g to 1.992g
   5319           *                                  | default is 375mg
   5320           *	@note : HIGH-G THRESHOLD
   5321           *	@note Threshold of high-g interrupt according to accel g range
   5322           *    g-range           |      High-g threshold
   5323           *  --------------------|----------------------------
   5324           *     2g               |    (thres_u8 * 7.81) mg
   5325           *     4g               |    (thres_u8 * 15.63) mg
   5326           *     8g               |    (thres_u8 * 31.25) mg
   5327           *     16g              |    (thres_u8 * 62.5) mg
   5328           *
   5329           *	@note : SLOPE THRESHOLD
   5330           *	@note Threshold of slope interrupt according to accel g range
   5331           *    g-range           |      Slope threshold
   5332           *  --------------------|----------------------------
   5333           *     2g               |    (thres_u8 * 3.19) mg
   5334           *     4g               |    (thres_u8 * 7.81) mg
   5335           *     8g               |    (thres_u8 * 15.63) mg
   5336           *     16g              |    (thres_u8 * 31.25) mg
   5337           *
   5338           *	@note : SLOW NO MOTION THRESHOLD
   5339           *	@note Threshold of slow no motion interrupt according to accel g range
   5340           *    g-range           |   slow no motion threshold
   5341           *  --------------------|----------------------------
   5342           *     2g               |    (thres_u8 * 3.19) mg
   5343           *     4g               |    (thres_u8 * 7.81) mg
   5344           *     8g               |    (thres_u8 * 15.63) mg
   5345           *     16g              |    (thres_u8 * 31.25) mg
   5346           *
   5347           *
   5348           *
   5349           *	@return results of bus communication function
   5350           *	@retval 0 -> Success
   5351           *	@retval -1 -> Error
   5352           *
   5353           *
   5354           */
   5355          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_thres(u8 channel_u8,
   5356          u8 *thres_u8)
   5357          {
   5358          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5359          	/*  Variable used to return value of
   5360          	communication routine*/
   5361          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5362          
   5363          	if (p_bma2x2 == BMA2x2_NULL) {
   5364          		/* Check the struct p_bma2x2 is empty */
   5365          		return E_BMA2x2_NULL_PTR;
   5366          		} else {
   5367          		switch (channel_u8) {
   5368          		/* Read the threshold value */
   5369          		case BMA2x2_LOW_THRES:
   5370          			/*LOW THRESHOLD*/
   5371          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5372          			(p_bma2x2->dev_addr, BMA2x2_LOW_THRES_ADDR,
   5373          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5374          			*thres_u8 = data_u8;
   5375          		break;
   5376          		case BMA2x2_HIGH_THRES:
   5377          			/*HIGH THRESHOLD*/
   5378          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5379          			(p_bma2x2->dev_addr,
   5380          			BMA2x2_HIGH_THRES_ADDR,
   5381          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5382          			*thres_u8 = data_u8;
   5383          		break;
   5384          		case BMA2x2_SLOPE_THRES:
   5385          			/*SLOPE THRESHOLD*/
   5386          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5387          			(p_bma2x2->dev_addr,
   5388          			BMA2x2_SLOPE_THRES_ADDR,
   5389          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5390          			*thres_u8 = data_u8;
   5391          		break;
   5392          		case BMA2x2_SLOW_NO_MOTION_THRES:
   5393          			/*SLO NO MOT THRESHOLD*/
   5394          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5395          			(p_bma2x2->dev_addr,
   5396          			BMA2x2_SLOW_NO_MOTION_THRES_ADDR,
   5397          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5398          			*thres_u8 = data_u8;
   5399          		break;
   5400          		default:
   5401          			com_rslt = E_OUT_OF_RANGE;
   5402          		break;
   5403          		}
   5404          	}
   5405          	return com_rslt;
   5406          }
   5407          /*!
   5408           * @brief This API is used to set the threshold of
   5409           *	Low, High, Slope and slow no motion interrupts in the registers
   5410           *	@note LOW_THRES		-> register 0x23 bit form 0 to 7
   5411           *	@note HIGH_THRES		-> register 0x26 bit form 0 to 7
   5412           *	@note SLOPE_THRES		-> register 0x28 bit form 0 to 7
   5413           *	@note SLO_NO_MOT_THRES -> register 0x29 bit form 0 to 7
   5414           *
   5415           *  @param channel_u8: The value of threshold selection
   5416           *     channel_u8   | result
   5417           *   -----------------| ------------------
   5418           *               0    | BMA2x2_ACCEL_LOW_THRES
   5419           *               1    | BMA2x2_ACCEL_HIGH_THRES
   5420           *               2    | BMA2x2_ACCEL_SLOPE_THRES
   5421           *               3    | BMA2x2_ACCEL_SLOW_NO_MOTION_THRES
   5422           *
   5423           *  @param thres_u8: The threshold value of selected interrupts
   5424           *
   5425           *	@note : LOW-G THRESHOLD
   5426           *     Threshold                    |    result
   5427           * ---------------------------------| ------------------
   5428           * BMA2x2_ACCEL_LOW_THRES           | Low-threshold interrupt trigger
   5429           *                                  | according to(thres_u8 * 7.81) mg
   5430           *                                  | range from 0g to 1.992g
   5431           *                                  | default is 375mg
   5432           *	@note : HIGH-G THRESHOLD
   5433           *	@note Threshold of high-g interrupt according to accel g range
   5434           *    g-range           |      High-g threshold
   5435           *  --------------------|----------------------------
   5436           *     2g               |    (thres_u8 * 7.81) mg
   5437           *     4g               |    (thres_u8 * 15.63) mg
   5438           *     8g               |    (thres_u8 * 31.25) mg
   5439           *     16g              |    (thres_u8 * 62.5) mg
   5440           *
   5441           *	@note : SLOPE THRESHOLD
   5442           *	@note Threshold of slope interrupt according to accel g range
   5443           *    g-range           |      Slope threshold
   5444           *  --------------------|----------------------------
   5445           *     2g               |    (thres_u8 * 3.19) mg
   5446           *     4g               |    (thres_u8 * 7.81) mg
   5447           *     8g               |    (thres_u8 * 15.63) mg
   5448           *     16g              |    (thres_u8 * 31.25) mg
   5449           *
   5450           *	@note : SLOW NO MOTION THRESHOLD
   5451           *	@note Threshold of slow no motion interrupt according to accel g range
   5452           *    g-range           |   slow no motion threshold
   5453           *  --------------------|----------------------------
   5454           *     2g               |    (thres_u8 * 3.19) mg
   5455           *     4g               |    (thres_u8 * 7.81) mg
   5456           *     8g               |    (thres_u8 * 15.63) mg
   5457           *     16g              |    (thres_u8 * 31.25) mg
   5458           *
   5459           *
   5460           *
   5461           *	@return results of bus communication function
   5462           *	@retval 0 -> Success
   5463           *	@retval -1 -> Error
   5464           *
   5465           *
   5466           */
   5467          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_thres(u8 channel_u8,
   5468          u8 thres_u8)
   5469          {
   5470          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5471          	/*  Variable used to return value of
   5472          	communication routine*/
   5473          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5474          
   5475          	if (p_bma2x2 == BMA2x2_NULL) {
   5476          		/* Check the struct p_bma2x2 is empty */
   5477          		return E_BMA2x2_NULL_PTR;
   5478          		} else {
   5479          		switch (channel_u8) {
   5480          		/* write the threshold value*/
   5481          		case BMA2x2_LOW_THRES:
   5482          			/*LOW THRESHOLD*/
   5483          			data_u8 = thres_u8;
   5484          			com_rslt = bma2x2_write_reg(
   5485          			BMA2x2_LOW_THRES_ADDR, &data_u8,
   5486          			BMA2x2_GEN_READ_WRITE_LENGTH);
   5487          		break;
   5488          		case BMA2x2_HIGH_THRES:
   5489          			/*HIGH THRESHOLD*/
   5490          			data_u8 = thres_u8;
   5491          			com_rslt = bma2x2_write_reg(
   5492          			BMA2x2_HIGH_THRES_ADDR, &data_u8,
   5493          			BMA2x2_GEN_READ_WRITE_LENGTH);
   5494          		break;
   5495          		case BMA2x2_SLOPE_THRES:
   5496          			/*SLOPE THRESHOLD*/
   5497          			data_u8 = thres_u8;
   5498          			com_rslt = bma2x2_write_reg(
   5499          			BMA2x2_SLOPE_THRES_ADDR, &data_u8,
   5500          			BMA2x2_GEN_READ_WRITE_LENGTH);
   5501          		break;
   5502          		case BMA2x2_SLOW_NO_MOTION_THRES:
   5503          			/*SLO NO MOT THRESHOLD*/
   5504          			data_u8 = thres_u8;
   5505          			com_rslt = bma2x2_write_reg(
   5506          			BMA2x2_SLOW_NO_MOTION_THRES_ADDR,
   5507          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5508          		break;
   5509          		default:
   5510          			com_rslt = E_OUT_OF_RANGE;
   5511          		break;
   5512          		}
   5513          	}
   5514          	return com_rslt;
   5515          }
   5516          /*!
   5517           *	@brief This API is used to get
   5518           *	the low high hysteresis in the registers 0x24
   5519           *	@note LOW_G_HYST  -> bit form 0 to 1
   5520           *	@note HIGH_G_HYST  -> bit from 6 to 7
   5521           *
   5522           *  @param channel_u8: The value of hysteresis selection
   5523           *     channel_u8   | result
   5524           *   -----------------| ------------------
   5525           *           0        | BMA2x2_ACCEL_LOW_G_HYST
   5526           *           1        | BMA2x2_ACCEL_HIGH_G_HYST
   5527           *
   5528           *  @param hyst_u8: The hysteresis data
   5529           *
   5530           *	@note LOW HYSTERESIS
   5531           *	@note Hysteresis of low-g interrupt according to (hyst_u8 * 125)mg
   5532           *
   5533           *	@note HIGH HYSTERESIS
   5534           *	@note High hysteresis depends on the accel range selection
   5535           *    g-range           |    High Hysteresis
   5536           *  --------------------|----------------------------
   5537           *     2g               |    (thres_u8 * 125) mg
   5538           *     4g               |    (thres_u8 * 250) mg
   5539           *     8g               |    (thres_u8 * 500) mg
   5540           *     16g              |    (thres_u8 * 1000) mg
   5541           *
   5542           *	@return results of bus communication function
   5543           *	@retval 0 -> Success
   5544           *	@retval -1 -> Error
   5545           *
   5546           *
   5547           */
   5548          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_low_high_g_hyst(u8 channel_u8,
   5549          u8 *hyst_u8)
   5550          {
   5551          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5552          	/*  Variable used to return value of
   5553          	communication routine*/
   5554          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5555          
   5556          	if (p_bma2x2 == BMA2x2_NULL) {
   5557          		/* Check the struct p_bma2x2 is empty */
   5558          		return E_BMA2x2_NULL_PTR;
   5559          		} else {
   5560          		switch (channel_u8) {
   5561          		/* read the hysteresis data */
   5562          		case BMA2x2_LOW_G_HYST:
   5563          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5564          			(p_bma2x2->dev_addr,
   5565          			BMA2x2_LOW_G_HYST_REG,
   5566          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5567          			*hyst_u8 = BMA2x2_GET_BITSLICE
   5568          			(data_u8, BMA2x2_LOW_G_HYST);
   5569          		break;
   5570          		case BMA2x2_HIGH_G_HYST:
   5571          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5572          			(p_bma2x2->dev_addr,
   5573          			BMA2x2_HIGH_G_HYST_REG,
   5574          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5575          			*hyst_u8 = BMA2x2_GET_BITSLICE
   5576          			(data_u8, BMA2x2_HIGH_G_HYST);
   5577          		break;
   5578          		default:
   5579          			com_rslt = E_OUT_OF_RANGE;
   5580          		break;
   5581          		}
   5582          	}
   5583          	return com_rslt;
   5584          }
   5585          /*!
   5586           *	@brief This API is used to set
   5587           *	the low high hysteresis in the registers 0x24
   5588           *	@note LOW_G_HYST  -> bit form 0 to 1
   5589           *	@note HIGH_G_HYST  -> bit from 6 to 7
   5590           *
   5591           *  @param channel_u8: The value of hysteresis selection
   5592           *     channel_u8   | result
   5593           *   -----------------| ------------------
   5594           *           0        | BMA2x2_ACCEL_LOW_G_HYST
   5595           *           1        | BMA2x2_ACCEL_HIGH_G_HYST
   5596           *
   5597           *  @param hyst_u8: The hysteresis data
   5598           *
   5599           *	@note LOW HYSTERESIS
   5600           *	@note Hysteresis of low-g interrupt according to (hyst_u8 * 125)mg
   5601           *
   5602           *	@note HIGH HYSTERESIS
   5603           *	@note High hysteresis depends on the accel range selection
   5604           *    g-range           |    High Hysteresis
   5605           *  --------------------|----------------------------
   5606           *     2g               |    (thres_u8 * 125) mg
   5607           *     4g               |    (thres_u8 * 250) mg
   5608           *     8g               |    (thres_u8 * 500) mg
   5609           *     16g              |    (thres_u8 * 1000) mg
   5610           *
   5611           *	@return results of bus communication function
   5612           *	@retval 0 -> Success
   5613           *	@retval -1 -> Error
   5614           *
   5615           *
   5616           */
   5617          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_low_high_g_hyst(u8 channel_u8,
   5618          u8 hyst_u8)
   5619          {
   5620          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5621          	/*  Variable used to return value of
   5622          	communication routine*/
   5623          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5624          
   5625          	if (p_bma2x2 == BMA2x2_NULL) {
   5626          		/* Check the struct p_bma2x2 is empty */
   5627          		return E_BMA2x2_NULL_PTR;
   5628          		} else {
   5629          		switch (channel_u8) {
   5630          		/* write the hysteresis data  */
   5631          		case BMA2x2_LOW_G_HYST:
   5632          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5633          			(p_bma2x2->dev_addr, BMA2x2_LOW_G_HYST_REG,
   5634          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5635          			data_u8 = BMA2x2_SET_BITSLICE
   5636          			(data_u8, BMA2x2_LOW_G_HYST, hyst_u8);
   5637          			com_rslt += bma2x2_write_reg(
   5638          			BMA2x2_LOW_G_HYST_REG,
   5639          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5640          		break;
   5641          		case BMA2x2_HIGH_G_HYST:
   5642          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5643          			(p_bma2x2->dev_addr,
   5644          			BMA2x2_HIGH_G_HYST_REG, &data_u8,
   5645          			BMA2x2_GEN_READ_WRITE_LENGTH);
   5646          			data_u8 = BMA2x2_SET_BITSLICE
   5647          			(data_u8, BMA2x2_HIGH_G_HYST, hyst_u8);
   5648          			com_rslt += bma2x2_write_reg(
   5649          			BMA2x2_HIGH_G_HYST_REG,
   5650          			&data_u8,  BMA2x2_GEN_READ_WRITE_LENGTH);
   5651          		break;
   5652          		default:
   5653          			com_rslt = E_OUT_OF_RANGE;
   5654          		break;
   5655          		}
   5656          	}
   5657          	return com_rslt;
   5658          }
   5659          /*!
   5660           *	@brief This API is used to get
   5661           *	low_g  mode in the registers 0x24 bit 2
   5662           *
   5663           *
   5664           *	@param low_g_mode_u8: The value of Low_G mode
   5665           *      low_g_mode_u8   |  g-result
   5666           *  --------------------|----------------------------
   5667           *     0x00             | LOW_G_SINGLE_AXIS_MODE
   5668           *     0x01             | LOW_G_SUMMING_MODE
   5669           *
   5670           *
   5671           *	@return results of bus communication function
   5672           *	@retval 0 -> Success
   5673           *	@retval -1 -> Error
   5674           *
   5675           *
   5676          */
   5677          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_low_g_mode(u8 *low_g_mode_u8)
   5678          {
   5679          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5680          	/*  Variable used to return value of
   5681          	communication routine*/
   5682          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5683          
   5684          	if (p_bma2x2 == BMA2x2_NULL) {
   5685          		/* Check the struct p_bma2x2 is empty */
   5686          		return E_BMA2x2_NULL_PTR;
   5687          		} else {
   5688          			/* read the low-g mode*/
   5689          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5690          			(p_bma2x2->dev_addr, BMA2x2_LOW_G_INTR_MODE_REG,
   5691          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5692          			*low_g_mode_u8 = BMA2x2_GET_BITSLICE(data_u8,
   5693          			BMA2x2_LOW_G_INTR_MODE);
   5694          		}
   5695          	return com_rslt;
   5696          }
   5697          /*!
   5698           *	@brief This API is used to set
   5699           *	low_g  mode in the registers 0x24 bit 2
   5700           *
   5701           *
   5702           *	@param low_g_mode_u8: The value of Low_G mode
   5703           *    low_g_mode_u8   |    result
   5704           *  --------------------|----------------------------
   5705           *     0x00             | LOW_G_SINGLE_AXIS_MODE
   5706           *     0x01             | LOW_G_SUMMING_MODE
   5707           *
   5708           *
   5709           *	@return results of bus communication function
   5710           *	@retval 0 -> Success
   5711           *	@retval -1 -> Error
   5712           *
   5713           *
   5714          */
   5715          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_low_g_mode(u8 low_g_mode_u8)
   5716          {
   5717          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5718          	/*  Variable used to return value of
   5719          	communication routine*/
   5720          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5721          
   5722          	if (p_bma2x2 == BMA2x2_NULL) {
   5723          		/* Check the struct p_bma2x2 is empty */
   5724          		return E_BMA2x2_NULL_PTR;
   5725          		} else {
   5726          			/* write the low-g mode*/
   5727          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5728          			(p_bma2x2->dev_addr,
   5729          			BMA2x2_LOW_G_INTR_MODE_REG, &data_u8,
   5730          			BMA2x2_GEN_READ_WRITE_LENGTH);
   5731          			data_u8 = BMA2x2_SET_BITSLICE
   5732          			(data_u8, BMA2x2_LOW_G_INTR_MODE, low_g_mode_u8);
   5733          			com_rslt += bma2x2_write_reg(
   5734          			BMA2x2_LOW_G_INTR_MODE_REG,
   5735          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5736          		}
   5737          	return com_rslt;
   5738          }
   5739          /*!
   5740           *	@brief This API is used to get
   5741           *	the tap duration in the register 0x2A bit form 0 to 2
   5742           *
   5743           *
   5744           *	@param tap_durn_u8: The value of tap duration
   5745           *    tap_durn_u8     |    result
   5746           *  --------------------|----------------------------
   5747           *     0x00             | TAP_DURN_50_MS
   5748           *     0x01             | TAP_DURN_100_MS
   5749           *     0x02             | TAP_DURN_150_MS
   5750           *     0x03             | TAP_DURN_200_MS
   5751           *     0x04             | TAP_DURN_250_MS
   5752           *     0x05             | TAP_DURN_375_MS
   5753           *     0x06             | TAP_DURN_500_MS
   5754           *     0x07             | TAP_DURN_700_MS
   5755           *
   5756           *
   5757           *
   5758           *	@return results of bus communication function
   5759           *	@retval 0 -> Success
   5760           *	@retval -1 -> Error
   5761           *
   5762           *
   5763           */
   5764          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_tap_durn(u8 *tap_durn_u8)
   5765          {
   5766          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5767          	/*  Variable used to return value of
   5768          	communication routine*/
   5769          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5770          
   5771          	if (p_bma2x2 == BMA2x2_NULL) {
   5772          		/* Check the struct p_bma2x2 is empty */
   5773          		return E_BMA2x2_NULL_PTR;
   5774          		} else {
   5775          			/* read the tap duration*/
   5776          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5777          			(p_bma2x2->dev_addr,
   5778          			BMA2x2_TAP_DURN_REG, &data_u8,
   5779          			BMA2x2_GEN_READ_WRITE_LENGTH);
   5780          			*tap_durn_u8 = BMA2x2_GET_BITSLICE
   5781          			(data_u8, BMA2x2_TAP_DURN);
   5782          		}
   5783          	return com_rslt;
   5784          }
   5785          /*!
   5786           *	@brief This API is used to set
   5787           *	the tap duration in the register 0x2A bit form 0 to 2
   5788           *
   5789           *
   5790           *	@param tap_durn_u8: The value of tap duration
   5791           *    tap_durn_u8     |    result
   5792           *  --------------------|----------------------
   5793           *     0x00             | TAP_DURN_50_MS
   5794           *     0x01             | TAP_DURN_100_MS
   5795           *     0x02             | TAP_DURN_150_MS
   5796           *     0x03             | TAP_DURN_200_MS
   5797           *     0x04             | TAP_DURN_250_MS
   5798           *     0x05             | TAP_DURN_375_MS
   5799           *     0x06             | TAP_DURN_500_MS
   5800           *     0x07             | TAP_DURN_700_MS
   5801           *
   5802           *
   5803           *
   5804           *	@return results of bus communication function
   5805           *	@retval 0 -> Success
   5806           *	@retval -1 -> Error
   5807           *
   5808           *
   5809           */
   5810          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_tap_durn(u8 tap_durn_u8)
   5811          {
   5812          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5813          	/*  Variable used to return value of
   5814          	communication routine*/
   5815          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5816          
   5817          	if (p_bma2x2 == BMA2x2_NULL) {
   5818          		/* Check the struct p_bma2x2 is empty */
   5819          		return E_BMA2x2_NULL_PTR;
   5820          		} else {
   5821          			/* write the tap duration */
   5822          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   5823          			p_bma2x2->dev_addr,
   5824          			BMA2x2_TAP_DURN_REG, &data_u8,
   5825          			BMA2x2_GEN_READ_WRITE_LENGTH);
   5826          			data_u8 = BMA2x2_SET_BITSLICE
   5827          			(data_u8, BMA2x2_TAP_DURN, tap_durn_u8);
   5828          			com_rslt += bma2x2_write_reg(
   5829          			BMA2x2_TAP_DURN_REG, &data_u8,
   5830          			BMA2x2_GEN_READ_WRITE_LENGTH);
   5831          		}
   5832          	return com_rslt;
   5833          }
   5834          /*!
   5835           *	@brief This API is used to get
   5836           *	the tap shock form the register 0x2A bit 6
   5837           *
   5838           *
   5839           *
   5840           *	@param tap_shock_u8: The value of tap shock
   5841           *    tap_shock_u8    |    result
   5842           *  --------------------|----------------------
   5843           *     0x00             | TAP_SHOCK_50_MS
   5844           *     0x01             | TAP_SHOCK_75_MS
   5845           *
   5846           *
   5847           *	@return results of bus communication function
   5848           *	@retval 0 -> Success
   5849           *	@retval -1 -> Error
   5850           *
   5851           *
   5852          */
   5853          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_tap_shock(u8 *tap_shock_u8)
   5854          {
   5855          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5856          	/*  Variable used to return value of
   5857          	communication routine*/
   5858          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5859          
   5860          	if (p_bma2x2 == BMA2x2_NULL) {
   5861          		/* Check the struct p_bma2x2 is empty */
   5862          		return E_BMA2x2_NULL_PTR;
   5863          		} else {
   5864          			/* read tap shock value */
   5865          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5866          			(p_bma2x2->dev_addr,
   5867          			BMA2x2_TAP_SHOCK_DURN_REG,
   5868          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5869          			*tap_shock_u8 = BMA2x2_GET_BITSLICE(data_u8,
   5870          			BMA2x2_TAP_SHOCK_DURN);
   5871          		}
   5872          	return com_rslt;
   5873          }
   5874          /*!
   5875           *	@brief This API is used to set
   5876           *	the tap shock form the register 0x2A bit 6
   5877           *
   5878           *
   5879           *
   5880           *	@param tap_shock_u8: The value of tap shock
   5881           *    tap_shock_u8    |    result
   5882           *  --------------------|----------------------
   5883           *     0x00             | TAP_SHOCK_50_MS
   5884           *     0x01             | TAP_SHOCK_75_MS
   5885           *
   5886           *
   5887           *	@return results of bus communication function
   5888           *	@retval 0 -> Success
   5889           *	@retval -1 -> Error
   5890           *
   5891           *
   5892          */
   5893          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_tap_shock(u8 tap_shock_u8)
   5894          {
   5895          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5896          	/*  Variable used to return value of
   5897          	communication routine*/
   5898          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5899          
   5900          	if (p_bma2x2 == BMA2x2_NULL) {
   5901          		/* Check the struct p_bma2x2 is empty */
   5902          		return E_BMA2x2_NULL_PTR;
   5903          		} else {
   5904          			/* write tap shock value*/
   5905          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5906          			(p_bma2x2->dev_addr,
   5907          			BMA2x2_TAP_SHOCK_DURN_REG, &data_u8,
   5908          			BMA2x2_GEN_READ_WRITE_LENGTH);
   5909          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   5910          			BMA2x2_TAP_SHOCK_DURN, tap_shock_u8);
   5911          			com_rslt += bma2x2_write_reg(
   5912          			BMA2x2_TAP_SHOCK_DURN_REG, &data_u8,
   5913          			BMA2x2_GEN_READ_WRITE_LENGTH);
   5914          		}
   5915          	return com_rslt;
   5916          }
   5917          /*!
   5918           *	@brief This API is used to get
   5919           *	the tap quiet in the register 0x2A bit 7
   5920           *
   5921           *
   5922           *
   5923           *  @param  tap_quiet_u8 : The value of tap quiet
   5924           *    tap_quiet_u8    |    result
   5925           *  --------------------|----------------------
   5926           *     0x00             | TAP_QUIET_30_MS
   5927           *     0x01             | TAP_QUIET_20_MS
   5928           *
   5929           *	@return results of bus communication function
   5930           *	@retval 0 -> Success
   5931           *	@retval -1 -> Error
   5932           *
   5933           *
   5934           */
   5935          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_tap_quiet(u8 *tap_quiet_u8)
   5936          {
   5937          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5938          		/*  Variable used to return value of
   5939          	communication routine*/
   5940          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5941          
   5942          	if (p_bma2x2 == BMA2x2_NULL) {
   5943          		/* Check the struct p_bma2x2 is empty */
   5944          		return E_BMA2x2_NULL_PTR;
   5945          		} else {
   5946          			/* read the tap quiet value*/
   5947          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5948          			(p_bma2x2->dev_addr,
   5949          			BMA2x2_TAP_QUIET_DURN_REG, &data_u8,
   5950          			BMA2x2_GEN_READ_WRITE_LENGTH);
   5951          			*tap_quiet_u8 = BMA2x2_GET_BITSLICE
   5952          			(data_u8, BMA2x2_TAP_QUIET_DURN);
   5953          		}
   5954          	return com_rslt;
   5955          }
   5956          /*!
   5957           *	@brief This API is used to set
   5958           *	the tap quiet in the register 0x2A bit 7
   5959           *
   5960           *
   5961           *
   5962           *  @param  tap_quiet_u8 : The value of tap quiet
   5963           *    tap_quiet_u8    |    result
   5964           *  --------------------|----------------------
   5965           *     0x00             | TAP_QUIET_30_MS
   5966           *     0x01             | TAP_QUIET_20_MS
   5967           *
   5968           *	@return results of bus communication function
   5969           *	@retval 0 -> Success
   5970           *	@retval -1 -> Error
   5971           *
   5972           *
   5973           */
   5974          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_tap_quiet(u8 tap_quiet_u8)
   5975          {
   5976          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5977          		/*  Variable used to return value of
   5978          	communication routine*/
   5979          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5980          
   5981          	if (p_bma2x2 == BMA2x2_NULL) {
   5982          		/* Check the struct p_bma2x2 is empty */
   5983          		return E_BMA2x2_NULL_PTR;
   5984          		} else {
   5985          			/* write the tap quiet value*/
   5986          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5987          			(p_bma2x2->dev_addr,
   5988          			BMA2x2_TAP_QUIET_DURN_REG,
   5989          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5990          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   5991          			BMA2x2_TAP_QUIET_DURN, tap_quiet_u8);
   5992          			com_rslt += bma2x2_write_reg(
   5993          			BMA2x2_TAP_QUIET_DURN_REG,
   5994          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5995          		}
   5996          	return com_rslt;
   5997          }
   5998          /*!
   5999           *	@brief This API is used to get
   6000           *	the tap threshold in the register 0x2B bit from 0 to 4
   6001           *
   6002           *
   6003           *
   6004           *  @param tap_thres_u8 : The value of tap threshold
   6005           *  @note Tap threshold of single and double tap corresponding
   6006           *     to accel range
   6007           *     range            |    Tap threshold
   6008           *  --------------------|----------------------
   6009           *     2g               | (tap_thres_u8 * 62.5)mg
   6010           *     4g               | (tap_thres_u8 * 125)mg
   6011           *     8g               | (tap_thres_u8 * 250)mg
   6012           *     16g              | (tap_thres_u8 * 500)mg
   6013           *
   6014           *
   6015           *	@return results of bus communication function
   6016           *	@retval 0 -> Success
   6017           *	@retval -1 -> Error
   6018           *
   6019           *
   6020           */
   6021          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_tap_thres(u8 *tap_thres_u8)
   6022          {
   6023          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6024          	/*  Variable used to return value of
   6025          	communication routine*/
   6026          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6027          
   6028          	if (p_bma2x2 == BMA2x2_NULL) {
   6029          		/* Check the struct p_bma2x2 is empty */
   6030          		return E_BMA2x2_NULL_PTR;
   6031          		} else {
   6032          			/* read the tap threshold*/
   6033          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6034          			(p_bma2x2->dev_addr,
   6035          			BMA2x2_TAP_THRES_REG,
   6036          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6037          			*tap_thres_u8 = BMA2x2_GET_BITSLICE
   6038          			(data_u8, BMA2x2_TAP_THRES);
   6039          		}
   6040          	return com_rslt;
   6041          }
   6042          /*!
   6043           *	@brief This API is used to set
   6044           *	the tap threshold in the register 0x2B bit from 0 to 4
   6045           *
   6046           *
   6047           *
   6048           *  @param tap_thres_u8 : The value of tap threshold
   6049           *	@note Tap threshold of single and double tap corresponding to accel range
   6050           *     range            |    Tap threshold
   6051           *  --------------------|----------------------
   6052           *     2g               | (tap_thres_u8 * 62.5)mg
   6053           *     4g               | (tap_thres_u8 * 125)mg
   6054           *     8g               | (tap_thres_u8 * 250)mg
   6055           *     16g              | (tap_thres_u8 * 500)mg
   6056           *
   6057           *
   6058           *	@return results of bus communication function
   6059           *	@retval 0 -> Success
   6060           *	@retval -1 -> Error
   6061           *
   6062           *
   6063           */
   6064          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_tap_thres(u8 tap_thres_u8)
   6065          {
   6066          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6067          	/*  Variable used to return value of
   6068          	communication routine*/
   6069          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6070          
   6071          	if (p_bma2x2 == BMA2x2_NULL) {
   6072          		/* Check the struct p_bma2x2 is empty */
   6073          		return E_BMA2x2_NULL_PTR;
   6074          		} else {
   6075          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6076          			(p_bma2x2->dev_addr,
   6077          			BMA2x2_TAP_THRES_REG, &data_u8,
   6078          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6079          			data_u8 = BMA2x2_SET_BITSLICE
   6080          			(data_u8, BMA2x2_TAP_THRES, tap_thres_u8);
   6081          			com_rslt += bma2x2_write_reg(
   6082          			BMA2x2_TAP_THRES_REG, &data_u8,
   6083          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6084          		}
   6085          	return com_rslt;
   6086          }
   6087          /*!
   6088           *	@brief This API is used to get
   6089           *	the tap sample in the register 0x2B bit 6 and 7
   6090           *
   6091           *
   6092           *
   6093           *  @param   *tap_sample_u8 : The value of tap sample
   6094           *     tap_sample_u8  |    result
   6095           *  --------------------|----------------------
   6096           *     0x00             | 2 samples
   6097           *     0x01             | 4 samples
   6098           *     0x02             | 8 samples
   6099           *     0x03             | 16 samples
   6100           *
   6101           *
   6102           *	@return results of bus communication function
   6103           *	@retval 0 -> Success
   6104           *	@retval -1 -> Error
   6105           *
   6106           *
   6107           */
   6108          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_tap_sample(u8 *tap_sample_u8)
   6109          {
   6110          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6111          		/*  Variable used to return value of
   6112          	communication routine*/
   6113          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6114          
   6115          	if (p_bma2x2 == BMA2x2_NULL) {
   6116          		/* Check the struct p_bma2x2 is empty */
   6117          		return E_BMA2x2_NULL_PTR;
   6118          		} else {
   6119          			/* read tap samples */
   6120          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6121          			(p_bma2x2->dev_addr,
   6122          			BMA2x2_TAP_SAMPLES_REG, &data_u8,
   6123          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6124          			*tap_sample_u8 = BMA2x2_GET_BITSLICE
   6125          			(data_u8, BMA2x2_TAP_SAMPLES);
   6126          		}
   6127          	return com_rslt;
   6128          }
   6129          /*!
   6130           *	@brief This API is used to set
   6131           *	the tap sample in the register 0x2B bit 6 and 7
   6132           *
   6133           *
   6134           *
   6135           *  @param   *tap_sample_u8 : The value of tap sample
   6136           *     tap_sample_u8  |    result
   6137           *  --------------------|----------------------
   6138           *     0x00             | 2 samples
   6139           *     0x01             | 4 samples
   6140           *     0x02             | 8 samples
   6141           *     0x03             | 16 samples
   6142           *
   6143           *
   6144           *	@return results of bus communication function
   6145           *	@retval 0 -> Success
   6146           *	@retval -1 -> Error
   6147           *
   6148           *
   6149           */
   6150          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_tap_sample(u8 tap_sample_u8)
   6151          {
   6152          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6153          	/*  Variable used to return value of
   6154          	communication routine*/
   6155          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6156          
   6157          	if (p_bma2x2 == BMA2x2_NULL) {
   6158          		/* Check the struct p_bma2x2 is empty */
   6159          		return E_BMA2x2_NULL_PTR;
   6160          		} else {
   6161          			/* write tap samples */
   6162          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6163          			(p_bma2x2->dev_addr, BMA2x2_TAP_SAMPLES_REG,
   6164          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6165          			data_u8 = BMA2x2_SET_BITSLICE
   6166          			(data_u8, BMA2x2_TAP_SAMPLES, tap_sample_u8);
   6167          			com_rslt += bma2x2_write_reg(
   6168          			BMA2x2_TAP_SAMPLES_REG, &data_u8,
   6169          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6170          		}
   6171          	return com_rslt;
   6172          }
   6173          /*!
   6174           *	@brief This API is used to get
   6175           *	the orient mode in the register 0x2C bit 0 and 1
   6176           *
   6177           *
   6178           *
   6179           *  @param orient_mode_u8 : The value of orient mode
   6180           *     orient_mode_u8 |    result
   6181           *  --------------------|------------------
   6182           *     0x00             | symmetrical
   6183           *     0x01             | high asymmetrical
   6184           *     0x02             | low asymmetrical
   6185           *     0x03             | symmetrical
   6186           *
   6187           *
   6188           *
   6189           *	@return results of bus communication function
   6190           *	@retval 0 -> Success
   6191           *	@retval -1 -> Error
   6192           *
   6193           *
   6194          */
   6195          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_orient_mode(u8 *orient_mode_u8)
   6196          {
   6197          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6198          	/*  Variable used to return value of
   6199          	communication routine*/
   6200          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6201          
   6202          	if (p_bma2x2 == BMA2x2_NULL) {
   6203          		/* Check the struct p_bma2x2 is empty */
   6204          		return E_BMA2x2_NULL_PTR;
   6205          		} else {
   6206          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   6207          			p_bma2x2->dev_addr,
   6208          			BMA2x2_ORIENT_MODE_REG, &data_u8,
   6209          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6210          			*orient_mode_u8 = BMA2x2_GET_BITSLICE(
   6211          			data_u8, BMA2x2_ORIENT_MODE);
   6212          		}
   6213          	return com_rslt;
   6214          }
   6215          /*!
   6216           *	@brief This API is used to set
   6217           *	the orient mode in the register 0x2C bit 0 and 1
   6218           *
   6219           *
   6220           *
   6221           *  @param orient_mode_u8 : The value of orient mode
   6222           *     orient_mode_u8 |    result
   6223           *  --------------------|------------------
   6224           *     0x00             | symmetrical
   6225           *     0x01             | high asymmetrical
   6226           *     0x02             | low asymmetrical
   6227           *     0x03             | symmetrical
   6228           *
   6229           *
   6230           *
   6231           *	@return results of bus communication function
   6232           *	@retval 0 -> Success
   6233           *	@retval -1 -> Error
   6234           *
   6235           *
   6236          */
   6237          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_orient_mode(u8 orient_mode_u8)
   6238          {
   6239          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6240          	/*  Variable used to return value of
   6241          	communication routine*/
   6242          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6243          
   6244          	if (p_bma2x2 == BMA2x2_NULL) {
   6245          		/* Check the struct p_bma2x2 is empty */
   6246          		return E_BMA2x2_NULL_PTR;
   6247          		} else {
   6248          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6249          			(p_bma2x2->dev_addr,
   6250          			BMA2x2_ORIENT_MODE_REG, &data_u8,
   6251          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6252          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   6253          			BMA2x2_ORIENT_MODE, orient_mode_u8);
   6254          			com_rslt += bma2x2_write_reg(
   6255          			BMA2x2_ORIENT_MODE_REG, &data_u8,
   6256          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6257          		}
   6258          	return com_rslt;
   6259          }
   6260          /*!
   6261           *	@brief This API is used to get
   6262           *	the orient block in the register 0x2C bit 2 and 3
   6263           *
   6264           *
   6265           *
   6266           *	@param orient_block_u8 : The value of orient block
   6267           *     orient_mode_u8 |    result
   6268           *  --------------------|------------------
   6269           *     0x00             | no blocking
   6270           *     0x01             | theta blocking or
   6271           *                      | acceleration slope in any axis > 1.5g
   6272           *     0x02             | theta blocking or
   6273           *                      | acceleration slope in any axis > 0.2g
   6274           *                      | acceleration in any axis > 1.5g
   6275           *     0x03             | theta blocking or
   6276           *                      | acceleration slope in any axis > 0.4g
   6277           *                      | acceleration in any axis > 1.5g
   6278           *                      | value of orient is not stable for at lease 100ms
   6279           *
   6280           *
   6281           *	@return results of bus communication function
   6282           *	@retval 0 -> Success
   6283           *	@retval -1 -> Error
   6284           *
   6285           *
   6286           */
   6287          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_orient_block(
   6288          u8 *orient_block_u8)
   6289          {
   6290          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6291          		/*  Variable used to return value of
   6292          	communication routine*/
   6293          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6294          
   6295          	if (p_bma2x2 == BMA2x2_NULL) {
   6296          		/* Check the struct p_bma2x2 is empty */
   6297          		return E_BMA2x2_NULL_PTR;
   6298          		} else {
   6299          			/* Read the orient block data */
   6300          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6301          			(p_bma2x2->dev_addr,
   6302          			BMA2x2_ORIENT_BLOCK_REG, &data_u8,
   6303          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6304          			*orient_block_u8 = BMA2x2_GET_BITSLICE
   6305          			(data_u8, BMA2x2_ORIENT_BLOCK);
   6306          		}
   6307          	return com_rslt;
   6308          }
   6309          /*!
   6310           *	@brief This API is used to set
   6311           *	the orient block in the register 0x2C bit 2 and 3
   6312           *
   6313           *
   6314           *
   6315           *	@param orient_block_u8 : The value of orient block
   6316           *     orient_mode_u8 |    result
   6317           *  --------------------|------------------
   6318           *     0x00             | no blocking
   6319           *     0x01             | theta blocking or
   6320           *                      | acceleration slope in any axis > 1.5g
   6321           *     0x02             | theta blocking or
   6322           *                      | acceleration slope in any axis > 0.2g
   6323           *                      | acceleration in any axis > 1.5g
   6324           *     0x03             | theta blocking or
   6325           *                      | acceleration slope in any axis > 0.4g
   6326           *                      | acceleration in any axis > 1.5g
   6327           *                      | value of orient is not stable for at lease 100ms
   6328           *
   6329           *
   6330           *	@return results of bus communication function
   6331           *	@retval 0 -> Success
   6332           *	@retval -1 -> Error
   6333           *
   6334           *
   6335           */
   6336          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_orient_block(u8 orient_block_u8)
   6337          {
   6338          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6339          	/*  Variable used to return value of
   6340          	communication routine*/
   6341          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6342          
   6343          	if (p_bma2x2 == BMA2x2_NULL) {
   6344          		/* Check the struct p_bma2x2 is empty */
   6345          		return E_BMA2x2_NULL_PTR;
   6346          		} else {
   6347          			/* write the orient block data */
   6348          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6349          			(p_bma2x2->dev_addr,
   6350          			BMA2x2_ORIENT_BLOCK_REG, &data_u8,
   6351          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6352          			data_u8 = BMA2x2_SET_BITSLICE
   6353          			(data_u8, BMA2x2_ORIENT_BLOCK, orient_block_u8);
   6354          			com_rslt += bma2x2_write_reg(
   6355          			BMA2x2_ORIENT_BLOCK_REG, &data_u8,
   6356          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6357          		}
   6358          	return com_rslt;
   6359          }
   6360          /*!
   6361           *	@brief This API is used to get
   6362           *	the orient hysteresis in the register 0x2C bit 4 to 6
   6363           *
   6364           *
   6365           *
   6366           *  @param orient_hyst_u8 : The value of orient hysteresis
   6367           *
   6368           *
   6369           *
   6370           *	@return results of bus communication function
   6371           *	@retval 0 -> Success
   6372           *	@retval -1 -> Error
   6373           *
   6374           *
   6375           */
   6376          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_orient_hyst(u8 *orient_hyst_u8)
   6377          {
   6378          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6379          	/*  Variable used to return value of
   6380          	communication routine*/
   6381          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6382          
   6383          	if (p_bma2x2 == BMA2x2_NULL) {
   6384          		/* Check the struct p_bma2x2 is empty */
   6385          		return E_BMA2x2_NULL_PTR;
   6386          		} else {
   6387          			/* read the orient hysteresis data*/
   6388          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6389          			(p_bma2x2->dev_addr,
   6390          			BMA2x2_ORIENT_HYST_REG, &data_u8,
   6391          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6392          			*orient_hyst_u8 = BMA2x2_GET_BITSLICE
   6393          			(data_u8, BMA2x2_ORIENT_HYST);
   6394          		}
   6395          	return com_rslt;
   6396          }
   6397          /*!
   6398           *	@brief This API is used to set
   6399           *	the orient hysteresis in the register 0x2C bit 4 to 6
   6400           *
   6401           *
   6402           *
   6403           *  @param orient_hyst_u8 : The value of orient hysteresis
   6404           *
   6405           *
   6406           *
   6407           *	@return results of bus communication function
   6408           *	@retval 0 -> Success
   6409           *	@retval -1 -> Error
   6410           *
   6411           *
   6412           */
   6413          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_orient_hyst(u8 orient_hyst_u8)
   6414          {
   6415          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6416          	/*  Variable used to return value of
   6417          	communication routine*/
   6418          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6419          
   6420          	if (p_bma2x2 == BMA2x2_NULL) {
   6421          		/* Check the struct p_bma2x2 is empty */
   6422          		return E_BMA2x2_NULL_PTR;
   6423          		} else {
   6424          			/* write the orient hysteresis data */
   6425          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6426          			(p_bma2x2->dev_addr,
   6427          			BMA2x2_ORIENT_HYST_REG, &data_u8,
   6428          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6429          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   6430          			BMA2x2_ORIENT_HYST, orient_hyst_u8);
   6431          			com_rslt += bma2x2_write_reg(
   6432          			BMA2x2_ORIENT_HYST_REG,
   6433          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6434          		}
   6435          	return com_rslt;
   6436          }
   6437          /*!
   6438           *	@brief  This API is used to get
   6439           *	the theta value of orient and flat interrupts
   6440           *	@note ORIENT_THETA -> register 0x2D bit 0 to 5
   6441           *	@note FLAT_THETA   -> register 0x2E bit 0 to 5
   6442           *
   6443           *  @param channel_u8: The value of theta selection
   6444           *     channel_u8     |    result
   6445           *  --------------------|------------------
   6446           *     0x00             | BMA2x2_ACCEL_ORIENT_THETA
   6447           *     0x01             | BMA2x2_ACCEL_FLAT_THETA
   6448           * @note
   6449           * @note FLAT_THETA : Defines a blocking angle between 0 deg to 44.8 deg
   6450           * @note ORIENT_THETA : Defines threshold for detection of flat position
   6451           *                in range from 0 deg to 44.8 deg
   6452           *
   6453           *  @param theta_u8: The value of theta
   6454           *
   6455           *	@return results of bus communication function
   6456           *	@retval 0 -> Success
   6457           *	@retval -1 -> Error
   6458           *
   6459           *
   6460           */
   6461          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_theta(u8 channel_u8,
   6462          u8 *theta_u8)
   6463          {
   6464          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6465          	/*  Variable used to return value of
   6466          	communication routine*/
   6467          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6468          
   6469          	if (p_bma2x2 == BMA2x2_NULL) {
   6470          		/* Check the struct p_bma2x2 is empty */
   6471          		return E_BMA2x2_NULL_PTR;
   6472          		} else {
   6473          		switch (channel_u8) {
   6474          		/* write theta value*/
   6475          		case BMA2x2_ORIENT_THETA:
   6476          			/*ORIENT THETA*/
   6477          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6478          			(p_bma2x2->dev_addr,
   6479          			BMA2x2_THETA_BLOCK_REG, &data_u8,
   6480          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6481          			*theta_u8 = BMA2x2_GET_BITSLICE
   6482          			(data_u8, BMA2x2_THETA_BLOCK);
   6483          		break;
   6484          		case BMA2x2_FLAT_THETA:
   6485          			/*FLAT THETA*/
   6486          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6487          			(p_bma2x2->dev_addr,
   6488          			BMA2x2_THETA_FLAT_REG,
   6489          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6490          			*theta_u8 = data_u8;
   6491          		break;
   6492          		default:
   6493          			com_rslt = E_OUT_OF_RANGE;
   6494          		break;
   6495          		}
   6496          	}
   6497          	return com_rslt;
   6498          }
   6499          /*!
   6500           *	@brief  This API is used to set
   6501           *	the theta value of orient and flat interrupts
   6502           *	@note ORIENT_THETA -> register 0x2D bit 0 to 5
   6503           *	@note FLAT_THETA   -> register 0x2E bit 0 to 5
   6504           *
   6505           *  @param channel_u8: The value of theta selection
   6506           *     channel_u8     |    result
   6507           *  --------------------|------------------
   6508           *     0x00             | BMA2x2_ACCEL_ORIENT_THETA
   6509           *     0x01             | BMA2x2_ACCEL_FLAT_THETA
   6510           * @note
   6511           * @note FLAT_THETA : Defines a blocking angle between 0 deg to 44.8 deg
   6512           * @note ORIENT_THETA : Defines threshold for detection of flat position
   6513           *                in range from 0 deg to 44.8 deg
   6514           *
   6515           *  @param theta_u8: The value of theta
   6516           *
   6517           *	@return results of bus communication function
   6518           *	@retval 0 -> Success
   6519           *	@retval -1 -> Error
   6520           *
   6521           *
   6522           */
   6523          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_theta(u8 channel_u8,
   6524          u8 theta_u8)
   6525          {
   6526          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6527          	/*  Variable used to return value of
   6528          	communication routine*/
   6529          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6530          
   6531          	if (p_bma2x2 == BMA2x2_NULL) {
   6532          		/* Check the struct p_bma2x2 is empty */
   6533          		return E_BMA2x2_NULL_PTR;
   6534          		} else {
   6535          		switch (channel_u8) {
   6536          		/* write flat value */
   6537          		case BMA2x2_ORIENT_THETA:
   6538          			/*ORIENT THETA*/
   6539          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6540          			(p_bma2x2->dev_addr,
   6541          			BMA2x2_THETA_BLOCK_REG, &data_u8,
   6542          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6543          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   6544          			BMA2x2_THETA_BLOCK, theta_u8);
   6545          			com_rslt += bma2x2_write_reg(
   6546          			BMA2x2_THETA_BLOCK_REG,
   6547          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6548          		break;
   6549          		case BMA2x2_FLAT_THETA:
   6550          			/*FLAT THETA*/
   6551          			data_u8 = theta_u8;
   6552          			com_rslt = bma2x2_write_reg(
   6553          			BMA2x2_THETA_FLAT_REG,
   6554          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6555          		break;
   6556          		default:
   6557          			com_rslt = E_OUT_OF_RANGE;
   6558          		break;
   6559          		}
   6560          	}
   6561          	return com_rslt;
   6562          }
   6563          /*!
   6564           *	@brief This API is used to get
   6565           *  the interrupt enable of orient ud_enable in the register 0x2D bit 6
   6566           *
   6567           *
   6568           *  @param orient_enable_u8 : The value of orient ud_enable
   6569           *     orient_enable_u8     |    result
   6570           *  ------------------------- |------------------
   6571           *     0x00                   | Generates Interrupt
   6572           *     0x01                   | Do not generate interrupt
   6573           *
   6574           *
   6575           *
   6576           *	@return results of bus communication function
   6577           *	@retval 0 -> Success
   6578           *	@retval -1 -> Error
   6579           *
   6580           *
   6581           */
   6582          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_orient_enable(u8 *orient_enable_u8)
   6583          {
   6584          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6585          	/*  Variable used to return value of
   6586          	communication routine*/
   6587          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6588          
   6589          	if (p_bma2x2 == BMA2x2_NULL) {
   6590          		/* Check the struct p_bma2x2 is empty */
   6591          		return E_BMA2x2_NULL_PTR;
   6592          		} else {
   6593          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6594          			(p_bma2x2->dev_addr,
   6595          			BMA2x2_ORIENT_UD_ENABLE_REG,
   6596          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6597          			*orient_enable_u8 = BMA2x2_GET_BITSLICE
   6598          			(data_u8, BMA2x2_ORIENT_UD_ENABLE);
   6599          		}
   6600          	return com_rslt;
   6601          }
   6602          /*!
   6603           *	@brief This API is used to set
   6604           *  the interrupt enable of orient ud_enable in the register 0x2D bit 6
   6605           *
   6606           *
   6607           *  @param orient_enable_u8 : The value of orient ud_enable
   6608           *     orient_enable_u8     |    result
   6609           *  ------------------------- |------------------
   6610           *     0x00                   | Generates Interrupt
   6611           *     0x01                   | Do not generate interrupt
   6612           *
   6613           *
   6614           *
   6615           *	@return results of bus communication function
   6616           *	@retval 0 -> Success
   6617           *	@retval -1 -> Error
   6618           *
   6619           *
   6620           */
   6621          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_orient_enable(u8 orient_enable_u8)
   6622          {
   6623          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6624          	/*  Variable used to return value of
   6625          	communication routine*/
   6626          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6627          
   6628          	if (p_bma2x2 == BMA2x2_NULL) {
   6629          		/* Check the struct p_bma2x2 is empty */
   6630          		return E_BMA2x2_NULL_PTR;
   6631          		} else {
   6632          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6633          			(p_bma2x2->dev_addr,
   6634          			BMA2x2_ORIENT_UD_ENABLE_REG,
   6635          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6636          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   6637          			BMA2x2_ORIENT_UD_ENABLE, orient_enable_u8);
   6638          			com_rslt += bma2x2_write_reg(
   6639          			BMA2x2_ORIENT_UD_ENABLE_REG,
   6640          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6641          		}
   6642          	return com_rslt;
   6643          }
   6644          /*!
   6645           *	@brief This API is used to get
   6646           *	the interrupt enable of flat hysteresis("flat_hy)
   6647           *	in the register 0x2F bit 0 to 2
   6648           *
   6649           *
   6650           *
   6651           *
   6652           *  @param flat_hyst_u8 : The value of flat hysteresis
   6653           *
   6654           *
   6655           *
   6656           *	@return results of bus communication function
   6657           *	@retval 0 -> Success
   6658           *	@retval -1 -> Error
   6659           *
   6660           *
   6661           */
   6662          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_flat_hyst(u8 *flat_hyst_u8)
   6663          {
   6664          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6665          	/*  Variable used to return value of
   6666          	communication routine*/
   6667          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6668          
   6669          	if (p_bma2x2 == BMA2x2_NULL) {
   6670          		/* Check the struct p_bma2x2 is empty */
   6671          		return E_BMA2x2_NULL_PTR;
   6672          		} else {
   6673          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6674          			(p_bma2x2->dev_addr,
   6675          			BMA2x2_FLAT_HYST_REG, &data_u8,
   6676          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6677          			*flat_hyst_u8 = BMA2x2_GET_BITSLICE
   6678          			(data_u8, BMA2x2_FLAT_HYST);
   6679          		}
   6680          	return com_rslt;
   6681          }
   6682          /*!
   6683           *	@brief This API is used to set
   6684           *	the interrupt enable of flat hysteresis("flat_hy)
   6685           *	in the register 0x2F bit 0 to 2
   6686           *
   6687           *
   6688           *
   6689           *
   6690           *  @param flat_hyst_u8 : The value of flat hysteresis
   6691           *
   6692           *
   6693           *
   6694           *	@return results of bus communication function
   6695           *	@retval 0 -> Success
   6696           *	@retval -1 -> Error
   6697           *
   6698           *
   6699           */
   6700          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_flat_hyst(u8 flat_hyst_u8)
   6701          {
   6702          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6703          	/*  Variable used to return value of
   6704          	communication routine*/
   6705          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6706          
   6707          	if (p_bma2x2 == BMA2x2_NULL) {
   6708          		/* Check the struct p_bma2x2 is empty */
   6709          		return E_BMA2x2_NULL_PTR;
   6710          		} else {
   6711          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   6712          			p_bma2x2->dev_addr,
   6713          			BMA2x2_FLAT_HYST_REG,
   6714          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6715          			data_u8 = BMA2x2_SET_BITSLICE
   6716          			(data_u8, BMA2x2_FLAT_HYST, flat_hyst_u8);
   6717          			com_rslt += bma2x2_write_reg(
   6718          			BMA2x2_FLAT_HYST_REG, &data_u8,
   6719          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6720          		}
   6721          	return com_rslt;
   6722          }
   6723          /*!
   6724           *	@brief This API is used to get
   6725           *  the interrupt enable of flat hold time(flat_hold_time)
   6726           *	in the register 0x2F bit 4 and 5
   6727           *
   6728           *
   6729           *  @param  flat_hold_time_u8 : The value of flat hold time
   6730           *     flat_hold_time_u8    |    result
   6731           *  ------------------------- |------------------
   6732           *     0x00                   | 0ms
   6733           *     0x01                   | 512ms
   6734           *     0x02                   | 1024ms
   6735           *     0x03                   | 2048ms
   6736           *
   6737           *
   6738           *
   6739           *	@return results of bus communication function
   6740           *	@retval 0 -> Success
   6741           *	@retval -1 -> Error
   6742           *
   6743           *
   6744           */
   6745          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_flat_hold_time(
   6746          u8 *flat_hold_time_u8)
   6747          {
   6748          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6749          	/*  Variable used to return value of
   6750          	communication routine*/
   6751          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6752          
   6753          	if (p_bma2x2 == BMA2x2_NULL) {
   6754          		/* Check the struct p_bma2x2 is empty */
   6755          		return E_BMA2x2_NULL_PTR;
   6756          		} else {
   6757          			/* read the flat hold time */
   6758          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6759          			(p_bma2x2->dev_addr,
   6760          			BMA2x2_FLAT_HOLD_TIME_REG,
   6761          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6762          			*flat_hold_time_u8 = BMA2x2_GET_BITSLICE
   6763          			(data_u8, BMA2x2_FLAT_HOLD_TIME);
   6764          		}
   6765          	return com_rslt;
   6766          }
   6767          /*!
   6768           *	@brief This API is used to set
   6769           *  the interrupt enable of flat hold time(flat_hold_time)
   6770           *	in the register 0x2F bit 4 and 5
   6771           *
   6772           *
   6773           *  @param  flat_hold_time_u8 : The value of flat hold time
   6774           *     flat_hold_time_u8    |    result
   6775           *  ------------------------- |------------------
   6776           *     0x00                   | 0ms
   6777           *     0x01                   | 512ms
   6778           *     0x02                   | 1024ms
   6779           *     0x03                   | 2048ms
   6780           *
   6781           *
   6782           *
   6783           *	@return results of bus communication function
   6784           *	@retval 0 -> Success
   6785           *	@retval -1 -> Error
   6786           *
   6787           *
   6788           */
   6789          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_flat_hold_time(
   6790          u8 flat_hold_time_u8)
   6791          {
   6792          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6793          	/*  Variable used to return value of
   6794          	communication routine*/
   6795          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6796          
   6797          	if (p_bma2x2 == BMA2x2_NULL) {
   6798          		/* Check the struct p_bma2x2 is empty */
   6799          		return E_BMA2x2_NULL_PTR;
   6800          		} else {
   6801          			/* write the flat hold time */
   6802          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6803          			(p_bma2x2->dev_addr,
   6804          			BMA2x2_FLAT_HOLD_TIME_REG, &data_u8,
   6805          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6806          			data_u8 = BMA2x2_SET_BITSLICE
   6807          			(data_u8, BMA2x2_FLAT_HOLD_TIME, flat_hold_time_u8);
   6808          			com_rslt += bma2x2_write_reg(
   6809          			BMA2x2_FLAT_HOLD_TIME_REG, &data_u8,
   6810          			BMA2x2_GEN_READ_WRITE_LENGTH);
   6811          		}
   6812          	return com_rslt;
   6813          }
   6814          /*!
   6815           *	@brief This API is used to get
   6816           *	the fifo water mark level trigger in the register 0x30 bit from 0 to 5
   6817           *
   6818           *
   6819           *
   6820           *
   6821           *  @param fifo_wml_trig: The value of fifo watermark trigger level
   6822           *
   6823           *
   6824           *
   6825           *	@return results of bus communication function
   6826           *	@retval 0 -> Success
   6827           *	@retval -1 -> Error
   6828           *
   6829           *
   6830           */
   6831          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_wml_trig(
   6832          u8 *fifo_wml_trig)
   6833          {
   6834          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6835          	/*  Variable used to return value of
   6836          	communication routine*/
   6837          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6838          
   6839          	if (p_bma2x2 == BMA2x2_NULL) {
   6840          		/* Check the struct p_bma2x2 is empty */
   6841          		return E_BMA2x2_NULL_PTR;
   6842          		} else {
   6843          			/* read the fifo water mark trigger */
   6844          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6845          			(p_bma2x2->dev_addr,
   6846          			BMA2x2_FIFO_WML_TRIG_RETAIN_REG,
   6847          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6848          			*fifo_wml_trig = BMA2x2_GET_BITSLICE
   6849          			(data_u8, BMA2x2_FIFO_WML_TRIG_RETAIN);
   6850          		}
   6851          	return com_rslt;
   6852          }
   6853          /*!
   6854           *	@brief This API is used to set
   6855           *	the fifo water mark level trigger in the register 0x30 bit from 0 to 5
   6856           *
   6857           *
   6858           *
   6859           *
   6860           *  @param fifo_wml_trig: The value of fifo watermark trigger level
   6861           *
   6862           *
   6863           *
   6864           *	@return results of bus communication function
   6865           *	@retval 0 -> Success
   6866           *	@retval -1 -> Error
   6867           *
   6868           *
   6869           */
   6870          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_fifo_wml_trig(
   6871          u8 fifo_wml_trig)
   6872          {
   6873          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6874          	u8 power_mode = BMA2x2_INIT_VALUE;
   6875          	/*  Variable used to return value of
   6876          	communication routine*/
   6877          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6878          
   6879          	if (p_bma2x2 == BMA2x2_NULL) {
   6880          		/* Check the struct p_bma2x2 is empty */
   6881          		return E_BMA2x2_NULL_PTR;
   6882          		} else {
   6883          		if (fifo_wml_trig < BMA2x2_FIFO_WML_RANGE) {
   6884          			/* write the fifo watermark trigger*/
   6885          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6886          			(p_bma2x2->dev_addr,
   6887          			BMA2x2_FIFO_WML_TRIG_RETAIN_REG,
   6888          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6889          			data_u8 = BMA2x2_SET_BITSLICE
   6890          			(data_u8, BMA2x2_FIFO_WML_TRIG_RETAIN,
   6891          			fifo_wml_trig);
   6892          			com_rslt += bma2x2_get_power_mode(&power_mode);
   6893          			com_rslt += bma2x2_set_power_mode(BMA2x2_MODE_STANDBY);
   6894          			com_rslt += bma2x2_write_reg(
   6895          			BMA2x2_FIFO_WML_TRIG_RETAIN_REG,
   6896          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6897          			com_rslt += bma2x2_set_power_mode(power_mode);
   6898          		} else {
   6899          		com_rslt = E_OUT_OF_RANGE;
   6900          		}
   6901          	}
   6902          	return com_rslt;
   6903          }
   6904          /*!
   6905           *	@brief This API is for to get
   6906           *	the self test axis(self_test_axis) in the register ox32 bit 0 to 2
   6907           *
   6908           *
   6909           *
   6910           *  @param selftest_axis_u8 : The value of selftest axis
   6911           *     selftest_axis_u8     |    result
   6912           *  ------------------------- |------------------
   6913           *     0x00                   | self test disable
   6914           *     0x01                   | x-axis
   6915           *     0x02                   | y-axis
   6916           *     0x03                   | z-axis
   6917           *
   6918           *
   6919           *	@return results of bus communication function
   6920           *	@retval 0 -> Success
   6921           *	@retval -1 -> Error
   6922           *
   6923           *
   6924           */
   6925          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_selftest_axis(
   6926          u8 *selftest_axis_u8)
   6927          {
   6928          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6929          	/*  Variable used to return value of
   6930          	communication routine*/
   6931          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6932          
   6933          	if (p_bma2x2 == BMA2x2_NULL) {
   6934          		/* Check the struct p_bma2x2 is empty */
   6935          		return E_BMA2x2_NULL_PTR;
   6936          		} else {
   6937          			/* read the self test axis*/
   6938          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6939          			(p_bma2x2->dev_addr,
   6940          			BMA2x2_ENABLE_SELFTEST_REG,
   6941          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6942          			*selftest_axis_u8 = BMA2x2_GET_BITSLICE
   6943          			(data_u8, BMA2x2_ENABLE_SELFTEST);
   6944          		}
   6945          	return com_rslt;
   6946          }
   6947          /*!
   6948           *	@brief This API is for to set
   6949           *	the self test axis(self_test_axis) in the register ox32 bit 0 to 2
   6950           *
   6951           *
   6952           *
   6953           *  @param selftest_axis_u8 : The value of selftest axis
   6954           *     selftest_axis_u8     |    result
   6955           *  ------------------------- |------------------
   6956           *     0x00                   | self test disable
   6957           *     0x01                   | x-axis
   6958           *     0x02                   | y-axis
   6959           *     0x03                   | z-axis
   6960           *
   6961           *
   6962           *	@return results of bus communication function
   6963           *	@retval 0 -> Success
   6964           *	@retval -1 -> Error
   6965           *
   6966           *
   6967           */
   6968          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_selftest_axis(
   6969          u8 selftest_axis_u8)
   6970          {
   6971          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6972          	/*  Variable used to return value of
   6973          	communication routine*/
   6974          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6975          
   6976          	if (p_bma2x2 == BMA2x2_NULL) {
   6977          		/* Check the struct p_bma2x2 is empty */
   6978          		return E_BMA2x2_NULL_PTR;
   6979          		} else {
   6980          		if (selftest_axis_u8 < BMA2x2_SELF_TEST_AXIS_RANGE) {
   6981          			/* write the self test axis*/
   6982          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6983          			(p_bma2x2->dev_addr,
   6984          			BMA2x2_ENABLE_SELFTEST_REG,
   6985          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6986          			data_u8 = BMA2x2_SET_BITSLICE
   6987          			(data_u8, BMA2x2_ENABLE_SELFTEST, selftest_axis_u8);
   6988          			com_rslt += bma2x2_write_reg(
   6989          			BMA2x2_ENABLE_SELFTEST_REG,
   6990          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6991          		 } else {
   6992          		com_rslt = E_OUT_OF_RANGE;
   6993          		}
   6994          	}
   6995          	return com_rslt;
   6996          }
   6997          /*!
   6998           *	@brief This API is for to get
   6999           *	the Self Test sign(selftest_sign) in the register 0x32 bit 2
   7000           *
   7001           *
   7002           *
   7003           *  @param selftest_sign_u8 : The value of self test sign
   7004           *     selftest_sign_u8     |    result
   7005           *  ------------------------- |------------------
   7006           *     0x00                   | negative sign
   7007           *     0x01                   | positive sign
   7008           *
   7009           *
   7010           *	@return results of bus communication function
   7011           *	@retval 0 -> Success
   7012           *	@retval -1 -> Error
   7013           *
   7014           *
   7015           */
   7016          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_selftest_sign(
   7017          u8 *selftest_sign_u8)
   7018          {
   7019          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7020          	/*  Variable used to return value of
   7021          	communication routine*/
   7022          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7023          
   7024          	if (p_bma2x2 == BMA2x2_NULL) {
   7025          		/* Check the struct p_bma2x2 is empty */
   7026          		return E_BMA2x2_NULL_PTR;
   7027          		} else {
   7028          			/* read self test sign */
   7029          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7030          			(p_bma2x2->dev_addr,
   7031          			BMA2x2_NEG_SELFTEST_REG,
   7032          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7033          			*selftest_sign_u8 = BMA2x2_GET_BITSLICE
   7034          			(data_u8, BMA2x2_NEG_SELFTEST);
   7035          		}
   7036          	return com_rslt;
   7037          }
   7038          /*!
   7039           *	@brief This API is for to set
   7040           *	the Self Test sign(selftest_sign) in the register 0x32 bit 2
   7041           *
   7042           *
   7043           *
   7044           *  @param selftest_sign_u8 : The value of self test sign
   7045           *     selftest_sign_u8     |    result
   7046           *  ------------------------- |------------------
   7047           *     0x00                   | negative sign
   7048           *     0x01                   | positive sign
   7049           *
   7050           *
   7051           *	@return results of bus communication function
   7052           *	@retval 0 -> Success
   7053           *	@retval -1 -> Error
   7054           *
   7055           *
   7056           */
   7057          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_selftest_sign(
   7058          u8 selftest_sign_u8)
   7059          {
   7060          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7061          	/*  Variable used to return value of
   7062          	communication routine*/
   7063          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7064          
   7065          	if (p_bma2x2 == BMA2x2_NULL) {
   7066          		/* Check the struct p_bma2x2 is empty */
   7067          		return E_BMA2x2_NULL_PTR;
   7068          		} else {
   7069          		if (selftest_sign_u8 <
   7070          		BMA2x2_SELF_TEST_SIGN_RANGE) {
   7071          			/* write self test sign */
   7072          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7073          			(p_bma2x2->dev_addr,
   7074          			BMA2x2_NEG_SELFTEST_REG,
   7075          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7076          			data_u8 = BMA2x2_SET_BITSLICE
   7077          			(data_u8, BMA2x2_NEG_SELFTEST, selftest_sign_u8);
   7078          			com_rslt += bma2x2_write_reg(
   7079          			BMA2x2_NEG_SELFTEST_REG,
   7080          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7081          		} else {
   7082          		com_rslt = E_OUT_OF_RANGE;
   7083          		}
   7084          	}
   7085          	return com_rslt;
   7086          }
   7087          /*!
   7088           * @brief This API is used to get
   7089           * the nvm program mode(nvm_prog_mode)in the register 0x33 bit 0
   7090           *
   7091           *
   7092           *  @param  nvmprog_mode_u8 : The value of nvm program mode
   7093           *     nvmprog_mode_u8      |    result
   7094           *  ------------------------- |------------------
   7095           *     0x00                   | Disable program mode
   7096           *     0x01                   | Enable program mode
   7097           *
   7098           *	@return results of bus communication function
   7099           *	@retval 0 -> Success
   7100           *	@retval -1 -> Error
   7101           *
   7102           *
   7103           */
   7104          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_nvmprog_mode(
   7105          u8 *nvmprog_mode_u8)
   7106          {
   7107          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7108          	/*  Variable used to return value of
   7109          	communication routine*/
   7110          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7111          
   7112          	if (p_bma2x2 == BMA2x2_NULL) {
   7113          		com_rslt = E_BMA2x2_NULL_PTR;
   7114          	} else {
   7115          		/* read the nvm program mode*/
   7116          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7117          		(p_bma2x2->dev_addr,
   7118          		BMA2x2_UNLOCK_EE_PROG_MODE_REG,
   7119          		&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7120          		*nvmprog_mode_u8 = BMA2x2_GET_BITSLICE
   7121          		(data_u8, BMA2x2_UNLOCK_EE_PROG_MODE);
   7122          	}
   7123          	return com_rslt;
   7124          }
   7125          /*!
   7126           * @brief This API is used to set
   7127           * the nvm program mode(nvm_prog_mode)in the register 0x33 bit 0
   7128           *
   7129           *
   7130           *  @param  nvmprog_mode_u8 : The value of nvm program mode
   7131           *     nvmprog_mode_u8      |    result
   7132           *  ------------------------- |------------------
   7133           *     0x00                   | Disable program mode
   7134           *     0x01                   | Enable program mode
   7135           *
   7136           *	@return results of bus communication function
   7137           *	@retval 0 -> Success
   7138           *	@retval -1 -> Error
   7139           *
   7140           *
   7141           */
   7142          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_nvmprog_mode(u8 nvmprog_mode_u8)
   7143          {
   7144          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7145          	/*  Variable used to return value of
   7146          	communication routine*/
   7147          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7148          
   7149          	if (p_bma2x2 == BMA2x2_NULL) {
   7150          		/* Check the struct p_bma2x2 is empty */
   7151          		com_rslt = E_BMA2x2_NULL_PTR;
   7152          	} else {
   7153          		/* write the nvm program mode*/
   7154          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7155          		(p_bma2x2->dev_addr,
   7156          		BMA2x2_UNLOCK_EE_PROG_MODE_REG,
   7157          		&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7158          		data_u8 = BMA2x2_SET_BITSLICE
   7159          		(data_u8, BMA2x2_UNLOCK_EE_PROG_MODE, nvmprog_mode_u8);
   7160          		com_rslt += bma2x2_write_reg
   7161          		(BMA2x2_UNLOCK_EE_PROG_MODE_REG,
   7162          		&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7163          	}
   7164          	return com_rslt;
   7165          }
   7166          /*!
   7167           *	@brief This API is used to set
   7168           *	the value of nvm program trig in the register 0x33 bit 1
   7169           *
   7170           *
   7171           *
   7172           *
   7173           *  @param nvprog_trig_u8: The value of nvm program trig
   7174           *     nvprog_trig_u8       |    result
   7175           *  ------------------------- |------------------
   7176           *     0x00                   | Do not trigger nvm program
   7177           *     0x01                   | Trigger nvm program
   7178           *
   7179           *
   7180           *	@return results of bus communication function
   7181           *	@retval 0 -> Success
   7182           *	@retval -1 -> Error
   7183           *
   7184           *
   7185           */
   7186          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_nvprog_trig(u8 nvprog_trig_u8)
   7187          {
   7188          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7189          	/*  Variable used to return value of
   7190          	communication routine*/
   7191          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7192          
   7193          	if (p_bma2x2 == BMA2x2_NULL) {
   7194          		/* Check the struct p_bma2x2 is empty */
   7195          		com_rslt = E_BMA2x2_NULL_PTR;
   7196          	} else {
   7197          		/* set the nvm program trigger */
   7198          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7199          		(p_bma2x2->dev_addr,
   7200          		BMA2x2_START_EE_PROG_TRIG_REG,
   7201          		&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7202          		data_u8 = BMA2x2_SET_BITSLICE
   7203          		(data_u8, BMA2x2_START_EE_PROG_TRIG, nvprog_trig_u8);
   7204          		com_rslt += bma2x2_write_reg
   7205          		(BMA2x2_START_EE_PROG_TRIG_REG,
   7206          		&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7207          	}
   7208          	return com_rslt;
   7209          }
   7210          /*!
   7211           * @brief This API is used to get
   7212           * the nvm program ready in the register bit 2
   7213           *
   7214           *
   7215           *  @param nvprog_ready_u8: The value of nvm program ready
   7216           *     nvprog_ready_u8      |    result
   7217           *  ------------------------- |------------------
   7218           *     0x00                   | nvm write/update operation is in progress
   7219           *     0x01                   | nvm is ready to accept a new write
   7220           *
   7221           *
   7222           *
   7223           *	@return results of bus communication function
   7224           *	@retval 0 -> Success
   7225           *	@retval -1 -> Error
   7226           *
   7227           *
   7228           */
   7229          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_nvmprog_ready(u8 *nvprog_ready_u8)
   7230          {
   7231          	/*  Variable used to return value of
   7232          	communication routine*/
   7233          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7234          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7235          
   7236          	if (p_bma2x2 == BMA2x2_NULL) {
   7237          		/* Check the struct p_bma2x2 is empty */
   7238          		com_rslt = E_BMA2x2_NULL_PTR;
   7239          	} else {
   7240          		/* read the nvm program ready*/
   7241          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7242          		(p_bma2x2->dev_addr,
   7243          		BMA2x2_EE_PROG_READY_REG,
   7244          		&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7245          		*nvprog_ready_u8 = BMA2x2_GET_BITSLICE
   7246          		(data_u8, BMA2x2_EE_PROG_READY);
   7247          	}
   7248          	return com_rslt;
   7249          }
   7250          /*!
   7251           * @brief This API is used to set
   7252           * the nvm program ready in the register bit 2
   7253           *
   7254           *
   7255           *  @param nvprog_remain_u8: The value of nvm program ready
   7256           *     nvprog_remain_u8     |    result
   7257           *  ------------------------- |------------------
   7258           *     0x00                   | nvm write/update operation is in progress
   7259           *     0x01                   | nvm is ready to accept a new write
   7260           *
   7261           *
   7262           *
   7263           *	@return results of bus communication function
   7264           *	@retval 0 -> Success
   7265           *	@retval -1 -> Error
   7266           *
   7267           *
   7268           */
   7269          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_nvmprog_remain(u8 *nvprog_remain_u8)
   7270          {
   7271          	/*  Variable used to return value of
   7272          	communication routine*/
   7273          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7274          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7275          	/* Check the struct p_bma2x2 is empty */
   7276          	if (BMA2x2_NULL == p_bma2x2) {
   7277          		com_rslt = E_BMA2x2_NULL_PTR;
   7278          	} else {
   7279          		/* write the nvm program ready*/
   7280          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7281          		(p_bma2x2->dev_addr,
   7282          		BMA2x2_EE_REMAIN_REG, &data_u8,
   7283          		BMA2x2_GEN_READ_WRITE_LENGTH);
   7284          		*nvprog_remain_u8 = BMA2x2_GET_BITSLICE
   7285          		(data_u8, BMA2x2_EE_REMAIN);
   7286          	}
   7287          	return com_rslt;
   7288          }
   7289          /*!
   7290           *	@brief This API is used to get the enable status of spi3
   7291           *	in the register 0x34 bit 0
   7292           *
   7293           *
   7294           *
   7295           *  @param  spi3_u8 : The value of SPI 3 or 4 wire enable
   7296           *     spi3_u8              |    result
   7297           *  ------------------------- |------------------
   7298           *     0x00                   |     spi4
   7299           *     0x01                   |     spi3
   7300           *
   7301           *
   7302           *
   7303           *	@return results of bus communication function
   7304           *	@retval 0 -> Success
   7305           *	@retval -1 -> Error
   7306           *
   7307           *
   7308           */
   7309          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_spi3(u8 *spi3_u8)
   7310          {
   7311          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7312          	/*  Variable used to return value of
   7313          	communication routine*/
   7314          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7315          
   7316          	if (p_bma2x2 == BMA2x2_NULL) {
   7317          		/* Check the struct p_bma2x2 is empty */
   7318          		return E_BMA2x2_NULL_PTR;
   7319          		} else {
   7320          			/* read the spi status*/
   7321          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7322          			(p_bma2x2->dev_addr,
   7323          			BMA2x2_ENABLE_SPI_MODE_3_REG,
   7324          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7325          			*spi3_u8 = BMA2x2_GET_BITSLICE
   7326          			(data_u8, BMA2x2_ENABLE_SPI_MODE_3);
   7327          		}
   7328          	return com_rslt;
   7329          }
   7330          /*!
   7331           *	@brief This API is used to set the enable status of spi3
   7332           *	in the register 0x34 bit 0
   7333           *
   7334           *
   7335           *
   7336           *  @param  spi3_u8 : The value of SPI 3 or 4 wire enable
   7337           *     spi3_u8              |    result
   7338           *  ------------------------- |------------------
   7339           *     0x00                   |     spi4
   7340           *     0x01                   |     spi3
   7341           *
   7342           *
   7343           *
   7344           *	@return results of bus communication function
   7345           *	@retval 0 -> Success
   7346           *	@retval -1 -> Error
   7347           *
   7348           *
   7349           */
   7350          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_spi3(u8 spi3_u8)
   7351          {
   7352          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7353          	/*  Variable used to return value of
   7354          	communication routine*/
   7355          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7356          
   7357          	if (p_bma2x2 == BMA2x2_NULL) {
   7358          		/* Check the struct p_bma2x2 is empty */
   7359          		return E_BMA2x2_NULL_PTR;
   7360          		} else {
   7361          			/* write the spi status*/
   7362          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7363          			(p_bma2x2->dev_addr,
   7364          			BMA2x2_ENABLE_SPI_MODE_3_REG,
   7365          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7366          			data_u8 = BMA2x2_SET_BITSLICE
   7367          			(data_u8, BMA2x2_ENABLE_SPI_MODE_3, spi3_u8);
   7368          			com_rslt += bma2x2_write_reg(
   7369          			BMA2x2_ENABLE_SPI_MODE_3_REG,
   7370          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7371          		}
   7372          	return com_rslt;
   7373          }
   7374          /*!
   7375           *	@brief This API is used to get the i2c
   7376           *	watch dog timer period and I2C interface mode is selected
   7377           *	in the register 0x34 bit 1 and 2
   7378           *
   7379           *
   7380           *  @param channel_u8: The i2c option selection
   7381           *     channel_u8           |    result
   7382           *  ------------------------- |------------------
   7383           *        0                   |   BMA2x2_ACCEL_I2C_SELECT
   7384           *        1                   |   BMA2x2_ACCEL_I2C_ENABLE
   7385           *
   7386           *  @param i2c_wdt_u8: watch dog timer period
   7387           *	and I2C interface mode is selected
   7388           *     BMA2x2_ACCEL_I2C_SELECT|    result
   7389           *  ------------------------- |------------------
   7390           *     0x00                   | Disable the watchdog at SDI pin
   7391           *     0x01                   | Enable watchdog
   7392           *
   7393           *     BMA2x2_I2C_ENABLE      |    result
   7394           *  ------------------------- |------------------
   7395           *     0x00                   | 1ms
   7396           *     0x01                   | 50ms
   7397           *
   7398           *
   7399           *	@return results of bus communication function
   7400           *	@retval 0 -> Success
   7401           *	@retval -1 -> Error
   7402           *
   7403           *
   7404           */
   7405          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_i2c_wdt(u8 channel_u8,
   7406          u8 *i2c_wdt_u8)
   7407          {
   7408          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7409          		/*  Variable used to return value of
   7410          	communication routine*/
   7411          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7412          
   7413          	if (p_bma2x2 == BMA2x2_NULL) {
   7414          		/* Check the struct p_bma2x2 is empty */
   7415          		return E_BMA2x2_NULL_PTR;
   7416          		} else {
   7417          		switch (channel_u8) {
   7418          		case BMA2x2_I2C_SELECT:
   7419          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7420          			(p_bma2x2->dev_addr,
   7421          			BMA2x2_I2C_WDT_PERIOD_REG,
   7422          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7423          			*i2c_wdt_u8 = BMA2x2_GET_BITSLICE(data_u8,
   7424          			BMA2x2_I2C_WDT_PERIOD);
   7425          		break;
   7426          		case BMA2x2_I2C_ENABLE:
   7427          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7428          			(p_bma2x2->dev_addr,
   7429          			BMA2x2_ENABLE_I2C_WDT_REG,
   7430          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7431          			*i2c_wdt_u8 = BMA2x2_GET_BITSLICE
   7432          			(data_u8, BMA2x2_ENABLE_I2C_WDT);
   7433          		break;
   7434          		default:
   7435          		com_rslt = E_OUT_OF_RANGE;
   7436          		break;
   7437          		}
   7438          	}
   7439          	return com_rslt;
   7440          }
   7441          /*!
   7442           *	@brief This API is used to set the i2c
   7443           *	watch dog timer period and I2C interface mode is selected
   7444           *	in the register 0x34 bit 1 and 2
   7445           *
   7446           *
   7447           *  @param channel_u8: The i2c option selection
   7448           *     channel_u8           |    result
   7449           *  ------------------------- |------------------
   7450           *        0                   |   BMA2x2_ACCEL_I2C_SELECT
   7451           *        1                   |   BMA2x2_ACCEL_I2C_ENABLE
   7452           *
   7453           *  @param i2c_wdt_u8: watch dog timer period
   7454           *	and I2C interface mode is selected
   7455           *     BMA2x2_ACCEL_I2C_SELECT|    result
   7456           *  ------------------------- |------------------
   7457           *     0x00                   | Disable the watchdog at SDI pin
   7458           *     0x01                   | Enable watchdog
   7459           *
   7460           *     BMA2x2_I2C_ENABLE      |    result
   7461           *  ------------------------- |------------------
   7462           *     0x00                   | 1ms
   7463           *     0x01                   | 50ms
   7464           *
   7465           *
   7466           *	@return results of bus communication function
   7467           *	@retval 0 -> Success
   7468           *	@retval -1 -> Error
   7469           *
   7470           *
   7471           */
   7472          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_i2c_wdt(u8 channel_u8,
   7473          u8 i2c_wdt_u8)
   7474          {
   7475          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7476          	/*  Variable used to return value of
   7477          	communication routine*/
   7478          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7479          
   7480          	if (p_bma2x2 == BMA2x2_NULL) {
   7481          		/* Check the struct p_bma2x2 is empty */
   7482          		return E_BMA2x2_NULL_PTR;
   7483          		} else {
   7484          		switch (channel_u8) {
   7485          		case BMA2x2_I2C_SELECT:
   7486          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7487          			(p_bma2x2->dev_addr,
   7488          			BMA2x2_I2C_WDT_PERIOD_REG,
   7489          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7490          			data_u8 = BMA2x2_SET_BITSLICE
   7491          			(data_u8,
   7492          			BMA2x2_I2C_WDT_PERIOD, i2c_wdt_u8);
   7493          			com_rslt += bma2x2_write_reg(
   7494          			BMA2x2_I2C_WDT_PERIOD_REG,
   7495          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7496          		break;
   7497          		case BMA2x2_I2C_ENABLE:
   7498          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7499          			(p_bma2x2->dev_addr,
   7500          			BMA2x2_ENABLE_I2C_WDT_REG,
   7501          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7502          			data_u8 = BMA2x2_SET_BITSLICE
   7503          			(data_u8,
   7504          			BMA2x2_ENABLE_I2C_WDT, i2c_wdt_u8);
   7505          			com_rslt += bma2x2_write_reg(
   7506          			BMA2x2_ENABLE_I2C_WDT_REG,
   7507          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7508          		break;
   7509          		default:
   7510          			com_rslt = E_OUT_OF_RANGE;
   7511          		break;
   7512          		}
   7513          	}
   7514          	return com_rslt;
   7515          }
   7516          /*!
   7517           *	@brief This API is used to get
   7518           *	slow compensation(hp_x_enable, hp_y_enable and hp_z_enable) enable
   7519           *	in the register 0x36 bit 0 to 2
   7520           *	@note SLOW_COMP_X -> bit 0
   7521           *	@note SLOW_COMP_Y -> bit 1
   7522           *	@note SLOW_COMP_Z -> bit 2
   7523           *
   7524           *
   7525           *	@param channel_u8: The value of slow compensation selection
   7526           *     channel_u8           |    result
   7527           *  ------------------------- |------------------
   7528           *        0                   |   BMA2x2_ACCEL_SLOW_COMP_X
   7529           *        1                   |   BMA2x2_ACCEL_SLOW_COMP_Y
   7530           *        2                   |   BMA2x2_ACCEL_SLOW_COMP_Z
   7531           *
   7532           *  @param slow_comp_u8: The value of slow compensation enable
   7533           *     slow_comp_u8         |    result
   7534           *  ------------------------- |------------------
   7535           *         0x00               |    Disable
   7536           *        0x01                |    Enable
   7537           *
   7538           *
   7539           *	@return results of bus communication function
   7540           *	@retval 0 -> Success
   7541           *	@retval -1 -> Error
   7542           *
   7543           *
   7544           */
   7545          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_slow_comp(u8 channel_u8,
   7546          u8 *slow_comp_u8)
   7547          {
   7548          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7549          	/*  Variable used to return value of
   7550          	communication routine*/
   7551          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7552          
   7553          	if (p_bma2x2 == BMA2x2_NULL) {
   7554          		/* Check the struct p_bma2x2 is empty */
   7555          		return E_BMA2x2_NULL_PTR;
   7556          		} else {
   7557          		switch (channel_u8) {
   7558          		case BMA2x2_SLOW_COMP_X:
   7559          			/*SLOW COMP X*/
   7560          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7561          			(p_bma2x2->dev_addr,
   7562          			BMA2x2_ENABLE_SLOW_COMP_X_REG,
   7563          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7564          			*slow_comp_u8 = BMA2x2_GET_BITSLICE
   7565          			(data_u8, BMA2x2_ENABLE_SLOW_COMP_X);
   7566          		break;
   7567          		case BMA2x2_SLOW_COMP_Y:
   7568          			/*SLOW COMP Y*/
   7569          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7570          			(p_bma2x2->dev_addr,
   7571          			BMA2x2_ENABLE_SLOW_COMP_Y_REG,
   7572          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7573          			*slow_comp_u8 = BMA2x2_GET_BITSLICE
   7574          			(data_u8, BMA2x2_ENABLE_SLOW_COMP_Y);
   7575          		break;
   7576          		case BMA2x2_SLOW_COMP_Z:
   7577          			/*SLOW COMP Z*/
   7578          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7579          			(p_bma2x2->dev_addr,
   7580          			BMA2x2_ENABLE_SLOW_COMP_Z_REG,
   7581          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7582          			*slow_comp_u8 = BMA2x2_GET_BITSLICE
   7583          			(data_u8, BMA2x2_ENABLE_SLOW_COMP_Z);
   7584          		break;
   7585          		default:
   7586          			com_rslt = E_OUT_OF_RANGE;
   7587          		break;
   7588          		}
   7589          	}
   7590          	return com_rslt;
   7591          }
   7592          /*!
   7593           *	@brief This API is used to set
   7594           *	slow compensation(hp_x_enable, hp_y_enable and hp_z_enable) enable
   7595           *	in the register 0x36 bit 0 to 2
   7596           *	@note SLOW_COMP_X -> bit 0
   7597           *	@note SLOW_COMP_Y -> bit 1
   7598           *	@note SLOW_COMP_Z -> bit 2
   7599           *
   7600           *
   7601           *	@param channel_u8: The value of slow compensation selection
   7602           *     channel_u8           |    result
   7603           *  ------------------------- |------------------
   7604           *        0                   |   BMA2x2_ACCEL_SLOW_COMP_X
   7605           *        1                   |   BMA2x2_ACCEL_SLOW_COMP_Y
   7606           *        2                   |   BMA2x2_ACCEL_SLOW_COMP_Z
   7607           *
   7608           *  @param slow_comp_u8: The value of slow compensation enable
   7609           *     slow_comp_u8         |    result
   7610           *  ------------------------- |------------------
   7611           *         0x00               |    Disable
   7612           *        0x01                |    Enable
   7613           *
   7614           *
   7615           *	@return results of bus communication function
   7616           *	@retval 0 -> Success
   7617           *	@retval -1 -> Error
   7618           *
   7619           *
   7620           */
   7621          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_slow_comp(u8 channel_u8,
   7622          u8 slow_comp_u8)
   7623          {
   7624          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7625          		/*  Variable used to return value of
   7626          	communication routine*/
   7627          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7628          
   7629          	if (p_bma2x2 == BMA2x2_NULL) {
   7630          		/* Check the struct p_bma2x2 is empty */
   7631          		return E_BMA2x2_NULL_PTR;
   7632          		} else {
   7633          		switch (channel_u8) {
   7634          		case BMA2x2_SLOW_COMP_X:
   7635          			/*SLOW COMP X*/
   7636          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7637          			(p_bma2x2->dev_addr,
   7638          			BMA2x2_ENABLE_SLOW_COMP_X_REG,
   7639          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7640          			data_u8 = BMA2x2_SET_BITSLICE
   7641          			(data_u8,
   7642          			BMA2x2_ENABLE_SLOW_COMP_X, slow_comp_u8);
   7643          			com_rslt += bma2x2_write_reg(
   7644          			BMA2x2_ENABLE_SLOW_COMP_X_REG,
   7645          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7646          		break;
   7647          		case BMA2x2_SLOW_COMP_Y:
   7648          			/*SLOW COMP Y*/
   7649          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7650          			(p_bma2x2->dev_addr,
   7651          			BMA2x2_ENABLE_SLOW_COMP_Y_REG,
   7652          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7653          			data_u8 = BMA2x2_SET_BITSLICE
   7654          			(data_u8,
   7655          			BMA2x2_ENABLE_SLOW_COMP_Y, slow_comp_u8);
   7656          			com_rslt += bma2x2_write_reg(
   7657          			BMA2x2_ENABLE_SLOW_COMP_Y_REG,
   7658          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7659          		break;
   7660          		case BMA2x2_SLOW_COMP_Z:
   7661          			/*SLOW COMP Z*/
   7662          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7663          			(p_bma2x2->dev_addr,
   7664          			BMA2x2_ENABLE_SLOW_COMP_Z_REG,
   7665          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7666          			data_u8 = BMA2x2_SET_BITSLICE
   7667          			(data_u8,
   7668          			BMA2x2_ENABLE_SLOW_COMP_Z, slow_comp_u8);
   7669          			com_rslt += bma2x2_write_reg(
   7670          			BMA2x2_ENABLE_SLOW_COMP_Z_REG,
   7671          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7672          		break;
   7673          		default:
   7674          			com_rslt = E_OUT_OF_RANGE;
   7675          		break;
   7676          		}
   7677          	}
   7678          	return com_rslt;
   7679          }
   7680          /*!
   7681           *	@brief This API is used to get
   7682           *	the status of fast offset compensation(cal_rdy) in the register 0x36
   7683           *	bit 4(Read Only Possible)
   7684           *
   7685           *
   7686           *
   7687           *  @param  cal_rdy_u8: The value of cal_ready
   7688           *
   7689           *
   7690           *
   7691           *
   7692           *	@return results of bus communication function
   7693           *	@retval 0 -> Success
   7694           *	@retval -1 -> Error
   7695           *
   7696           *
   7697           */
   7698          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_cal_rdy(u8 *cal_rdy_u8)
   7699          {
   7700          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7701          	/*  Variable used to return value of
   7702          	communication routine*/
   7703          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7704          
   7705          	if (p_bma2x2 == BMA2x2_NULL) {
   7706          		/* Check the struct p_bma2x2 is empty */
   7707          		return E_BMA2x2_NULL_PTR;
   7708          		} else {
   7709          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7710          		(p_bma2x2->dev_addr,
   7711          		BMA2x2_FAST_CAL_RDY_STAT_REG,
   7712          		&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7713          		*cal_rdy_u8 = BMA2x2_GET_BITSLICE(data_u8,
   7714          		BMA2x2_FAST_CAL_RDY_STAT);
   7715          	}
   7716          	return com_rslt;
   7717          }
   7718          /*!
   7719           *	@brief This API is used to set
   7720           *	the status of fast offset compensation(cal_rdy) in the register 0x36
   7721           *	bit 4(Read Only Possible)
   7722           *
   7723           *
   7724           *
   7725           *  @param  cal_trigger_u8: The value of cal_ready
   7726           *
   7727           *
   7728           *
   7729           *
   7730           *	@return results of bus communication function
   7731           *	@retval 0 -> Success
   7732           *	@retval -1 -> Error
   7733           *
   7734           *
   7735           */
   7736          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_cal_trigger(u8 cal_trigger_u8)
   7737          {
   7738          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7739          	/*  Variable used to return value of
   7740          	communication routine*/
   7741          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7742          
   7743          	if (p_bma2x2 == BMA2x2_NULL) {
   7744          		/* Check the struct p_bma2x2 is empty */
   7745          		return E_BMA2x2_NULL_PTR;
   7746          		} else {
   7747          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7748          			(p_bma2x2->dev_addr,
   7749          			BMA2x2_CAL_TRIGGER_REG, &data_u8,
   7750          			BMA2x2_GEN_READ_WRITE_LENGTH);
   7751          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   7752          			BMA2x2_CAL_TRIGGER, cal_trigger_u8);
   7753          			com_rslt += bma2x2_write_reg(
   7754          			BMA2x2_CAL_TRIGGER_REG,
   7755          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7756          		}
   7757          	return com_rslt;
   7758          }
   7759          /*!
   7760           *	@brief This API is used to set
   7761           *	the offset reset(offset_reset) in the register 0x36
   7762           *	bit 7(Write only possible)
   7763           *
   7764           *
   7765           *
   7766           *  @param  offset_rst_u8: The offset reset value
   7767           *
   7768           *
   7769           *
   7770           *	@return results of bus communication function
   7771           *	@retval 0 -> Success
   7772           *	@retval -1 -> Error
   7773           *
   7774           *
   7775           */
   7776          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_offset_rst(u8 offset_rst_u8)
   7777          {
   7778          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7779          	/*  Variable used to return value of
   7780          	communication routine*/
   7781          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7782          
   7783          	if (p_bma2x2 == BMA2x2_NULL) {
   7784          		/* Check the struct p_bma2x2 is empty */
   7785          		return E_BMA2x2_NULL_PTR;
   7786          		} else {
   7787          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7788          			(p_bma2x2->dev_addr,
   7789          			BMA2x2_RST_OFFSET_REG,
   7790          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7791          			data_u8 = BMA2x2_SET_BITSLICE
   7792          			(data_u8, BMA2x2_RST_OFFSET,
   7793          			offset_rst_u8);
   7794          			com_rslt += bma2x2_write_reg(
   7795          			BMA2x2_RST_OFFSET_REG,
   7796          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7797          		}
   7798          	return com_rslt;
   7799          }
   7800          /*!
   7801           *	@brief This API is used to get
   7802           *	the status of offset target axis(offset_target_x, offset_target_y and
   7803           *	offset_target_z) and cut_off in the register 0x37
   7804           *	@note CUT_OFF -> bit 0
   7805           *	@note OFFSET_TRIGGER_X -> bit 1 and 2
   7806           *	@note OFFSET_TRIGGER_Y -> bit 3 and 4
   7807           *	@note OFFSET_TRIGGER_Z -> bit 5 and 6
   7808           *
   7809           *
   7810           *  @param channel_u8: The value of offset axis selection
   7811           *     channel_u8           |    result
   7812           *  ------------------------- |------------------
   7813           *        0                   |   BMA2x2_ACCEL_CUT_OFF
   7814           *        1                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_X
   7815           *        2                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_Y
   7816           *        2                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_Z
   7817           *
   7818           *  @param  offset_u8: The offset target value
   7819           *     CUT_OFF                |    result
   7820           *  ------------------------- |------------------
   7821           *        0                   |   1Hz
   7822           *        1                   |   10Hz
   7823           *
   7824           *
   7825           *     OFFSET_TRIGGER         |    result
   7826           *  ------------------------- |------------------
   7827           *        0x00                |   0g
   7828           *        0x01                |   +1g
   7829           *        0x02                |   -1g
   7830           *        0x03                |   0g
   7831           *
   7832           *	@return results of bus communication function
   7833           *	@retval 0 -> Success
   7834           *	@retval -1 -> Error
   7835           *
   7836           *
   7837           */
   7838          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_offset_target(u8 channel_u8,
   7839          u8 *offset_u8)
   7840          {
   7841          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7842          	/*  Variable used to return value of
   7843          	communication routine*/
   7844          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7845          
   7846          	if (p_bma2x2 == BMA2x2_NULL) {
   7847          		/* Check the struct p_bma2x2 is empty */
   7848          		return E_BMA2x2_NULL_PTR;
   7849          		} else {
   7850          		switch (channel_u8) {
   7851          		case BMA2x2_CUT_OFF:
   7852          			/*CUT-OFF*/
   7853          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7854          			(p_bma2x2->dev_addr,
   7855          			BMA2x2_COMP_CUTOFF_REG, &data_u8,
   7856          			BMA2x2_GEN_READ_WRITE_LENGTH);
   7857          			*offset_u8 = BMA2x2_GET_BITSLICE(data_u8,
   7858          			BMA2x2_COMP_CUTOFF);
   7859          		break;
   7860          		case BMA2x2_OFFSET_TRIGGER_X:
   7861          			/*OFFSET TRIGGER X*/
   7862          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7863          			(p_bma2x2->dev_addr,
   7864          			BMA2x2_COMP_TARGET_OFFSET_X_REG,
   7865          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7866          			*offset_u8 = BMA2x2_GET_BITSLICE(data_u8,
   7867          			BMA2x2_COMP_TARGET_OFFSET_X);
   7868          		break;
   7869          		case BMA2x2_OFFSET_TRIGGER_Y:
   7870          			/*OFFSET TRIGGER Y*/
   7871          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7872          			(p_bma2x2->dev_addr,
   7873          			BMA2x2_COMP_TARGET_OFFSET_Y_REG,
   7874          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7875          			*offset_u8 = BMA2x2_GET_BITSLICE(data_u8,
   7876          			BMA2x2_COMP_TARGET_OFFSET_Y);
   7877          		break;
   7878          		case BMA2x2_OFFSET_TRIGGER_Z:
   7879          			/*OFFSET TRIGGER Z*/
   7880          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7881          			(p_bma2x2->dev_addr,
   7882          			BMA2x2_COMP_TARGET_OFFSET_Z_REG,
   7883          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7884          			*offset_u8 = BMA2x2_GET_BITSLICE
   7885          			(data_u8, BMA2x2_COMP_TARGET_OFFSET_Z);
   7886          		break;
   7887          		default:
   7888          			com_rslt = E_OUT_OF_RANGE;
   7889          		break;
   7890          		}
   7891          	}
   7892          	return com_rslt;
   7893          }
   7894          /*!
   7895           *	@brief This API is used to set
   7896           *	the status of offset target axis(offset_target_x, offset_target_y and
   7897           *	offset_target_z) and cut_off in the register 0x37
   7898           *	@note CUT_OFF -> bit 0
   7899           *	@note OFFSET_TRIGGER_X -> bit 1 and 2
   7900           *	@note OFFSET_TRIGGER_Y -> bit 3 and 4
   7901           *	@note OFFSET_TRIGGER_Z -> bit 5 and 6
   7902           *
   7903           *
   7904           *  @param channel_u8: The value of offset axis selection
   7905           *     channel_u8           |    result
   7906           *  ------------------------- |------------------
   7907           *        0                   |   BMA2x2_ACCEL_CUT_OFF
   7908           *        1                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_X
   7909           *        2                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_Y
   7910           *        2                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_Z
   7911           *
   7912           *  @param  offset_u8: The offset target value
   7913           *     CUT_OFF                |    result
   7914           *  ------------------------- |------------------
   7915           *        0                   |   1Hz
   7916           *        1                   |   10Hz
   7917           *
   7918           *
   7919           *     OFFSET_TRIGGER         |    result
   7920           *  ------------------------- |------------------
   7921           *        0x00                |   0g
   7922           *        0x01                |   +1g
   7923           *        0x02                |   -1g
   7924           *        0x03                |   0g
   7925           *
   7926           *	@return results of bus communication function
   7927           *	@retval 0 -> Success
   7928           *	@retval -1 -> Error
   7929           *
   7930           *
   7931           */
   7932          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_offset_target(u8 channel_u8,
   7933          u8 offset_u8)
   7934          {
   7935          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7936          	/*  Variable used to return value of
   7937          	communication routine*/
   7938          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7939          
   7940          	if (p_bma2x2 == BMA2x2_NULL) {
   7941          		/* Check the struct p_bma2x2 is empty */
   7942          		return E_BMA2x2_NULL_PTR;
   7943          		} else {
   7944          		switch (channel_u8) {
   7945          		case BMA2x2_CUT_OFF:
   7946          			/*CUT-OFF*/
   7947          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7948          			(p_bma2x2->dev_addr,
   7949          			BMA2x2_COMP_CUTOFF_REG,
   7950          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7951          			data_u8 = BMA2x2_SET_BITSLICE
   7952          			(data_u8, BMA2x2_COMP_CUTOFF, offset_u8);
   7953          			com_rslt += bma2x2_write_reg(
   7954          			BMA2x2_COMP_CUTOFF_REG,
   7955          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7956          		break;
   7957          		case BMA2x2_OFFSET_TRIGGER_X:
   7958          			/*OFFSET TARGET X*/
   7959          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7960          			(p_bma2x2->dev_addr,
   7961          			BMA2x2_COMP_TARGET_OFFSET_X_REG,
   7962          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7963          			data_u8 = BMA2x2_SET_BITSLICE
   7964          			(data_u8, BMA2x2_COMP_TARGET_OFFSET_X, offset_u8);
   7965          			com_rslt += bma2x2_write_reg(
   7966          			BMA2x2_COMP_TARGET_OFFSET_X_REG,
   7967          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7968          		break;
   7969          		case BMA2x2_OFFSET_TRIGGER_Y:
   7970          			/*OFFSET TARGET Y*/
   7971          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7972          			(p_bma2x2->dev_addr,
   7973          			BMA2x2_COMP_TARGET_OFFSET_Y_REG,
   7974          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7975          			data_u8 = BMA2x2_SET_BITSLICE
   7976          			(data_u8, BMA2x2_COMP_TARGET_OFFSET_Y, offset_u8);
   7977          			com_rslt += bma2x2_write_reg(
   7978          			BMA2x2_COMP_TARGET_OFFSET_Y_REG,
   7979          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7980          		break;
   7981          		case BMA2x2_OFFSET_TRIGGER_Z:
   7982          			/*OFFSET TARGET Z*/
   7983          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7984          			(p_bma2x2->dev_addr,
   7985          			BMA2x2_COMP_TARGET_OFFSET_Z_REG,
   7986          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7987          			data_u8 = BMA2x2_SET_BITSLICE
   7988          			(data_u8, BMA2x2_COMP_TARGET_OFFSET_Z, offset_u8);
   7989          			com_rslt += bma2x2_write_reg(
   7990          			BMA2x2_COMP_TARGET_OFFSET_Z_REG,
   7991          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7992          		break;
   7993          		default:
   7994          			com_rslt = E_OUT_OF_RANGE;
   7995          		break;
   7996          		}
   7997          	}
   7998          	return com_rslt;
   7999          }
   8000          /*!
   8001           *	@brief This API is used to get the status of offset
   8002           *	(offset_x, offset_y and offset_z) in the registers 0x38,0x39 and 0x3A
   8003           *	@note offset_x -> register 0x38 bit 0 to 7
   8004           *	@note offset_y -> register 0x39 bit 0 to 7
   8005           *	@note offset_z -> register 0x3A bit 0 to 7
   8006           *
   8007           *
   8008           *  @param channel_u8: The value of offset selection
   8009           *     channel_u8           |    result
   8010           *  ------------------------- |------------------
   8011           *        0                   |   BMA2x2_ACCEL_X_AXIS
   8012           *        1                   |   BMA2x2_ACCEL_Y_AXIS
   8013           *        2                   |   BMA2x2_ACCEL_Z_AXIS
   8014           *
   8015           *  @param offset_u8: The value of offset
   8016           *
   8017           *
   8018           *
   8019           *	@return results of bus communication function
   8020           *	@retval 0 -> Success
   8021           *	@retval -1 -> Error
   8022           *
   8023           *
   8024           */
   8025          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_offset(u8 channel_u8,
   8026          s8 *offset_u8)
   8027          {
   8028          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8029          	/*  Variable used to return value of
   8030          	communication routine*/
   8031          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8032          
   8033          	if (p_bma2x2 == BMA2x2_NULL) {
   8034          		/* Check the struct p_bma2x2 is empty */
   8035          		return E_BMA2x2_NULL_PTR;
   8036          		} else {
   8037          		switch (channel_u8) {
   8038          		case BMA2x2_X_AXIS:
   8039          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8040          			(p_bma2x2->dev_addr,
   8041          			BMA2x2_OFFSET_X_AXIS_ADDR, &data_u8,
   8042          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8043          			*offset_u8 = (s8)data_u8;
   8044          		break;
   8045          		case BMA2x2_Y_AXIS:
   8046          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8047          			(p_bma2x2->dev_addr,
   8048          			BMA2x2_OFFSET_Y_AXIS_ADDR, &data_u8,
   8049          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8050          			*offset_u8 = (s8)data_u8;
   8051          		break;
   8052          		case BMA2x2_Z_AXIS:
   8053          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8054          			(p_bma2x2->dev_addr,
   8055          			BMA2x2_OFFSET_Z_AXIS_ADDR, &data_u8,
   8056          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8057          			*offset_u8 = (s8)data_u8;
   8058          		break;
   8059          		default:
   8060          			com_rslt = E_OUT_OF_RANGE;
   8061          		break;
   8062          		}
   8063          	}
   8064          	return com_rslt;
   8065          }
   8066          /*!
   8067           *	@brief This API is used to set the status of offset
   8068           *	(offset_x, offset_y and offset_z) in the registers 0x38,0x39 and 0x3A
   8069           *	@note offset_x -> register 0x38 bit 0 to 7
   8070           *	@note offset_y -> register 0x39 bit 0 to 7
   8071           *	@note offset_z -> register 0x3A bit 0 to 7
   8072           *
   8073           *
   8074           *  @param channel_u8: The value of offset selection
   8075           *     channel_u8           |    result
   8076           *  ------------------------- |------------------
   8077           *        0                   |   BMA2x2_ACCEL_X_AXIS
   8078           *        1                   |   BMA2x2_ACCEL_Y_AXIS
   8079           *        2                   |   BMA2x2_ACCEL_Z_AXIS
   8080           *
   8081           *  @param offset_u8: The value of offset
   8082           *
   8083           *
   8084           *
   8085           *	@return results of bus communication function
   8086           *	@retval 0 -> Success
   8087           *	@retval -1 -> Error
   8088           *
   8089           *
   8090           */
   8091          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_offset(u8 channel_u8,
   8092          s8 offset_u8)
   8093          {
   8094          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8095          	/*  Variable used to return value of
   8096          	communication routine*/
   8097          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8098          
   8099          	if (p_bma2x2 == BMA2x2_NULL) {
   8100          		/* Check the struct p_bma2x2 is empty */
   8101          		return E_BMA2x2_NULL_PTR;
   8102          		} else {
   8103          		switch (channel_u8) {
   8104          		case BMA2x2_X_AXIS:
   8105          			data_u8 = offset_u8;
   8106          			com_rslt = bma2x2_write_reg(
   8107          			BMA2x2_OFFSET_X_AXIS_ADDR, &data_u8,
   8108          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8109          		break;
   8110          		case BMA2x2_Y_AXIS:
   8111          			data_u8 = offset_u8;
   8112          			com_rslt = bma2x2_write_reg(
   8113          			BMA2x2_OFFSET_Y_AXIS_ADDR, &data_u8,
   8114          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8115          		break;
   8116          		case BMA2x2_Z_AXIS:
   8117          			data_u8 = offset_u8;
   8118          			com_rslt = bma2x2_write_reg(
   8119          			BMA2x2_OFFSET_Z_AXIS_ADDR, &data_u8,
   8120          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8121          		break;
   8122          		default:
   8123          			com_rslt = E_OUT_OF_RANGE;
   8124          		break;
   8125          		}
   8126          	}
   8127          	return com_rslt;
   8128          }
   8129          /*!
   8130           *	@brief This API is used to get
   8131           *	the status of fifo (fifo_mode) in the register 0x3E bit 6 and 7
   8132           *
   8133           *
   8134           *  @param fifo_mode_u8 : The value of fifo mode
   8135           *     fifo_mode_u8         |    result
   8136           *  ------------------------- |------------------
   8137           *        0x00                |   BYPASS
   8138           *        0x01                |   FIFO
   8139           *        0x02                |   STREAM
   8140           *        0x03                |   RESERVED
   8141           *
   8142           *
   8143           *
   8144           *	@return results of bus communication function
   8145           *	@retval 0 -> Success
   8146           *	@retval -1 -> Error
   8147           *
   8148           *
   8149          */
   8150          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_mode(u8 *fifo_mode_u8)
   8151          {
   8152          	/*  Variable used to return value of
   8153          	communication routine*/
   8154          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8155          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8156          
   8157          	if (p_bma2x2 == BMA2x2_NULL) {
   8158          		/* Check the struct p_bma2x2 is empty */
   8159          		return E_BMA2x2_NULL_PTR;
   8160          		} else {
   8161          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   8162          			p_bma2x2->dev_addr,
   8163          			BMA2x2_FIFO_MODE_REG, &data_u8,
   8164          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8165          			*fifo_mode_u8 = BMA2x2_GET_BITSLICE(data_u8,
   8166          			BMA2x2_FIFO_MODE);
   8167          		}
   8168          	return com_rslt;
   8169          }
   8170          /*!
   8171           *	@brief This API is used to set
   8172           *	the status of fifo (fifo_mode) in the register 0x3E bit 6 and 7
   8173           *
   8174           *
   8175           *  @param fifo_mode_u8 : The value of fifo mode
   8176           *     fifo_mode_u8         |    result
   8177           *  ------------------------- |------------------
   8178           *        0x00                |   BYPASS
   8179           *        0x01                |   FIFO
   8180           *        0x02                |   STREAM
   8181           *        0x03                |   RESERVED
   8182           *
   8183           *
   8184           *
   8185           *	@return results of bus communication function
   8186           *	@retval 0 -> Success
   8187           *	@retval -1 -> Error
   8188           *	@retval -127 -> Null Pointer Error
   8189           *
   8190          */
   8191          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_fifo_mode(u8 fifo_mode_u8)
   8192          {
   8193          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8194          	u8 power_mode = BMA2x2_INIT_VALUE;
   8195          		/*  Variable used to return value of
   8196          	communication routine*/
   8197          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8198          
   8199          	if (p_bma2x2 == BMA2x2_NULL) {
   8200          		/* Check the struct p_bma2x2 is empty */
   8201          		com_rslt = E_BMA2x2_NULL_PTR;
   8202          	} else {
   8203          		if (fifo_mode_u8 < BMA2x2_FIFO_MODE_RANGE) {
   8204          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8205          			(p_bma2x2->dev_addr,
   8206          			BMA2x2_FIFO_MODE_REG, &data_u8,
   8207          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8208          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   8209          			BMA2x2_FIFO_MODE, fifo_mode_u8);
   8210          			data_u8 |= 0x0C;
   8211          			/*Power mode is switched to Standby power mode*/
   8212          			com_rslt += bma2x2_get_power_mode(&power_mode);
   8213          			com_rslt += bma2x2_set_power_mode(BMA2x2_MODE_STANDBY);
   8214          			/*Configure the mode in FIFO_CONFIG registers*/
   8215          			com_rslt += bma2x2_write_reg(
   8216          			BMA2x2_FIFO_MODE_REG,
   8217          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   8218          			if (com_rslt == SUCCESS) {
   8219          				/*FIFO config is stored in struct p_bma2x2*/
   8220          				p_bma2x2->fifo_config = data_u8;
   8221          			}
   8222          			/*Power mode is reverted to previously set mode */
   8223          			com_rslt += bma2x2_set_power_mode(power_mode);
   8224          
   8225          		} else {
   8226          			com_rslt = E_OUT_OF_RANGE;
   8227          		}
   8228          	}
   8229          	return com_rslt;
   8230          }
   8231          /*!
   8232           * @brief This API is used to get
   8233           * the axis enable of fifo data select in the register 0x3E bit 0 and 1
   8234           *
   8235           *
   8236           *  @param fifo_data_select_u8 : The value of FIFO axis data select
   8237           *   fifo_data_select_u8    |    result
   8238           *  ------------------------- |------------------
   8239           *        0x00                |   XYZ
   8240           *        0x01                |   Y
   8241           *        0x02                |   X
   8242           *        0x03                |   Z
   8243           *
   8244           *
   8245           *
   8246           *	@return results of bus communication function
   8247           *	@retval 0 -> Success
   8248           *	@retval -1 -> Error
   8249           *
   8250           *
   8251           */
   8252          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_data_select(
   8253          u8 *fifo_data_select_u8)
   8254          {
   8255          		/*  Variable used to return value of
   8256          	communication routine*/
   8257          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8258          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8259          
   8260          	if (p_bma2x2 == BMA2x2_NULL) {
   8261          		/* Check the struct p_bma2x2 is empty */
   8262          		return E_BMA2x2_NULL_PTR;
   8263          		} else {
   8264          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   8265          			p_bma2x2->dev_addr,
   8266          			BMA2x2_FIFO_DATA_SELECT_REG,
   8267          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   8268          			*fifo_data_select_u8 = BMA2x2_GET_BITSLICE(data_u8,
   8269          			BMA2x2_FIFO_DATA_SELECT);
   8270          		}
   8271          	return com_rslt;
   8272          }
   8273          /*!
   8274           * @brief This API is used to set
   8275           * the axis enable of fifo data select in the register 0x3E bit 0 and 1
   8276           *
   8277           *
   8278           *  @param fifo_data_select_u8 : The value of FIFO axis data select
   8279           *   fifo_data_select_u8      |    result
   8280           *  ------------------------- |------------------
   8281           *        0x00                |   XYZ
   8282           *        0x01                |   Y
   8283           *        0x02                |   X
   8284           *        0x03                |   Z
   8285           *
   8286           *
   8287           *
   8288           *	@return results of bus communication function
   8289           *	@retval 0 -> Success
   8290           *	@retval -1 -> Error
   8291           *	@retval -127 -> Null Pointer Error
   8292           *
   8293           */
   8294          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_fifo_data_select(
   8295          u8 fifo_data_select_u8)
   8296          {
   8297          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8298          	u8 power_mode = BMA2x2_INIT_VALUE;
   8299          	/*  Variable used to return value of
   8300          	communication routine*/
   8301          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8302          
   8303          	if (p_bma2x2 == BMA2x2_NULL) {
   8304          		/* Check the struct p_bma2x2 is empty */
   8305          		com_rslt = E_BMA2x2_NULL_PTR;
   8306          	} else {
   8307          		if (fifo_data_select_u8 < BMA2x2_FIFO_DATA_SELECT_RANGE) {
   8308          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8309          			(p_bma2x2->dev_addr,
   8310          			BMA2x2_FIFO_DATA_SELECT_REG, &data_u8,
   8311          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8312          			data_u8 = BMA2x2_SET_BITSLICE
   8313          			(data_u8,
   8314          			BMA2x2_FIFO_DATA_SELECT, fifo_data_select_u8);
   8315          			data_u8 |= 0x0C;
   8316          			/*Power mode is switched to Standby power mode*/
   8317          			com_rslt += bma2x2_get_power_mode(&power_mode);
   8318          			com_rslt += bma2x2_set_power_mode(BMA2x2_MODE_STANDBY);
   8319          			/* Configure appropriate (X,Y,Z) axes data to be
   8320          			available in FIFO*/
   8321          			com_rslt += bma2x2_write_reg(
   8322          				BMA2x2_FIFO_DATA_SELECT_REG, &data_u8, 1);
   8323          			if (com_rslt == SUCCESS) {
   8324          				/*FIFO config is stored in struct p_bma2x2*/
   8325          				p_bma2x2->fifo_config = data_u8;
   8326          			}
   8327          			/*Power mode is reverted to previously set mode */
   8328          			com_rslt += bma2x2_set_power_mode(power_mode);
   8329          		} else {
   8330          			com_rslt = E_OUT_OF_RANGE;
   8331          		}
   8332          	}
   8333          	return com_rslt;
   8334          }
   8335          
   8336          /*!
   8337           *  @brief This API reads the FIFO data from the register 0x3F
   8338           *  and store the data in the user defined buffer mapped to the member
   8339           *  of structure "fifo_configuration"
   8340           *
   8341           *  @note Before calling this API user must map the following FIFO settings
   8342           *  required to read the FIFO data to the structure "fifo_configuration"
   8343           *    - Data buffer to store the FIFO data is mapped to
   8344           *      the structure member "fifo_data"
   8345           *    - Number of bytes to be read from FIFO is mapped to
   8346           *      the structure member "fifo_length"
   8347           *
   8348           *  @note The number of bytes to be read from the FIFO is specified in the
   8349           *  member "fifo_length" of the structure "fifo_configuration"
   8350           *
   8351           *  @param[in,out] fifo_conf : Structure containing the FIFO configurations
   8352           *  is passed as input and FIFO data of specified length is obtained as output
   8353           *
   8354           *  @return results of bus communication function
   8355           *  @retval 0 -> Success
   8356           *  @retval -1 -> Error
   8357           *  @retval -127 -> Null Pointer Error
   8358           *
   8359           */
   8360          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_fifo_data(
   8361          				struct fifo_configuration *fifo_conf)
   8362          {
   8363          	u8 fifo_frame_count = 0;
   8364          	u8 fifo_data_bytes = 0;
   8365          	u8 fifo_data_select = 0;
   8366          	/*  Variable used to return value of
   8367          	communication routine*/
   8368          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8369          
   8370          	if (p_bma2x2 == BMA2x2_NULL || fifo_conf->fifo_data == BMA2x2_NULL) {
   8371          		/* Check the struct p_bma2x2 is empty */
   8372          		com_rslt = E_BMA2x2_NULL_PTR;
   8373          	} else {
   8374          		/*Resetting the FIFO data byte index*/
   8375          		fifo_conf->accel_byte_start_index = 0;
   8376          		/*Frames in FIFO is stored */
   8377          		com_rslt = bma2x2_get_fifo_frame_count(&fifo_frame_count);
   8378          		/*FIFO data select value is stored*/
   8379          		com_rslt += bma2x2_get_fifo_data_select(&fifo_data_select);
   8380          		/*Number of bytes in FIFO is calculated*/
   8381          		if (fifo_data_select == BMA2x2_FIFO_XYZ_DATA_ENABLED) {
   8382          			/*Number of bytes in FIFO when XYZ data are enabled*/
   8383          			fifo_data_bytes = fifo_frame_count *
   8384          					BMA2x2_FIFO_XYZ_AXES_FRAME_SIZE;
   8385          		} else {
   8386          			/*No of bytes in FIFO when single axis data enabled*/
   8387          			fifo_data_bytes = fifo_frame_count *
   8388          					BMA2x2_FIFO_SINGLE_AXIS_FRAME_SIZE;
   8389          		}
   8390          		/*Handled the case where user requests to read more FIFO
   8391          		length than available FIFO data*/
   8392          		if (fifo_conf->fifo_length > fifo_data_bytes) {
   8393          			/*Number of bytes in FIFO is read entirely when user
   8394          			reads more FIFO data than available*/
   8395          			fifo_conf->fifo_length = fifo_data_bytes;
   8396          		}
   8397          		/*Read the FIFO data*/
   8398          		com_rslt += p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
   8399          			BMA2x2_FIFO_DATA_OUTPUT_ADDR, fifo_conf->fifo_data,
   8400          			fifo_conf->fifo_length);
   8401          	}
   8402          	return com_rslt;
   8403          }
   8404          
   8405          /*!
   8406           *  @brief This API extracts the accel data from the FIFO frames
   8407           *
   8408           *  @note The bma2x2_extract_accel() API should be called only after reading
   8409           *  the FIFO data by calling the bma2x2_read_fifo_data() API
   8410           *
   8411           *  @param[in,out] accel_frame      : Instance of the union where accel data
   8412           *                                    in FIFO is parsed and stored
   8413           *
   8414           *  @param[in,out] accel_frame_count: Number of Accel frames requested by user
   8415           *                                    is got as input and number of
   8416           *                                    accel frames parsed and stored is
   8417           *                                    returned as output to user
   8418           *
   8419           *  @param[in, out] fifo_conf       : FIFO configuration structure.
   8420           *                                    It provides the following as input
   8421           *                                        - user defined buffer
   8422           *                                        - length of FIFO data read
   8423           *                                    It returns the accel_byte_start_index
   8424           *                                    (index of accel bytes parsed from FIFO)
   8425           *
   8426           *  @return results of API execution status
   8427           *  @retval 0 -> Success
   8428           *  @retval -127 -> Error
   8429           *
   8430           */
   8431          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_extract_accel(union fifo_frame *accel_frame,
   8432          	u8 *accel_frame_count, struct fifo_configuration *fifo_conf)
   8433          {
   8434          	u8 data_index = 0;
   8435          	u8 accel_index = 0;
   8436          	u8 data_read_length = 0;
   8437          	u8 fifo_data_select = 0;
   8438          	/*  Variable used to return value of communication routine*/
   8439          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = 0;
   8440          
   8441          	if (p_bma2x2 == BMA2x2_NULL || fifo_conf->fifo_data == BMA2x2_NULL) {
   8442          		/* Check the struct p_bma2x2 is empty and FIFO data buffer
   8443          		not being mapped to  fifo_configuration structure */
   8444          		com_rslt = E_BMA2x2_NULL_PTR;
   8445          	} else {
   8446          		/* FIFO data enable value is stored in fifo_data_select*/
   8447          		fifo_data_select = p_bma2x2->fifo_config &
   8448          						BMA2x2_FIFO_DATA_ENABLED_MASK;
   8449          		/* FIFO bytes available for parsing is obtained in
   8450          		data_read_length*/
   8451          		get_accel_len_to_parse(&data_index, &data_read_length,
   8452          			*accel_frame_count, fifo_data_select, fifo_conf);
   8453          		/*Parse the FIFO data from accel byte start index to
   8454          		data_read_length*/
   8455          		for (; data_index < data_read_length; ) {
   8456          			unpack_accel_frame(accel_frame, &data_index,
   8457          				&accel_index, fifo_data_select, fifo_conf);
   8458          		}
   8459          		/* update number of accel data read*/
   8460          		*accel_frame_count = accel_index;
   8461          		/*update the accel byte index*/
   8462          		fifo_conf->accel_byte_start_index = data_index;
   8463          	}
   8464          	return com_rslt;
   8465          }
   8466          
   8467          /*!
   8468           *  @brief This API computes the number of bytes of accel FIFO data
   8469           *  which is to be parsed.
   8470           */
   8471          static void get_accel_len_to_parse(u8 *data_index, u8 *data_read_length,
   8472          	u8 accel_frame_count, u8 fifo_data_select,
   8473          	struct fifo_configuration *fifo_conf)
   8474          {
   8475          	/*Current data index is set to accel_byte_start_index*/
   8476          	*data_index = fifo_conf->accel_byte_start_index;
   8477          	/* FIFO bytes corresponding to the requested FIFO frames is obtained*/
   8478          	if (fifo_data_select == BMA2x2_FIFO_XYZ_DATA_ENABLED) {
   8479          		/*Number of bytes in FIFO when XYZ data are enabled*/
   8480          		*data_read_length = accel_frame_count *
   8481          					BMA2x2_FIFO_XYZ_AXES_FRAME_SIZE;
   8482          	} else {
   8483          		/*No of bytes in FIFO when single axis data enabled*/
   8484          		*data_read_length = accel_frame_count *
   8485          					BMA2x2_FIFO_SINGLE_AXIS_FRAME_SIZE;
   8486          	}
   8487          	if ((*data_read_length) > fifo_conf->fifo_length) {
   8488          		/*Handling the case where more FIFO frame is requested
   8489          		than available*/
   8490          		*data_read_length = fifo_conf->fifo_length;
   8491          	}
   8492          }
   8493          
   8494          /*!
   8495           *  @brief This API is used to parse the accelerometer frame from the
   8496           *  user defined FIFO data buffer mapped to the structure fifo_conf and store
   8497           *  it in the union fifo_frame
   8498           *
   8499           *  @note It update the data_index value which is used to store the index of
   8500           *  the current data byte which is parsed.
   8501           *
   8502           *  @note The parsed accel frames stored in the union fifo_conf contains data
   8503           *  in accordance with the enabled data axes to be stored in FIFO
   8504           *  (XYZ axes or individual axis)
   8505           */
   8506          static void unpack_accel_frame(union fifo_frame *accel_frame, u8 *data_index,
   8507          	u8 *accel_index, u8 fifo_data_select,
   8508          	struct fifo_configuration *fifo_conf)
   8509          {
   8510          	u16 data_lsb = 0;
   8511          	u16 data_msb = 0;
   8512          
   8513          	switch (fifo_data_select) {
   8514          
   8515          	case BMA2x2_FIFO_XYZ_DATA_ENABLED:
   8516          		unpack_accel_xyz(&accel_frame[*accel_index], data_index,
   8517          								fifo_conf);
   8518          		/* Accel index is updated*/
   8519          		(*accel_index)++;
   8520          	break;
   8521          
   8522          	case BMA2x2_FIFO_X_DATA_ENABLED:
   8523          		/* Accel raw x data */
   8524          		data_lsb = fifo_conf->fifo_data[(*data_index)++];
   8525          		data_msb = fifo_conf->fifo_data[(*data_index)++];
   8526          		accel_frame[*accel_index].x = (u16)((data_msb << 8) | data_lsb);
   8527          
   8528          		/* Resolution based data from FIFO is updated */
   8529          		if (V_BMA2x2RESOLUTION_U8 == BMA2x2_12_RESOLUTION) {
   8530          			accel_frame[*accel_index].x =
   8531          					(accel_frame[*accel_index].x >> 4);
   8532          		} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_14_RESOLUTION) {
   8533          			accel_frame[*accel_index].x =
   8534          					(accel_frame[*accel_index].x >> 2);
   8535          		} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_10_RESOLUTION) {
   8536          			accel_frame[*accel_index].x =
   8537          					(accel_frame[*accel_index].x >> 6);
   8538          		}
   8539          		/* Accel index is updated*/
   8540          		(*accel_index)++;
   8541          	break;
   8542          
   8543          	case BMA2x2_FIFO_Y_DATA_ENABLED:
   8544          		/* Accel raw y data */
   8545          		data_lsb = fifo_conf->fifo_data[(*data_index)++];
   8546          		data_msb = fifo_conf->fifo_data[(*data_index)++];
   8547          		accel_frame[*accel_index].y = (u16)((data_msb << 8) | data_lsb);
   8548          
   8549          		/* Resolution based data from FIFO is updated */
   8550          		if (V_BMA2x2RESOLUTION_U8 == BMA2x2_12_RESOLUTION) {
   8551          			accel_frame[*accel_index].y =
   8552          					(accel_frame[*accel_index].y >> 4);
   8553          		} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_14_RESOLUTION) {
   8554          			accel_frame[*accel_index].y =
   8555          					(accel_frame[*accel_index].y >> 2);
   8556          		} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_10_RESOLUTION) {
   8557          			accel_frame[*accel_index].y =
   8558          					(accel_frame[*accel_index].y >> 6);
   8559          		}
   8560          		/* Accel index is updated*/
   8561          		(*accel_index)++;
   8562          	break;
   8563          
   8564          	case BMA2x2_FIFO_Z_DATA_ENABLED:
   8565          		/* Accel raw z data */
   8566          		data_lsb = fifo_conf->fifo_data[(*data_index)++];
   8567          		data_msb = fifo_conf->fifo_data[(*data_index)++];
   8568          		accel_frame[*accel_index].z = (u16)((data_msb << 8) | data_lsb);
   8569          
   8570          		/* Resolution based data from FIFO is updated */
   8571          		if (V_BMA2x2RESOLUTION_U8 == BMA2x2_12_RESOLUTION) {
   8572          			accel_frame[*accel_index].z =
   8573          					(accel_frame[*accel_index].z >> 4);
   8574          		} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_14_RESOLUTION) {
   8575          			accel_frame[*accel_index].z =
   8576          					(accel_frame[*accel_index].z >> 2);
   8577          		} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_10_RESOLUTION) {
   8578          			accel_frame[*accel_index].z =
   8579          					(accel_frame[*accel_index].z >> 6);
   8580          		}
   8581          		/* Accel index is updated*/
   8582          		(*accel_index)++;
   8583          	break;
   8584          
   8585          	default:
   8586          	break;
   8587          	}
   8588          }
   8589          
   8590          /*!
   8591           *  @brief This API is used to parse the accelerometer data and
   8592           *  store it in the union fifo_frame
   8593           *  It also updates the data_index value which stores the index of
   8594           *  the current data byte which is parsed
   8595           *
   8596           */
   8597          static void unpack_accel_xyz(union fifo_frame *accel_frame, u8 *data_index,
   8598          	struct fifo_configuration *fifo_conf)
   8599          {
   8600          	u16 data_lsb = 0;
   8601          	u16 data_msb = 0;
   8602          
   8603          	/* Accel raw x data */
   8604          	data_lsb = fifo_conf->fifo_data[(*data_index)++];
   8605          	data_msb = fifo_conf->fifo_data[(*data_index)++];
   8606          	accel_frame->accel_data.x = (u16)((data_msb << 8) | data_lsb);
   8607          
   8608          	/* Accel raw y data */
   8609          	data_lsb = fifo_conf->fifo_data[(*data_index)++];
   8610          	data_msb = fifo_conf->fifo_data[(*data_index)++];
   8611          	accel_frame->accel_data.y = (u16)((data_msb << 8) | data_lsb);
   8612          
   8613          	/* Accel raw z data */
   8614          	data_lsb = fifo_conf->fifo_data[(*data_index)++];
   8615          	data_msb = fifo_conf->fifo_data[(*data_index)++];
   8616          	accel_frame->accel_data.z = (u16)((data_msb << 8) | data_lsb);
   8617          
   8618          	/* Resolution based data from FIFO is updated */
   8619          	if (V_BMA2x2RESOLUTION_U8 == BMA2x2_12_RESOLUTION) {
   8620          		accel_frame->accel_data.x = (accel_frame->accel_data.x >> 4);
   8621          		accel_frame->accel_data.y = (accel_frame->accel_data.y >> 4);
   8622          		accel_frame->accel_data.z = (accel_frame->accel_data.z >> 4);
   8623          	} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_14_RESOLUTION) {
   8624          		accel_frame->accel_data.x = (accel_frame->accel_data.x >> 2);
   8625          		accel_frame->accel_data.y = (accel_frame->accel_data.y >> 2);
   8626          		accel_frame->accel_data.z = (accel_frame->accel_data.z >> 2);
   8627          	} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_10_RESOLUTION) {
   8628          		accel_frame->accel_data.x = (accel_frame->accel_data.x >> 6);
   8629          		accel_frame->accel_data.y = (accel_frame->accel_data.y >> 6);
   8630          		accel_frame->accel_data.z = (accel_frame->accel_data.z >> 6);
   8631          	}
   8632          }
   8633          
   8634          /*!
   8635           * @brief This API is used to read the temp
   8636           * from register 0x08
   8637           *
   8638           *
   8639           *
   8640           *  @param  temp_s8: The value of temperature
   8641           *
   8642           *
   8643           *
   8644           *	@return results of bus communication function
   8645           *	@retval 0 -> Success
   8646           *	@retval -1 -> Error
   8647           *
   8648           *
   8649          */
   8650          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_temp(s8 *temp_s8)
   8651          {
   8652          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8653          		/*  Variable used to return value of
   8654          	communication routine*/
   8655          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8656          
   8657          	if (p_bma2x2 == BMA2x2_NULL) {
   8658          		/* Check the struct p_bma2x2 is empty */
   8659          		return E_BMA2x2_NULL_PTR;
   8660          		} else {
   8661          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   8662          			p_bma2x2->dev_addr,
   8663          			BMA2x2_TEMP_ADDR,
   8664          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   8665          			*temp_s8 = (s8)data_u8;
   8666          		}
   8667          	return com_rslt;
   8668          }
   8669          /*!
   8670           * @brief This API reads accelerometer data X,Y,Z values and
   8671           * temperature data from location 02h to 08h
   8672           *
   8673           *
   8674           *
   8675           *
   8676           *  @param accel : The value of accel xyz and temperature data
   8677           *
   8678           *	@return results of bus communication function
   8679           *	@retval 0 -> Success
   8680           *	@retval -1 -> Error
   8681           *
   8682           *
   8683          */
   8684          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_xyzt(
   8685          struct bma2x2_accel_data_temp *accel)
   8686          {
   8687          	/*  Variable used to return value of
   8688          	communication routine*/
   8689          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8690          	u8 data_u8[BMA2x2_ACCEL_XYZ_TEMP_DATA_SIZE] = {
   8691          	BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE,
   8692          	BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE,
   8693          	BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE,
   8694          	BMA2x2_INIT_VALUE};
   8695          	if (p_bma2x2 == BMA2x2_NULL) {
   8696          		/* Check the struct p_bma2x2 is empty */
   8697          		return E_BMA2x2_NULL_PTR;
   8698          		} else {
   8699          		switch (V_BMA2x2RESOLUTION_U8) {
   8700          		case BMA2x2_12_RESOLUTION:
   8701          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8702          			(p_bma2x2->dev_addr, BMA2x2_ACCEL_X12_LSB_REG,
   8703          			data_u8, BMA2x2_ACCEL_BW_MIN_RANGE);
   8704          
   8705          			/* read x data_u8*/
   8706          			accel->x = (s16)((((s32)((s8)
   8707          			data_u8[BMA2x2_SENSOR_DATA_XYZ_X_MSB]))
   8708          			<< BMA2x2_SHIFT_EIGHT_BITS)|
   8709          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_X_LSB]
   8710          			& BMA2x2_12_BIT_SHIFT));
   8711          			accel->x = accel->x >> BMA2x2_SHIFT_FOUR_BITS;
   8712          
   8713          			/* read y data_u8*/
   8714          			accel->y = (s16)((((s32)((s8)
   8715          			data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_MSB]))
   8716          			<< BMA2x2_SHIFT_EIGHT_BITS)|
   8717          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_LSB]
   8718          			& BMA2x2_12_BIT_SHIFT));
   8719          			accel->y = accel->y >> BMA2x2_SHIFT_FOUR_BITS;
   8720          
   8721          			/* read z data_u8*/
   8722          			accel->z = (s16)((((s32)((s8)
   8723          			data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_MSB]))
   8724          			<< BMA2x2_SHIFT_EIGHT_BITS)|
   8725          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_LSB]
   8726          			& BMA2x2_12_BIT_SHIFT));
   8727          			accel->z = accel->z >> BMA2x2_SHIFT_FOUR_BITS;
   8728          			/*Accessing the sixth element of array*/
   8729          			accel->temp = (s8)data_u8[BMA2x2_SENSOR_DATA_TEMP];
   8730          		break;
   8731          		case BMA2x2_10_RESOLUTION:
   8732          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8733          			(p_bma2x2->dev_addr, BMA2x2_ACCEL_X10_LSB_REG,
   8734          			data_u8, BMA2x2_ACCEL_BW_MIN_RANGE);
   8735          
   8736          			/* read x data_u8*/
   8737          			accel->x = (s16)((((s32)((s8)
   8738          			data_u8[BMA2x2_SENSOR_DATA_XYZ_X_MSB]))<<
   8739          			BMA2x2_SHIFT_EIGHT_BITS)|
   8740          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_X_LSB]
   8741          			& BMA2x2_10_BIT_SHIFT));
   8742          			accel->x = accel->x >> BMA2x2_SHIFT_SIX_BITS;
   8743          
   8744          			/* read y data_u8*/
   8745          			accel->y = (s16)((((s32)((s8)
   8746          			data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_MSB]))<<
   8747          			BMA2x2_SHIFT_EIGHT_BITS)|
   8748          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_LSB]
   8749          			& BMA2x2_10_BIT_SHIFT));
   8750          			accel->y = accel->y >> BMA2x2_SHIFT_SIX_BITS;
   8751          
   8752          			/* read z data_u8*/
   8753          			accel->z = (s16)((((s32)((s8)
   8754          			data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_MSB]))<<
   8755          			BMA2x2_SHIFT_EIGHT_BITS)|
   8756          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_LSB]
   8757          			& BMA2x2_10_BIT_SHIFT));
   8758          			accel->z = accel->z >> BMA2x2_SHIFT_SIX_BITS;
   8759          
   8760          			/* read temp_s8 data_u8*/
   8761          			/*Accessing the sixth element of array*/
   8762          			accel->temp = (s8)data_u8[BMA2x2_SENSOR_DATA_TEMP];
   8763          		break;
   8764          		case BMA2x2_14_RESOLUTION:
   8765          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8766          			(p_bma2x2->dev_addr, BMA2x2_ACCEL_X14_LSB_REG,
   8767          			data_u8, BMA2x2_ACCEL_BW_MIN_RANGE);
   8768          
   8769          			/* read x data_u8*/
   8770          			accel->x = (s16)((((s32)((s8)
   8771          			data_u8[BMA2x2_SENSOR_DATA_XYZ_X_MSB]))<<
   8772          			BMA2x2_SHIFT_EIGHT_BITS)|
   8773          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_X_LSB]
   8774          			& BMA2x2_14_BIT_SHIFT));
   8775          			accel->x = accel->x >> BMA2x2_SHIFT_TWO_BITS;
   8776          
   8777          			/* read y data_u8*/
   8778          			accel->y = (s16)((((s32)((s8)
   8779          			data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_MSB]))<<
   8780          			BMA2x2_SHIFT_EIGHT_BITS)|
   8781          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_LSB]
   8782          			& BMA2x2_14_BIT_SHIFT));
   8783          			accel->y = accel->y >> BMA2x2_SHIFT_TWO_BITS;
   8784          
   8785          			/* read z data_u8*/
   8786          			accel->z = (s16)((((s32)((s8)
   8787          			data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_MSB]))<<
   8788          			BMA2x2_SHIFT_EIGHT_BITS)|
   8789          			(data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_LSB]
   8790          			& BMA2x2_14_BIT_SHIFT));
   8791          			accel->z = accel->z >> BMA2x2_SHIFT_TWO_BITS;
   8792          			/* read temp data_u8*/
   8793          			/*Accessing the sixth element of array*/
   8794          			accel->temp = (s8)data_u8[BMA2x2_SENSOR_DATA_TEMP];
   8795          		break;
   8796          		default:
   8797          		break;
   8798          		}
   8799          	}
   8800          	return com_rslt;
   8801          }
   8802          /*!
   8803           * @brief This API reads accelerometer data X,Y,Z values and
   8804           * temperature data from location 0x02 to 0x08
   8805           *
   8806           *
   8807           *
   8808           *
   8809           *  @param accel : The value of accel xyz and temperature data
   8810           *
   8811           *	@return results of bus communication function
   8812           *	@retval 0 -> Success
   8813           *	@retval -1 -> Error
   8814           *
   8815           *
   8816          */
   8817          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_eight_resolution_xyzt(
   8818          struct bma2x2_accel_eight_resolution_temp *accel)
   8819          {
   8820          	/*  Variable used to return value of
   8821          	communication routine*/
   8822          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8823          	u8	data_u8 = BMA2x2_INIT_VALUE;
   8824          
   8825          	if (p_bma2x2 == BMA2x2_NULL) {
   8826          		/* Check the struct p_bma2x2 is empty */
   8827          		return E_BMA2x2_NULL_PTR;
   8828          		} else {
   8829          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8830          			(p_bma2x2->dev_addr,
   8831          			BMA2x2_X_AXIS_MSB_ADDR, &data_u8,
   8832          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8833          			accel->x = BMA2x2_GET_BITSLICE(data_u8,
   8834          			BMA2x2_ACCEL_X_MSB);
   8835          
   8836          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8837          			(p_bma2x2->dev_addr,
   8838          			BMA2x2_Y_AXIS_MSB_ADDR, &data_u8,
   8839          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8840          			accel->y = BMA2x2_GET_BITSLICE(data_u8,
   8841          			BMA2x2_ACCEL_Y_MSB);
   8842          
   8843          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8844          			(p_bma2x2->dev_addr,
   8845          			BMA2x2_Z_AXIS_MSB_ADDR, &data_u8,
   8846          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8847          			accel->z = BMA2x2_GET_BITSLICE(data_u8,
   8848          			BMA2x2_ACCEL_Z_MSB);
   8849          
   8850          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   8851          			p_bma2x2->dev_addr, BMA2x2_TEMP_ADDR, &data_u8,
   8852          			BMA2x2_GEN_READ_WRITE_LENGTH);
   8853          			accel->temp = (s8)data_u8;
   8854          		}
   8855          	return com_rslt;
   8856          }
   8857          
   8858          /*!
   8859           *	@brief This API is used to get
   8860           *	the fifo data in the register 0x3F bit 0 to 7
   8861           *
   8862           *
   8863           *  @param  output_reg_u8 : The value of fifo data
   8864           *
   8865           *
   8866           *
   8867           *	@return results of bus communication function
   8868           *	@retval 0 -> Success
   8869           *	@retval -1 -> Error
   8870           *
   8871           *
   8872          */
   8873          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_data_output_reg(
   8874          u8 *output_reg_u8)
   8875          {
   8876          	/*#warning This API is deprecated ,Instead use the \
   8877          	"bma2x2_read_fifo_data" API for reading FIFO data*/
   8878          
   8879          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8880          	/*Variable used to return value of
   8881          	communication routine*/
   8882          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8883          
   8884          	if (p_bma2x2 == BMA2x2_NULL) {
   8885          		/* Check the struct p_bma2x2 is empty */
   8886          		return E_BMA2x2_NULL_PTR;
   8887          		} else {
   8888          			/*GET FIFO DATA OUTPUT REGISTER*/
   8889          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   8890          			p_bma2x2->dev_addr,
   8891          			BMA2x2_FIFO_DATA_OUTPUT_ADDR,
   8892          			&data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   8893          			*output_reg_u8 = data_u8;
   8894          		}
   8895          	return com_rslt;
   8896          }

   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?_0
       2  ?_1
       2  ?_2
       6  ?_3
       7  ?_4
       1  V_BMA2x2RESOLUTION_U8
      72  bma2x2_burst_read
     138  bma2x2_extract_accel
      89  bma2x2_get_bw
      88  bma2x2_get_cal_rdy
     249  bma2x2_get_durn
      83  bma2x2_get_fifo_data_output_reg
      85  bma2x2_get_fifo_data_select
      85  bma2x2_get_fifo_frame_count
      87  bma2x2_get_fifo_mode
      86  bma2x2_get_fifo_overrun
      69  bma2x2_get_fifo_stat
      85  bma2x2_get_fifo_wml_trig
      88  bma2x2_get_flat_hold_time
      85  bma2x2_get_flat_hyst
      86  bma2x2_get_high_bw
     148  bma2x2_get_i2c_wdt
      87  bma2x2_get_intr1_fifo_full
      86  bma2x2_get_intr1_fifo_wm
      89  bma2x2_get_intr2_fifo_full
      89  bma2x2_get_intr2_fifo_wm
     151  bma2x2_get_intr_double_tap
     720  bma2x2_get_intr_enable
      89  bma2x2_get_intr_fifo_full
      89  bma2x2_get_intr_fifo_wm
     147  bma2x2_get_intr_flat
     147  bma2x2_get_intr_high_g
     149  bma2x2_get_intr_level
     145  bma2x2_get_intr_low_g
     153  bma2x2_get_intr_orient
      69  bma2x2_get_intr_orient_stat
     151  bma2x2_get_intr_output_type
     153  bma2x2_get_intr_single_tap
     149  bma2x2_get_intr_slope
     151  bma2x2_get_intr_slow_no_motion
      69  bma2x2_get_intr_stat
      69  bma2x2_get_intr_tap_stat
      85  bma2x2_get_latch_intr
      87  bma2x2_get_low_g_mode
     147  bma2x2_get_low_high_g_hyst
     146  bma2x2_get_new_data
      87  bma2x2_get_nvmprog_mode
      89  bma2x2_get_nvmprog_ready
      88  bma2x2_get_nvmprog_remain
     192  bma2x2_get_offset
     261  bma2x2_get_offset_target
      87  bma2x2_get_orient_block
      89  bma2x2_get_orient_enable
      88  bma2x2_get_orient_hyst
      85  bma2x2_get_orient_mode
     262  bma2x2_get_power_mode
      89  bma2x2_get_range
      85  bma2x2_get_selftest_axis
      87  bma2x2_get_selftest_sign
      89  bma2x2_get_shadow_dis
      86  bma2x2_get_sleep_durn
      89  bma2x2_get_sleep_timer_mode
     201  bma2x2_get_slow_comp
     259  bma2x2_get_slow_no_motion
     376  bma2x2_get_source
      85  bma2x2_get_spi3
      85  bma2x2_get_tap_durn
      86  bma2x2_get_tap_quiet
      87  bma2x2_get_tap_sample
      89  bma2x2_get_tap_shock
      85  bma2x2_get_tap_thres
     143  bma2x2_get_theta
     245  bma2x2_get_thres
     120  bma2x2_init
      83  bma2x2_read_accel_eight_resolution_x
     176  bma2x2_read_accel_eight_resolution_xyz
     223  bma2x2_read_accel_eight_resolution_xyzt
      83  bma2x2_read_accel_eight_resolution_y
      83  bma2x2_read_accel_eight_resolution_z
     325  bma2x2_read_accel_x
     679  bma2x2_read_accel_xyz
     703  bma2x2_read_accel_xyzt
     325  bma2x2_read_accel_y
     325  bma2x2_read_accel_z
     169  bma2x2_read_fifo_data
      72  bma2x2_read_reg
      83  bma2x2_read_temp
     108  bma2x2_rst_intr
     401  bma2x2_set_bw
     111  bma2x2_set_cal_trigger
     262  bma2x2_set_durn
     176  bma2x2_set_fifo_data_select
     181  bma2x2_set_fifo_mode
     154  bma2x2_set_fifo_wml_trig
     110  bma2x2_set_flat_hold_time
     107  bma2x2_set_flat_hyst
     108  bma2x2_set_high_bw
     213  bma2x2_set_i2c_wdt
     121  bma2x2_set_intr1_fifo_full
     120  bma2x2_set_intr1_fifo_wm
     123  bma2x2_set_intr2_fifo_full
     123  bma2x2_set_intr2_fifo_wm
     216  bma2x2_set_intr_double_tap
     481  bma2x2_set_intr_enable
     123  bma2x2_set_intr_fifo_full
     123  bma2x2_set_intr_fifo_wm
     212  bma2x2_set_intr_flat
     212  bma2x2_set_intr_high_g
     214  bma2x2_set_intr_level
     210  bma2x2_set_intr_low_g
     218  bma2x2_set_intr_orient
     216  bma2x2_set_intr_output_type
     218  bma2x2_set_intr_single_tap
     214  bma2x2_set_intr_slope
     216  bma2x2_set_intr_slow_no_motion
     278  bma2x2_set_latch_intr
     109  bma2x2_set_low_g_mode
     212  bma2x2_set_low_high_g_hyst
     153  bma2x2_set_mode_value
     211  bma2x2_set_new_data
     109  bma2x2_set_nvmprog_mode
     110  bma2x2_set_nvprog_trig
     125  bma2x2_set_offset
     108  bma2x2_set_offset_rst
     384  bma2x2_set_offset_target
     109  bma2x2_set_orient_block
     111  bma2x2_set_orient_enable
     110  bma2x2_set_orient_hyst
     107  bma2x2_set_orient_mode
     372  bma2x2_set_power_mode
     182  bma2x2_set_range
     119  bma2x2_set_selftest_axis
     121  bma2x2_set_selftest_sign
     111  bma2x2_set_shadow_dis
     245  bma2x2_set_sleep_durn
     123  bma2x2_set_sleep_timer_mode
     296  bma2x2_set_slow_comp
     382  bma2x2_set_slow_no_motion
     557  bma2x2_set_source
     107  bma2x2_set_spi3
     107  bma2x2_set_tap_durn
     108  bma2x2_set_tap_quiet
     109  bma2x2_set_tap_sample
     111  bma2x2_set_tap_shock
     107  bma2x2_set_tap_thres
     154  bma2x2_set_theta
     150  bma2x2_set_thres
      47  bma2x2_soft_rst
      94  bma2x2_update_image
     106  bma2x2_write_reg
      56  get_accel_len_to_parse
       2  p_bma2x2
     979  unpack_accel_frame
     423  unpack_accel_xyz

 
 24 776 bytes in section .far_func.text
      3 bytes in section .near.bss
     19 bytes in section .near.rodata
 
 24 776 bytes of CODE  memory
     19 bytes of CONST memory
      3 bytes of DATA  memory

Errors: none
Warnings: none
